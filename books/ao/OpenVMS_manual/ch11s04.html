<html>
<!-- Mirrored [from host tinco.pair.com [file /bhaskar/gtm/doc/books/ao/OpenVMS_manual/ch11s04.html]] -->
<head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Finding and Fixing Database Errors</title><link rel="stylesheet" href="gtm.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="titlepage.html" title="GT.M Administration and Operations Guide"><link rel="up" href="ch11.html" title="Chapter 11. Maintaining Database Integrity"><link rel="prev" href="ch11s03.html" title="Repairing the Database with DSE"><link rel="next" href="go01.html" title="Glossary"><link rel="copyright" href="ln-id3218893.html" title="Legal Notice"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Finding and Fixing Database Errors</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch11s03.html">Prev</a> </td><th width="60%" align="center">Chapter 11. Maintaining Database Integrity</th><td width="20%" align="right"> <a accesskey="n" href="go01.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Finding and Fixing Database Errors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="finding_and_fixing_db_errors"></a>Finding and Fixing Database Errors</h2></div></div></div><p>The rest of this chapter is arranged loosely in the form of a decision tree. The
material covers a wide range of scenarios and possible actions. </p><p>As you begin the decision-making process, follow these general guidelines from
this point:</p><p>
<span class="italic">IF THE SYMPTOM IS A FAILURE TO PROCESS,</span> refer
to section H1.</p><p>
<span class="italic">IF THE SYMPTOM IS A MUPIP INTEG ERROR REPORT</span>,
refer to section I1. If you are investigating a particular error message, refer to
the "MUPIP INTEG errors" table. </p><p>
<span class="italic">IF THE SYMPTOM IS A GT.M RUN-TIME ERROR REPORT</span>,
refer to section R1. If you are investigating a particular error message, refer to
the"MUPIP INTEG errors" table.</p><p>To facilitate use of the material as a troubleshooting guide, the text in these
sections refers to other sections with alphanumeric designators. Each alphanumeric
section describes suggested actions to employ in handling a particular
situation.</p><div class="sect2" title="C1&#8211;Possible Cache Control Problems"><div class="titlepage"><div><div><h3 class="title"><a name="c1_possible_cache_control_problems"></a>C1&#8211;Possible Cache Control Problems</h3></div></div></div><p>When a process detects that a normal cache operating principal has been
violated, or that a cache operation is taking an unexpectedly long time, that
process triggers a cache verification and rebuild. Such events can be caused by
abnormal process termination, or by inappropriately configured or managed
database storage subsystems.</p><p>When such an event occurs, GT.M sends a series of messages to the operator
facility describing the results of the cache verification. If the cache rebuild
is successful, no further immediate action is required. If the cache rebuild
fails, the database administrator must close off access to the database and use
DSE (CRIT and WCINIT) and MUPIP (INTEG) to reset the cache manually and verify
that the database is not damaged.</p><p>If such events are delivered to the operator facility, you should investigate
whether it is appropriate to modify your procedures to prevent abnormal
termination, to reconfigure your disk subsystem, or to change the nature or
schedule of disk activities so that database access is not disrupted during key
periods of operation.</p></div><div class="sect2" title="H1&#8211;Process Hangs"><div class="titlepage"><div><div><h3 class="title"><a name="h1_process_hangs"></a>H1&#8211;Process Hangs</h3></div></div></div><p>The term "hang" refers to a failure to process. Processes may hang for a
variety of reasons that have nothing to do with GT.M. However, hanging GT.M
processes may indicate that a database has become inaccessible. When you suspect
a hang, first determine the extent of the problem.</p><p>Your tools include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Knowledge of the application and how it is used</p></li><li class="listitem"><p>Communication with users</p></li><li class="listitem"><p>The DCL command SHOW SYSTEM</p></li><li class="listitem"><p>The DCL command SHOW PROCESS /CONTINUOUS /IDENTIFICATION=</p></li><li class="listitem"><p>The MONITOR utility program, invoked by the DCL command MONITOR</p></li></ul></div><p>
<span class="italic">WHEN MANY PROCESSES ON A SYSTEM ARE
HANGING</span>, determine if the hangs are confined to a particular
application. If all applications are affected or if processes not using GT.M
databases are affected, the problem is not a database-specific problem, but
something more general, such as <span>an OpenVMS</span>
 problem. Refer to section H6.</p><p>
<span class="italic">WHEN ONLY ONE PROCESS IS HANGING</span>, find out
whether that process is the only one using a particular GT.M application. If it
is the only process, start some appropriate second process and determine whether
the second process is also affected.</p><p>
<span class="italic">IF A PROCESS HANGS WHILE OTHER PROCESSES ACCESSING THE
SAME DATABASE CONTINUE TO PROCESS,</span> the problem is not a database
problem. Refer to section H2 and then to section H8.</p><p>
<span class="italic">WHEN ONLY GT.M PROCESSES RUNNING A PARTICULAR
APPLICATION HANG,</span>the problem may be a database problem. Refer to
section H2.</p><p>Is the system "hung?" If so, consider the following additional
questions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Does LKE work? If not, then a database has problems (see
below).</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Are there locks owned by a nonexistent process? Can they be
cleared? What were the circumstances of a process leaving locks?
</p></li><li class="listitem"><p>Are there locks which are not changing? What is the state of
the owning process(es)? If not all processes are hung, can the
stalled process(es) be MUPIP STOPped? </p></li></ul></div></li><li class="listitem"><p>Does some region have a "persistent" owner of the critical section
(crit)? Which one(s)? </p></li><li class="listitem"><p>If there is a crit owner, what is its state? If it is a nonexistent
process can it be <span>/</span>REMOVED?</p></li><li class="listitem"><p>Does a CRIT <span>/</span>INIT <span>/</span>RESET free the section or just change who owns it? </p></li><li class="listitem"><p>If CRIT <span>/</span>INIT
<span>/</span>RESET doesn't
free the problem, the cache is damaged.</p></li></ul></div><p>The following is another way of testing the cache: If CRIT is cleared and DSE
BUFFER hangs, the cache is not working. Use MUPIP STOP and/or CRIT <span>/</span>INIT <span>/</span>RESET to get everyone out of the
segment, then use DSE WCINIT. After a WCINIT, make sure that you can
successfully exit from DSE. Use MUPIP INTEG (<span>/</span>FAST) to check for damage which can be induced by
WCINIT.</p></div><div class="sect2" title="Handling a Hung Process"><div class="titlepage"><div><div><h3 class="title"><a name="handling_a_hang_process"></a>Handling a Hung Process</h3></div></div></div><p>This procedure is best used when you know that a "hung" process is the
problem.</p><div class="sect3" title="General Advice"><div class="titlepage"><div><div><h4 class="title"><a name="general_advice"></a>General Advice</h4></div></div></div><p>To ensure that nothing interferes with the operator trying to correct a
problem, use the DCL command:</p><pre class="programlisting">SET PROC/PRIO=15
</pre><p>To prevent commands being rejected due to privilege requirements,</p><pre class="programlisting">SET PROC/PRIV=(list-of-required-privileges)
</pre><p>Remember to restore PRIORITY and PRIVILEGES to their normal settings when
the analysis and recovery is complete.</p><p>All GT.M executable images and command files are in GTM$DIST. This
document assumes that you have symbols defined for the GT.M
utilities.</p></div><div class="sect3" title="Capturing Diagnostic Information"><div class="titlepage"><div><div><h4 class="title"><a name="capture_diagnostic_info"></a>Capturing Diagnostic Information</h4></div></div></div><p>Run</p><pre class="programlisting">CCE DUMP/DB
</pre><p>Invoke</p><pre class="programlisting">ANAL/SYSTEM
</pre><p>This always requires CMKRNL privileges and may require WORLD
privileges.</p><pre class="programlisting">SDA&gt;SET LOG file-spec
</pre><p>to an appropriate file.</p><pre class="programlisting">SDA&gt;SHOW SUMMARY
</pre><p>to find the index of the process we wish to analyze; the index most
frequently is the last 2 [hexadecimal] digits of the PID.</p><pre class="programlisting">SDA&gt;SET PROC/INDEX=index
SDA&gt;SHOW PROC/IMAGE
</pre><p>to get a load map.</p><pre class="programlisting">SDA&gt; SHOW PROC/REGISTER
</pre><p>to get the current registers.</p><pre class="programlisting">SDA&gt;SHOW CALL
</pre><p>to get the first call frame.</p><pre class="programlisting">SDA&gt;SHOW CALL/NEXT
</pre><p>to get additional call frames; repeat the SHOW CALL /NEXT for all frames
until you get a "not in physical memory" message.</p><pre class="programlisting">SDA&gt;EXIT
</pre></div><div class="sect3" title="Stopping Processes"><div class="titlepage"><div><div><h4 class="title"><a name="stopping_processes_ch11"></a>Stopping Processes</h4></div></div></div><p>These are general instructions for stopping processes. Read the entire
section before choosing one.</p><p>When stopping processes, the preferred choice is to get them to abort in
their own way, which preserves the integrity of the data at the application
level. If they are on accessible terminals, use standard exits, or press
&lt;CTRL-C&gt;, if appropriate. If you have access to the system users, call
them or send them e-mail asking them to try these standard exit
procedures.</p><p>If you cannot get direct or indirect access to active processes, or if
they do not respond, try MUPIP STOP /ID=pid. MUPIP STOP uses the FORCEX
system service, which takes a few seconds to work. Wait five seconds before
checking. FORCEX terminates an image rather than the entire process. If GT.M
is invoked from a command procedure or DETACHed, termination of the image
generally also terminates the process. However, in other cases, termination
of the image causes the process to drop back to DCL and wait for
commands.</p><p>If MUPIP STOP /ID=pid does not work, use STOP /ID=pid that deletes the
process.</p><p>If you want to stop all processes with access to a particular database,
and you can gain access to that database with DSE, FIND/REGION=region
followed by CRIT /INIT /RESET. This should generate an error for all
processes that are currently attempting to access a database.</p><p>The error should invoke the error handling code of the application that
should perform appropriate clean-up. If the application error handling does
not cause the process to terminate on a CRIT /RESET error, this approach may
not achieve the desired result.</p><p>If you want to shut down GT.CM, RUN GTM$DIST: GTCM_STOP or invoke
@GTM$DIST:GTCMSTOP.COM. If you want to stop all GT.M processes, RUN
GTM$DIST: GTM$STOP or invoke @GTM$DIST:GTMSTOP.COM.</p></div><div class="sect3" title="Determining the Number of Affected Jobs"><div class="titlepage"><div><div><h4 class="title"><a name="determining_the_no_of_affected_jobs"></a>Determining the Number of Affected Jobs</h4></div></div></div><p>Use the DCL command</p><pre class="programlisting">SHOW SYSTEM
</pre><p>to observe whether most processes are getting work done.</p><p>If one process is [almost] constantly in the COM state, reduce its
priority with the following DCL command.</p><pre class="programlisting">SET PROC/PRIO=0/ID=pid
</pre><p>If only one user is identified with a problem, and a second process
doing a similar function would not cause damage to the data of the
application, check to see if another user doing a similar task also
hangs.</p><p>If there is only one process affected, issue the following DCL command to
prevent that process from consuming CPU cycles, and indirectly interfering
with other processes:</p><pre class="programlisting">SET PROC/PRIO=0/ID=pid
</pre><p>If only one process is affected, and other important work is at hand, you
may defer the rest of the steps until an appropriate time.</p><p>If more than one application is affected, the problem is unlikely to be
directly caused by GT.M. Test to ensure that the disk drives are not full,
and that they are both read and write accessible. Perform steps recommended
by HP for determining the state of OpenVMS. </p></div></div><div class="sect2" title="H2&#8211;OpenVMS Status"><div class="titlepage"><div><div><h3 class="title"><a name="h2_open_vms_status"></a>H2&#8211;OpenVMS Status</h3></div></div></div><p>An OpenVMS process status ending in the letter "O" indicates the process has
been swapped out by the operating system, but otherwise means the same thing as
its prefix. </p><div class="sect3" title="COM"><div class="titlepage"><div><div><h4 class="title"><a name="com_db_integrate"></a>COM</h4></div></div></div><p>COM (compute state) indicates that the process needs to use CPU cycles to
proceed. A process that continuously exhibits this state is not performing
any I/O. Such a process may have encountered an infinite loop in the
application program. However, it may also have encountered a situation where
it is attempting to manage a database cache, but the cache is damaged and
unresponsive. If you have determined (from section H1) that the problem is
likely a database access problem, refer to section H3. Otherwise, refer to
section H8. </p></div><div class="sect3" title="HIB"><div class="titlepage"><div><div><h4 class="title"><a name="h1b_h2"></a>HIB</h4></div></div></div><p>HIB (Hibernating State) indicates that the process is waiting for time to
pass. GT.M processes in this state may be waiting for completion of M OPEN
or LOCK commands. However, it may also be waiting to access the database. If
you have determined (from section H1) that the problem is likely a database
access problem, refer to section H3. Otherwise, refer to section H8. </p></div><div class="sect3" title="LEF"><div class="titlepage"><div><div><h4 class="title"><a name="lef_ch11"></a>LEF</h4></div></div></div><p>LEF (Local Event Flag wait state) indicates that the process is waiting
for an asynchronous event. GT.M processes in this state may be waiting for
completion of M READ or JOB commands. Such processes are not experiencing
database problems. Refer to section H8. </p></div><div class="sect3" title="RWAST"><div class="titlepage"><div><div><h4 class="title"><a name="rwast"></a>RWAST</h4></div></div></div><p>RWAST (Resource Wait State) indicates that the process lacks some OpenVMS
resource required to continue, and that it has resource waiting enabled. A
process that exhibits this state for a significant period of time generally
can only be recovered by a system reboot. If this problem occurs with any
frequency, review the quotas and limits for users experiencing the problem.
Consider turning off resource wait mode for the susceptible process(es) with
the DCL command SET PROCESS /NORESOURCE_WAIT. Also, consider contacting
FIS  and/or HP to discuss the circumstances under
which this occurs. </p></div></div><div class="sect2" title="H3&#8211;Database Access Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h3_db_access_problems"></a>H3&#8211;Database Access Problems</h3></div></div></div><p>Use the following diagnostic steps and references to determine an appropriate
course of action for database access problems.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Determine if the disk volume is inaccessible.</p><p>Use <span>the DCL DIRECTORY</span>
 to display information retrieved from the
volume. If the volume is not accessible to <span>OpenVMS</span>
, the problem is not
a database problem. Refer to section H7.</p></li><li class="listitem"><p>Determine whether <span>OpenVMS</span>
 can write to the <span>volume</span>
.</p><p>Use a DCL command such as RENAME or COPY. If OpenVMS cannot
write to the volume, the problem is not a database problem. Refer to
section H7.</p></li><li class="listitem"><p>Determine whether any database file used by the application has "Cache
Freeze" set.</p><p>Use DSE FIND <span>/</span>REGION=region and DUMP <span>/</span>FILEHEADER to verify that CACHE FREEZE is zero
(00000000) for any hung region(s).</p><p>If CACHE FREEZE shows a PID, that process used MUPIP or DSE to FREEZE
the database. In this case, investigate whether the process is currently
producing the desired results. If the FREEZE is legitimate, do whatever
is appropriate to speed up the process using FREEZE. For example,
<span>raise its priority (but not higher than
14)</span>
. If the
process still exists, but should not be running at this time, stop it.
If CACHE FREEZE is non-zero but not in use to protect the database, use
DSE FIND <span>/</span>REGION=region and CHANGE <span>/</span>FILEHEAD <span>/</span>FREEZE=FALSE to clear the FREEZE state.</p><p>Use the DSE commands FIND <span>/</span>REGION and DUMP <span>/</span>FILEHEADER. If any region is frozen, determine
who initiated the freeze, and whether the process should be terminated
or allowed to complete. The following actions freeze databases:</p><p>
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>DSE CHANGE <span>/</span>FILEHEADER <span>/</span>FREEZE=TRUE</p></li><li class="listitem"><p>DSE ALL <span>/</span>FREEZE</p></li><li class="listitem"><p>MUPIP BACKUP <span>/</span>NOONLINE</p></li><li class="listitem"><p>MUPIP FREEZE</p></li><li class="listitem"><p>MUPIP INTEG <span>/</span>REGION</p></li><li class="listitem"><p>MUPIP EXTRACT <span>/</span>FREEZE</p></li></ul></div><p>
</p><p>DSE CHANGE <span>/</span>FILEHEADER <span>/</span>FREEZE=FALSE and MUPIP FREEZE <span>/</span>OFF clear a freeze. However,
when used with <span>/</span>OVERRIDE, these commands may cause damage to the results of
the process that initiated the freeze. After the freeze is cleared,
re-examine the entire situation.</p></li><li class="listitem"><p>Determine whether the database files used by the application are
accessible for reading.</p><p>Use an M function such as $DATA() or $ORDER().</p></li><li class="listitem"><p>Determine whether the database files used by the application are
accessible for writing.</p><p>SET a node in each database equal to itself.</p></li></ul></div><p>
<span class="italic">IF THE DATA CAN BE BOTH READ AND WRITTEN,</span>
the problem is not a database problem. Refer to section H8.</p><p>
<span class="italic">IF DATA CANNOT BE READ OR WRITTEN,</span> some
process is unable to release full ownership of the database critical section.
Determine the process identification number (PID) of the process using the DSE
command CRITICAL. If the process exists, refer to section H4. If the process is
non-existent, use DSE CRITICAL <span>/</span>REMOVE to emulate a release and re-examine the entire
situation.</p><p>Example:</p><pre class="programlisting">S reg=$V("GVNEXT",""),com="dbcheck.com" o     m-*  com:newv u com
W "$ DEFINE/USER SYS$OUTPUT dbcheck.lis",!,"$ DSE",!
F  Q:reg=""  D
. W "FIND /REGION=",reg,!,"DUMP /FILEHEADER",! 
. S reg(reg)="",reg=$V("GVNEXT",reg)
W "$ SEARCH dbcheck.lis ""Cache freeze""",!
; CAUTION: in the above line, "Cache freeze" 
; MUST be mixed-case as shown
W "$ DELETE dbcheck.lis.",!,"$ EXIT",!
C com ZSY "@dbcheck" 
O com C com:delete
W !,"Attempting first access"
S g="^%" D:$D(^%)  F  S g=$O(@g) Q:g=""  D
. S reg=$V("REGION",g) Q:$l(reg(reg))
. I $D(@g)'[0 S reg(reg)=g
. E  S reg(reg)=$Q(@g) 
. W !,"Successful Read in region: ",reg," of ",g
S reg="" F  S reg=$O(reg(reg)) Q:reg=""  D
W !,"Write to region: ",reg 
S @(reg(reg)_"="_reg(reg)) W "&#8211;OK"
Q
S reg=$V("GVFIRST"),com="dbcheck" o com:newv u com
W "dse &lt;&lt;yz &gt; dbcheck.lis",!
F  Q:reg=""  D
. W "find -region=",reg,!,"dump -fileheader",! 
. S reg(reg)="",reg=$V("GVNEXT",reg)
W "yz",!,"cat dbcheck.lis | grep 'Cache freeze'"
; CAUTION: in the above line, "Cache freeze" 
; MUST be mixed-case as shown
W "|awk '{print $1, $2, $3}'"
C com ZSY "/bin/csh -c ""source dbcheck""" 
O com,dbcheck.lis C com:delete,dbcheck.lis:delete
W !,"Attempting first access"
S g="^%" D:$D(^%)  F  S g=$O(@g) Q:g=""  D
. S reg=$V("REGION",g) Q:$l(reg(reg))
. I $D(@g)'[0 S reg(reg)=g
. E  S reg(reg)=$Q(@g) 
. W !,"Successful Read in region: ",reg," of ",g
S reg="" F  S reg=$O(reg(reg)) Q:reg=""  D
. W !,"Write to region: ",reg 
. S @(reg(reg)_"="_reg(reg)) W "&#8211;OK"
Q

</pre><p>This routine provides a generalized approach to automating some of the tasks
described in this section. It contains argumentless DO commands primarily for
typesetting reasons. The routine issues a report if any region is frozen, but
does not report which regions are in that state. It may hang reading or writing
a database. However, unless the region(s) holding ^% and the next global after
^% has a problem, it displays the name of the region that it is about to try. If
this routine runs to completion, the databases in the current Global Directory
are completely accessible. The limitations of this routine can be overcome by
writing custom <span>DCL</span>
 and/or M programs that include embedded information about
one or more Global Directories.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>If you have a Global Directory mapping globals to multiple files, you may
create an alternative Global Directory using different mappings to those
same files. Such mapping prevents the test program(s) from touching the
"real" data.</p></td></tr></table></div><p>Example:</p><pre class="programlisting">Mapping      Production region   Test region
-----------------------------------------------
A   to   M   
$DEFAULT            SCRATCH
N   to   Z   SCRATCH            
$DEFAULT
</pre><div class="sect3" title="Determining Which Process is Central to the Problem"><div class="titlepage"><div><div><h4 class="title"><a name="determining_the_central_process"></a>Determining Which Process is Central to the Problem</h4></div></div></div><p>If more than one process is affected, try to determine which process is
causing the bottleneck.</p><p>If you have already determined which process is at the center of the
problem, go to the section on "Capturing Diagnostic Information."</p><p>If one process was spending most of its time in the COM state, that is the
process to analyze; reduce its priority to zero (0) and go to the section on
"Capturing Diagnostic Information."</p><p>For each process that is in RWAST, issue a <span class="emphasis"><em>SHOW
PROC/QUOTA/OUT=file-spec/ID=pid </em></span> to an appropriate
file.</p><p>Perform a CCE DUMP/DB and try to stop these processes. For information on
stopping processes, refer to the section of that name in this chapter. If
the RWAST process(es) do not respond to all stopping procedures, perform a
normal system shutdown and restart the system.</p><p>If many processes running the same application are unresponsive and in the
HIB state, determine which database has the problem by running LKE SHOW
/ALL. LKE SHOW /ALL reports on the regions that it has processed. </p><p>If LKE SHOW /ALL reports on all regions, then repeat the command and
analyze the reports for evidence of a deadlock or a LOCK that is "stuck."
Stop the problem process(es), and correct the application.</p><p>If LKE hangs, run GDE SHOW /REGION to determine the next region after the
last region reported; this is the region with the problem.</p><p>Run DSE to determine what process has the critical section of the hung
region. In DSE enter the following commands.</p><pre class="programlisting">DSE&gt;FIND/REGION=region-name
</pre><p>then</p><pre class="programlisting">DSE&gt;CRIT
</pre><p>If CRIT reports that no process owns the critical section, issue a</p><pre class="programlisting">DSE&gt;BUFFER
</pre><p>command to test whether the region is OK. If BUFFER works, the database is
not the problem. Restart the analysis process with the section "How many
jobs are affected?" If it hangs for one minute and reports that it cannot
flush, issue a</p><pre class="programlisting">DSE&gt;CRIT/SEIZE
</pre><p>followed by</p><pre class="programlisting">DSE&gt;CRIT/RELEASE
</pre><p>If CRIT /RELEASE hangs, go to the section on "Capturing Diagnostic
Information," and use another process to analyze the process that is running
DSE. If CRIT /RELEASE works, then try to </p><pre class="programlisting">DSE&gt;EXIT
</pre><p>If EXIT hangs, go to the section on "Capturing Diagnostic Information,"
and use another process to analyze the process that is running DSE. If EXIT
works, then reinvoke DSE, issue a</p><pre class="programlisting">DSE&gt;CRIT/SEIZE
</pre><p>then use another process to stop the process running DSE. If this clears
the problem, report the problem and return to normal operation.</p><p>If the CRIT command displays the PID of a process that has write
ownership, that is the process to analyze; go to the "Capturing Diagnostic
Information" section.</p><p>If the CRIT command displays a count of READ owners, run CCE DUMP /DB and
go to section H5.</p></div></div><div class="sect2" title="H4&#8211;Database Cache Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h4_database_cache_problms"></a>H4&#8211;Database Cache Problems</h3></div></div></div><p>To increase the access speed, GT.M buffers data exchanged between processes
and database files in the shared memory cache. If information in the memory
cache is damaged, it can block the transfer of data to the disk.</p><p>
<span class="italic">IF A PROCESS HAS BEEN DETERMINED (FROM SECTION H3) TO
NEVER RELEASE FULL OWNERSHIP OF THE DATABASE CRITICAL SECTION,</span>
there may be a problem with the database cache. To determine where the problem
is occurring terminate the process. If this clears the hang, the problem was not
in the database but in the process, which was somehow damaged. Refer to section
P1. Otherwise, another process showing the same symptoms takes the place of the
terminated process. In this case, the cache is damaged.</p><p>
<span class="italic">IF THE CACHE IS DAMAGED,</span> it must be
reinitialized. It is crucial to stop all other database activity during cache
initialization. Refer to section Q1 before continuing with this section.</p><p>To minimize database damage due to cache reinitialization, and to confirm that
the problem is due to a damaged cache, use the DSE command CRITICAL SEIZE
followed by BUFFER_FLUSH. The DSE command BUFFER_FLUSH attempts to flush the
database cache which is a benign operation. Wait at least one minute for this
operation to complete.</p><p>
<span class="italic">IF THE BUFFER_FLUSH DOES NOT HANG,</span> the
cache is not damaged, and you should review all previous steps starting with
section H1. </p><p>
<span class="italic">IF THE BUFFER_FLUSH DOES HANG,</span> use the DSE
command WCINIT to reinitialize the cache. This command requires confirmation.
Never use WCINIT on a properly operating database. After a WCINIT always perform
at least a MUPIP INTEG FAST to detect any induced damage that has a danger of
spreading. If the WCINIT command hangs, clear the critical section as described
in section H5 and reissue the WCINIT.</p></div><div class="sect2" title="H5&#8211;Critical Section Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h5_critical_section_problems"></a>H5&#8211;Critical Section Problems</h3></div></div></div><p>The concurrency control mechanism allows only one process at a time to execute
code within a "critical section." To gain access to the database requires a
process to first gain ownership of the critical section. The errors described in
this section occur when a problem occurs in ownership control of the critical
section.</p><p>
<span class="italic">IF YOU HAVE DETERMINED WHICH PROCESS IS HOLDING THE
CRITICAL SECTION</span> (from section H2 using system utilities), try
terminating that process. If this corrects the problem, the damage was to the
process, rather than the critical section. Refer to section P1. </p><p>
<span class="italic">IF YOU CANNOT IDENTIFY THE PROCESS</span>, or if
terminating such a process causes other processes to exhibit the same
problem(s), the critical section is damaged and must be reinitialized. Restrict
database activity during the reinitialization. Refer to section Q1 before
continuing with this section.</p><p>
<span class="italic">TO REINITIALIZE THE DATABASE CRITICAL SECTION:
</span> Reinitializing a critical section on an active database file carries
some risk of causing database damage. You can minimize this risk by restricting
database activity during the reinitialization. Refer to section Q1 before
continuing with this section.</p><p>The DSE command CRITICAL INITIALIZE RESET re-establishes the database-critical
section and induces errors for all processes currently accessing the database in
question. You can avoid the induced errors in other processes by dropping the
RESET qualifier. However, this technique may result in other processes
attempting to use partially created critical section structures, possibly
corrupting them or the database contents.</p><p>After the CRITICAL INITIALIZE, use the DSE commands CRITICAL SEIZE and
CRITICAL RELEASE to verify operation of the critical section. Actions such as
those described in section H3 test more thoroughly for proper operation. </p></div><div class="sect2" title="H6&#8211;OpenVMS Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h6_OpenVMS_problems"></a>H6&#8211;OpenVMS Problems</h3></div></div></div><p>
<span class="italic">IF YOU HAVE DETERMINED THAT MANY PROCESSES IN THE
OPENVMS ENVIRONMENT ARE PERFORMING BADLY,</span> use the tools described
in section H2 to determine whether some processes are using OpenVMS priorities
to take over the system. If this is the case, review why priorities are being
adjusted and take appropriate action. Otherwise, you should assume you have an
OpenVMS tuning problem. For information on tuning OpenVMS, refer to the OpenVMS
Performance Management. If the problem is really severe, examine recent changes
to SYSGEN parameters. When changing SYSGEN parameters, the use of AUTOGEN helps
to avoid extreme performance problems. </p></div><div class="sect2" title="H7&#8211;Disk Hardware Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h7_disk_hardware_problems"></a>H7&#8211;Disk Hardware Problems</h3></div></div></div><p>
<span class="italic">IF YOU HAVE DETERMINED THAT A DISK VOLUME IS
INACCESSIBLE TO OPENVMS FOR READ AND/OR WRITE,</span>use the DCL command
SHOW DEVICE /FULL to check that the correct volume is properly mounted. If the
volume cannot be written, examine the physical device to see whether write lock
switches or plugs have been disturbed.</p><p>
<span class="italic">IF YOU HAVE DETERMINED THAT A DISK VOLUME IS
INACCESSIBLE TO UNIX FOR READ AND/OR WRITE,</span> use the df command to
check that the correct volume is properly mounted. If the volume cannot be
written, examine the physical device to see whether write lock switches or plugs
have been disturbed.</p><p>
<span class="italic">IF YOU CANNOT LOCATE THE PROBLEM,</span> run disk
diagnostics. Be aware that many disk diagnostics are destructive (i.e., destroy
your files). Avoid these diagnostics until you have exhausted all other avenues.
If you have to run destructive disk diagnostics, or you determine that a disk
spindle must be replaced, start planning for the recovery immediately.</p></div><div class="sect2" title="H8&#8211;Application Problems"><div class="titlepage"><div><div><h3 class="title"><a name="h8_application_problems"></a>H8&#8211;Application Problems</h3></div></div></div><p>Application problems may be caused by conflicting M LOCKs or OPEN commands in
more than one process, or by a process waiting for completion of M READ or JOB
command, which is dependent on an asynchronous event.</p><p>
<span class="italic">IF THE PROCESS STATUS (FROM SECTION H2) IS
HIB,</span> the problem may involve M LOCKs or OPEN commands.</p><p>
<span class="italic">IF THE PROCESS STATUS (FROM SECTION H2) IS
LEF,</span> the problem may involve M READ or JOB commands.</p><p>First, determine if processes are waiting, without relief, for M LOCKs using
the LKE command SHOW ALL WAITING. M routines use LOCK commands to create mutual
exclusion semaphores. </p><p>
<span class="italic">IF THE SHOW COMMAND HANGS,</span> you have a cache
or critical section problem. Restart your evaluation in section H5.</p><p>
<span class="italic">IF THE SHOW COMMAND DISPLAYS NO LOCKS
WAITING,</span> the problem is not a LOCK problem. If repeated use of
SHOW does not display the one or more LOCKs that persist every time, the problem
is not a LOCK problem. However, even if the problem is not a lock problem,
continue with this section because it discusses the M commands JOB, OPEN, and
READ, which may also produce hangs.</p><p>A LOCK identified as belonging to a non-existent process results from an
abnormal process termination. GT.M automatically clears such LOCKs when some
other process requests a conflicting LOCK. </p><div class="sect3" title="Persistent LOCKs"><div class="titlepage"><div><div><h4 class="title"><a name="persistent_locks"></a>Persistent LOCKs</h4></div></div></div><p>Persistent LOCKs belonging to currently existing processes are best
released by terminating those processes. Using the LKE command CLEAR with
various qualifiers can clear LOCKs, but may cause the routines using the
LOCKs to produce inappropriate results. For more information on LKE, refer
to the "M LOCK Utility" chapter.</p><p>The two most common reasons for persistent LOCKs are deadlocks and LOCKS
held during operations that take indeterminate amounts of time.</p></div><div class="sect3" title="Deadlocks"><div class="titlepage"><div><div><h4 class="title"><a name="deadlocks"></a>Deadlocks</h4></div></div></div><p>Deadlocks occur when two or more processes own resources and are trying to
add ownership of an additional resource already owned by another of the
deadlocked processes.</p><p>Example:</p><pre class="programlisting">Process 1       Process 2
---------       --------- 
LOCK ^A         LOCK ^B
LOCK +^B        LOCK +^A</pre><p>This shows a sequence in which Process 1 owns ^A and Process 2 owns ^B.
Each process is trying to get the resource owned by the other, while
"refusing" to release the resource it owns.</p><p>Example:</p><pre class="programlisting">Process 1       Process 2        Process 3
---------       ---------        --------- 
LOCK ^A         LOCK ^B          LOCK ^C
LOCK +^B        LOCK +^C         LOCK +^A</pre><p>This is similar to the previous example, except that it involves three
processes. When an application uses LOCKs in a complex fashion, deadlocks
may involve many processes.</p></div><div class="sect3" title="Preventing Deadlocks"><div class="titlepage"><div><div><h4 class="title"><a name="prevention_of_a_deadlock"></a>Preventing Deadlocks</h4></div></div></div><p>You can prevent deadlocks by using timeouts on the LOCK commands. Timeouts
allow the program to recognize a deadlock. Once a routine detects a
deadlock, it should release its LOCKs and restart execution from the
beginning of the code that accumulates LOCKs. Without timeouts, there is no
way in M to break a deadlock. You must use outside intervention to terminate
at least one deadlocked process, or use LKE to strip a LOCK from such a
process.</p><p>Example:</p><pre class="programlisting">FOR  QUIT:$$NEW
QUIT
NEW()  LOCK ^X(0)
SET ^X(0)=^X(0)+1
QUIT $$STORE(^X(0))
STORE(x)
LOCK +^X(x):10 IF  SET ^X(x)=name_"^"_bal
LOCK
QUIT $TEST
</pre><p>This uses a timeout on the LOCK of ^X(x) to cause a retry of NEW.</p><p>In addition to the LOCK command, the M JOB, OPEN, and READ commands can
contribute to deadlocks.</p><p>Example:</p><pre class="programlisting">Process 1         Process 2
---------         --------- 
LOCK ^A
           OPEN "MSA0:"
        OPEN "/dev/nrst0"
OPEN "MSA0:"
OPEN "/dev/nrst0"
        LOCK +^A

</pre><p>This example shows a sequence in which Process 1 owns ^A and
Process 2 owns device MSA0:. Again, each is trying to get the resource held
by the other. Notice that the LOCK commands could be replaced by OPEN
commands specifying some non-shared device other than MSA0:.</p><p>An application may combine the technique of timeouts on "long" commands to
protect the current process, with the technique of minimizing LOCK and OPEN
durations, to minimize conflicts with other processes.</p><p>Another type of application hanging occurs when a process acquires
ownership of a resource and then starts an operation that does not complete
for a long period of time. Other processes that need the unavailable
resource(s) then hang.</p><p>Example:</p><pre class="programlisting">Process 1         Process 2
---------         --------- 
LOCK ^A
READ x
LOCK ^A

</pre><p>If the READ by Process 1 is to an interactive terminal, and the operator
has abandoned that device, the READ may take what seems, at least to Process
2, forever. The M commands OPEN and JOB, as well as READ, can produce this
problem. When this situation arises, take action to get long-running
commands completed or to terminate the process performing those
commands.</p><p>There are two programming solutions that help avoid these situations. You
can either limit the duration of those commands with timeouts, or defer
resource ownership until any long operations are complete.</p><p>Example:</p><pre class="programlisting">FOR  Q:$$UPD
QUIT
UPD()  SET x=^ACCT(acct)
DO EDITACCT
LOCK ^ACCT(acct) 
IF x=^ACCT(acct) SET ^ACCT(acct)=y
ELSE  WRITE !,"Update conflict&#8211;Please Reenter"
LOCK
QUIT $TEST
</pre><p>This stores the contents of ^ACCT(acct) in local variable x, before the
interactive editing performed by sub-routine EDITACCT (not shown). When the
interaction is complete, it LOCKs the resource name and tests whether
^ACCT(acct) has been changed by some other process. If not, it updates the
global variable. Otherwise, it informs the user and restarts UPD. This
technique eliminates the "open update" problem, but it introduces the
possibility the user may have to re-enter work. An application that needs to
minimize the possibility of re-entry may extend this technique by testing
individual fields (pieces) for conflicting changes.</p></div></div><div class="sect2" title="I1&#8211;MUPIP INTEG Errors"><div class="titlepage"><div><div><h3 class="title"><a name="i1_mupip_integ_errors"></a>I1&#8211;MUPIP INTEG Errors</h3></div></div></div><p>Database errors reported by MUPIP INTEG differ in impact and severity. Some
require an immediate action to prevent extending the damage. Action on other
less severe errors may be delayed.</p><p>The next section provides general guidelines for determining your next course
of action and a table with information related to the error messages you may
encounter.</p><div class="sect3" title="Evaluating the Danger Level of a Database Problem"><div class="titlepage"><div><div><h4 class="title"><a name="evaluate_danger_level"></a>Evaluating the Danger Level of a Database Problem</h4></div></div></div><p>If you encounter an anomaly in your database or its operations, the
following list may offer some help in determining your next course of
action. The heading of each section indicates the level of urgency FIS attributes to those items listed below it.</p><div class="sect4" title="Requires Immediate Attention"><div class="titlepage"><div><div><h5 class="title"><a name="requires_immed_attention"></a>Requires Immediate Attention</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Block incorrectly marked free errors are very serious and lead
to accelerating damage. They degenerate into block
doubly-allocated errors, which are also very dangerous. A
database with these errors should be closed immediately for
repairs.</p></li><li class="listitem"><p>Any (structural) error in an index block is dangerous and
should be repaired as soon as possible. </p></li></ul></div><p>Repairs for such errors should also be performed on a database that
has been closed to normal activity. The need for both of these actions
occurring quickly arises from the likelihood of the bad index being
used. Only if your knowledge of the application allows you to predict
that a damaged area is used exclusively by restricted functions which
are not active (e.g., monthly processing or purges) should you defer
repairs.</p></div><div class="sect4" title="Can Be Deferred"><div class="titlepage"><div><div><h5 class="title"><a name="can_be_deferred"></a>Can Be Deferred</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Any (structural) error in a data block (level 0) does not pose
a threat of accelerating damage. However, level 0 errors may
cause errors or unreliable behavior in the application.</p></li><li class="listitem"><p>Block "incorrectly marked busy" errors only result in database
space becoming unavailable until the errors are corrected. An
index block error generates incorrectly marked busy errors,
because INTEG cannot process the descendants of the damaged
index. Therefore, incorrectly marked busy errors should be
corrected only after all other errors, except for bitmap errors,
are corrected.</p></li><li class="listitem"><p>Any bitmap errors flag not only the incorrectly marked block,
but also the associated bitmap, and sometimes the master map.
Therefore, local and master map errors should be corrected only
after all bitmap marked busy or free errors are
corrected.</p></li><li class="listitem"><p>Transaction number errors usually impact only incremental and
online backups.</p></li><li class="listitem"><p>File size errors can misdirect MUPIP but do not cause the GT.M
run-time system to generate further errors. An exception is
auto-extend, which may not work properly if there are file size
errors.</p></li><li class="listitem"><p>Reference count errors and free block errors are informational
only.</p></li></ul></div><p>The following list of INTEG messages classifies error severity using
the following codes, and refers you to a section identifying appropriate
follow-up action.</p><table border="0" summary="Simple list" class="simplelist"><tr><td>A Access: prevents database access</td></tr><tr><td>B Benign: presents no risk of additional damage and has little
or no effect on database performance</td></tr><tr><td>D Dangerous: presents a high risk that continuing updates may
cause significant additional damage</td></tr><tr><td>I Index: if the block is an index block, continuing updates will
be quite dangerous: treat as a D; if the block is a data block,
continuing updates can only cause limited additional damage </td></tr><tr><td>T Transient: usually cleared by an update to the
database</td></tr></table><p>Repair Dangerous and Access errors immediately. You may assess the
benefits of deferring correction of less severe errors until normally
scheduled down-time.</p><div class="informaltable"><table width="100%" border="1"><colgroup><col><col><col></colgroup><thead><tr><th colspan="3">
<p>MUPIP INTEG Error Messages</p>

</th></tr><tr><th>
<p>SEVERITY</p>
</th><th>
<p>ERROR MESSAGE</p>
</th><th>
<p>SECTION </p>
</th></tr></thead><tbody><tr><td>
<p>I</p>
<p>I</p>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
</td><td>
<p>Bad key name.</p>
<p>Bad numeric subscript.</p>
<p>Bad pointer value in directory.</p>
<p>Bitmap block number as pointer.</p>
<p>Block at incorrect level.</p>
<p>Block busy/free status unknown (local bitmap
corrupted).</p>
<p>Block doubly allocated.</p>
</td><td>
<p>K1</p>
<p>K1</p>
<p>K4</p>
<p>K4</p>
<p>01</p>
<p>M1</p>
<p>K3</p>
</td></tr><tr><td>
<p>B</p>
<p>D</p>
<p>I</p>
<p>D</p>
<p>D</p>
</td><td>
<p>Block incorrectly marked busy.</p>
<p>Block incorrectly marked free.</p>
<p>Block larger than file block size.</p>
<p>Block pointer larger than file maximum.</p>
<p>Block pointer negative.</p>
</td><td>
<p>M1</p>
<p>M1</p>
<p>O1</p>
<p>K4</p>
<p>K4</p>
</td></tr><tr><td>
<p>A</p>
<p>A</p>
<p>A</p>
<p>I</p>
<p>T</p>
</td><td>
<p>Block size equals zero.</p>
<p>Block size is greater than 64K.</p>
<p>Block size not a multiple of 512 bytes.</p>
<p>Block too small.</p>
<p>Block transaction number too large.</p>
</td><td>
<p>I3</p>
<p>I3</p>
<p>I3</p>
<p>01</p>
<p>I6</p>
</td></tr><tr><td>
<p>D</p>
<p>D</p>
<p>D</p>
<p>B</p>
<p>T</p>
</td><td>
<p>Blocks per local map is less than 512.</p>
<p>Blocks per local map is greater than 2K.</p>
<p>Blocks per local map is not a multiple of
512.</p>
<p>Cannot INTEG region across network.</p>
<p>Cannot determine access method;trying with
BG.</p>
</td><td>
<p>I3</p>
<p>I3</p>
<p>I3</p>
<p>I5</p>
<p>I6</p>
</td></tr><tr><td>
<p>I</p>
<p>T</p>
<p>A</p>
<p>T</p>
<p>B</p>
</td><td>
<p>Compression count not maximal.</p>
<p>Current tn and early tn are not equal.</p>
<p>Database for region rrr is already frozen, not
INTEGing</p>
<p>Database requires flushing.</p>
<p>File size larger than block count would
indicate.</p>
</td><td>
<p>K6</p>
<p>I6</p>
<p>I6</p>
<p>I7</p>
<p>I4</p>
</td></tr><tr><td>
<p>D</p>
<p>A</p>
<p>I</p>
<p>B</p>
<p>A</p>
</td><td>
<p>File size smaller than block count would
indicate.</p>
<p>File smaller than database header.</p>
<p>First record of block has nonzero compression
count.</p>
<p>Free blocks counter in file header: nnn is
incorrect, should be mmm.</p>
<p>Header indicates file creation did not
complete.</p>
</td><td>
<p>I4</p>
<p>I3</p>
<p>O1</p>
<p>I3</p>
<p>I3</p>
</td></tr><tr><td>
<p>A</p>
<p>A</p>
<p>D</p>
<p>A</p>
<p>D</p>
</td><td>
<p>Header indicates file is corrupt.</p>
<p>Header size not valid for database.</p>
<p>Block xxxx doubly allocated in index block.</p>
<p>Incorrect version of GT.M database.</p>
<p>Invalid mixing of global names.</p>
</td><td>
<p>I8</p>
<p>I3</p>
<p>K3</p>
<p>I2</p>
<p>K3</p>
</td></tr><tr><td>
<p>I</p>
<p>I</p>
<p>I</p>
<p>I</p>
<p>I</p>
</td><td>
<p>Key greater than index key.</p>
<p>Key larger than database maximum.</p>
<p>Key larger than maximum allowed length.</p>
<p>Key too long.</p>
<p>Key too short.</p>
</td><td>
<p>K2</p>
<p>K7</p>
<p>K1</p>
<p>K1</p>
<p>K1</p>
</td></tr><tr><td>
<p>I</p>
<p>I</p>
<p>I</p>
<p>D</p>
<p>B</p>
</td><td>
<p>Keys less than sibling's index key.</p>
<p>Keys out of order.</p>
<p>Last record of block has invalid size.</p>
<p>Last record of block has nonzero compression
count.</p>
<p>Local bitmap incorrect.</p>
</td><td>
<p>K2</p>
<p>K2</p>
<p>K5</p>
<p>K5</p>
<p>M1</p>
</td></tr><tr><td>
<p>B</p>
<p>B</p>
<p>B</p>
<p>T</p>
<p>B</p>
</td><td>
<p>Local map block level incorrect.</p>
<p>Map block too large.</p>
<p>Map block too small.</p>
<p>Map block transaction number too large.</p>
<p>Master bitmap incorrectly asserts this local map
has free space.</p>
</td><td>
<p>M2</p>
<p>M2</p>
<p>M2</p>
<p>I6</p>
<p>M1</p>
</td></tr><tr><td>
<p>B</p>
<p>B</p>
<p>B</p>
<p>B</p>
<p>B</p>
</td><td>
<p>Master bitmap incorrectly marks this local map
full.</p>
<p>Master bitmap shows this map full, agreeing with
disk local map.</p>
<p>Master bitmap shows this map full, agreeing with
MUPIP INTEG.</p>
<p>Master bitmap shows this map full, in disagreement
with both disk and mu_int result.</p>
<p>Master bitmap shows this map has space, agreeing
with disk local map.</p>
</td><td>
<p>M1</p>
<p>M1</p>
<p>M1</p>
<p>M1</p>
<p>M1</p>
</td></tr><tr><td>
<p>B</p>
<p>D</p>
<p>I</p>
<p>..</p>
<p>I</p>
</td><td>
<p>Master bitmap shows this map has space, agreeing
with MUPIP INTEG.</p>
<p>Read error on bitmap.</p>
<p>Record has too large compression count.</p>
<p>Record too large.</p>
<p>Record too small.</p>
</td><td>
<p>M1</p>
<p>H7</p>
<p>O2</p>
<p>O2</p>
<p>O2</p>
</td></tr><tr><td>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
</td><td>
<p>Reference count should be zero, is nnn.</p>
<p>Root block number greater than last block number
in file.</p>
<p>Root block number is a local bitmap number.</p>
<p>Root block number negative.</p>
<p>Root level higher than maximum.</p>
</td><td>
<p>I6</p>
<p>K4</p>
<p>K4</p>
<p>K4</p>
<p>O1</p>
</td></tr><tr><td>
<p>D</p>
<p>A</p>
<p>A</p>
<p>A</p>
</td><td>
<p>Root level less than one.</p>
<p>Start VBN smaller than possible.</p>
<p>Total blocks equals zero.</p>
<p>Unable to verify that this is a database
file.</p>
</td><td>
<p>O1</p>
<p>I3</p>
<p>I4</p>
<p>I3</p>
</td></tr></tbody></table></div></div></div></div><div class="sect2" title="I2&#8211;GT.M Version Mismatch"><div class="titlepage"><div><div><h3 class="title"><a name="gtm_version_mismatch_chi2"></a>I2&#8211;GT.M Version Mismatch</h3></div></div></div><p>GT.M databases and Global Directories may change with new releases of the
product.</p><p>
<span class="italic">IF YOU GET AN ERROR INDICATING A VERSION
MISMATCH,</span> first identify the GT.M version using the M command
WRITE $ZVERSION from Direct Mode.</p><p>Then refer to the installation procedures for your new release. If you are
running more than one release of GT.M <span>or GT.CX,</span>
investigate the <span>logical names</span>
 that define the environments, and take
appropriate action. </p></div><div class="sect2" title="I3&#8211;File Header Errors"><div class="titlepage"><div><div><h3 class="title"><a name="i3_file_header_errors"></a>I3&#8211;File Header Errors</h3></div></div></div><p>These errors indicate damage to the control or reference information in the
file header.</p><p>"Start VBN smaller than possible" indicates that INTEG cannot locate the
database structure. "Header indicates that file creation did not complete"
indicates a MUPIP CREATE problem. In these cases, the database has effectively
been lost. DSE cannot correct these problems. If you determine that the costs of
recovering from a backup, hopefully with journal files, are prohibitive,
consider consulting with FIS.</p><p>To correct the other errors of this type use the DSE CHANGE FILEHEADER command
with the BLK_SIZE=, BLOCKS_FREE=, and TOTAL_BLKS qualifiers.</p><p>"Free blocks counter ..." indicates that the count of free blocks in the file
header is not correct. This error only affects $VIEW("FREECNT",region) and DUMP
FILEHEADER which return the information.</p></div><div class="sect2" title="I4&#8211;File Size Errors"><div class="titlepage"><div><div><h3 class="title"><a name="i4_file_size_errors"></a>I4&#8211;File Size Errors</h3></div></div></div><p>File size errors can misdirect MUPIP, but do not cause the GT.M run-time
system to generate further errors. Auto-extend is the exception and may not
function properly if there are file size errors. One possible symptom of an
auto-extend problem would be incorrectly marked busy errors from a partial
bitmap at the "old" end of the database which had previously been incorrectly
initialized.</p><p>These errors indicate that the total blocks count does not agree with the file
size. Get the starting VBN and the block size for the file by using DSE DUMP
FILEHEADER. Then calculate the correct total blocks value with the following
formula:</p><pre class="programlisting">((file size - starting VBN + 1) / (block size / 512))
</pre><p>A decimal number results from this formula. Convert this decimal to a
hexadecimal number, then change the total block count to this hexadecimal value
using DSE CHANGE FILEHEADER TOTAL_BLKS= . You may also need to adjust the free
blocks count with BLOCKS_FREE=. MUPIP INTEG informs you if this is necessary and
gives the correct values. </p></div><div class="sect2" title="I5&#8211;More Database Access Problems"><div class="titlepage"><div><div><h3 class="title"><a name="i5_more_db_access_problems"></a>I5&#8211;More Database Access Problems</h3></div></div></div><p>These error messages reflect failures to find, open, or access a database
file. Examine any secondary error messages to obtain additional information
about the problem.</p><p>
<span>Use the DCL command SHOW LOG GTM$GBLDIR</span>
 or use the M command
WRITE $ZGBLDIR to verify that the "pointer" identifies the proper Global
Directory. If the pointer is not appropriate, <span>correct it with
the DCL command DEFINE GTM$GBLDIR </span>
 or use the M command SET $ZGBLDIR= to name the proper
file.</p><p>Examine the Global Directory using GDE. If the Global Directory is not
appropriate, correct or recreate it with GDE. For more information on the use of
GDE, refer to the "Global Directory Editor" chapter.</p><p>IF THE GLOBAL DIRECTORY IS DAMAGED BUT ACCESSIBLE WITH GDE, investigate who
may have used GDE to perform the modifications. If the Global Directory is
damaged and not accessible with GDE, investigate what program, other than GT.M
and its utilities, might have written to the file. Except for GDE, all GT.M
components treat the Global Directory as static and read-only.</p><p>IF THE GLOBAL DIRECTORY APPEARS CORRECT, use the DCL command SHOW LOGICAL to
verify that any logical names it uses are properly defined for the process
experiencing the problem. If the process has an environment to which you do not
have access, you may have to carefully read the command procedures used to
establish that environment.</p><p>IF THE GLOBAL DIRECTORY APPEARS CORRECT, use printenv to verify that any
environment variables that it uses are properly defined for the process
experiencing the problem. If the process has an environment to which you do not
have access, you may have to carefully read the shell scripts used to establish
that environment.</p><p>IF THE ENVIRONMENT VARIABLES APPEAR CORRECT, use the <span>DCL
command DIRECTORY /SECURITY</span>
 to
examine the file protection. Remember to examine not only the file, but also all
directories accessed in locating the file.</p><p>IF THE FILES APPEAR TO BE PROPERLY MAPPED by the Global Directory, correctly
placed given all logical names, and correctly protected to permit appropriate
access, use one of the DCL commands TYPE or DUMP to verify access to the files,
independent of GT.M.</p><p>IF THE FILES APPEAR TO BE PROPERLY MAPPED by the Global Directory, properly
placed given all environment variables, and properly protected to permit
appropriate access, use the od or cat utility to verify access to the files,
independent of GT.M.</p><p>IF YOU SUSPECT A VERSION MISMATCH PROBLEM, refer to section I2. </p><p>IF YOU SUSPECT A DISK HARDWARE PROBLEM, refer to section H7.</p></div><div class="sect2" title="I6&#8211;Transient Errors"><div class="titlepage"><div><div><h3 class="title"><a name="i6_transient_errors"></a>I6&#8211;Transient Errors</h3></div></div></div><p>GT.M corrects certain errors automatically. If you find that any of these
errors persist, contact your GT.M support channel.</p><p>"Block transaction number too large" indicates that the file header has a smaller transaction number than the database block. </p><p>If you are not running TP or incremental backup this is a benign error (from the database's point of view; application data consistency should be verified). GT.M automatically self-corrects these errors as soon as it performs sufficient updates to get the current transaction number of the database higher than any block's transaction number. If this error persists, perform the following steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Run the MUPIP INTEG command on your database and look for the following output: </p><p><code class="code">"Largest transaction number found in database was HHHHHHH"</code></p></li><li class="listitem"><p>Run the following command:</p><p><code class="code">dse change -fileheader -current_tn=&lt;HHHHHHH+1&gt;</code></p><p>Where &lt;HHHHHHH+1&gt; is the largest transaction number + 1. This command sets the current transaction number to one more than the largest transaction number found in the database. Note that HHHHHHH is in hexadecimal form. </p></li></ul></div><p>"Current tn and early tn are not equal" indicates that the critical section has been damaged. "Reference
count is not zero" indicates an improper file close. The first access that
references a questionable database should correct these errors. Generally, these
errors indicate that the file was not closed normally. This problem is typically
caused by an unscheduled shutdown of the system. Review your institution's
shutdown procedures to ensure a controlled shutdown.</p><p>"Cannot determine access method..." indicates that the fileheader has been
damaged. When INTEG detects this error, it forces the access method to BG and
continues. If there is no other damage to the file header, no other action may
be required. </p><p>However, if the access method should be MM, use MUPIP SET ACCESS_METHOD= to
correct the database.</p></div><div class="sect2" title="I7&#8211;Database Rundown Problem"><div class="titlepage"><div><div><h3 class="title"><a name="i7_db_rundown_prblm"></a>I7&#8211;Database Rundown Problem</h3></div></div></div><p>A MUPIP INTEG may be performed without write access to the file. However, in
the case where the file was improperly closed, it must be RUNDOWN prior to being
INTEGed. To do this, MUPIP requires write access to the file, so either increase
the privileges for the process, change the protection on the file, or use a more
privileged process and repeat the MUPIP INTEG. </p></div><div class="sect2" title="I8&#8211;Repair-Induced Problems"><div class="titlepage"><div><div><h3 class="title"><a name="i8_repair_induced_prblm"></a>I8&#8211;Repair-Induced Problems</h3></div></div></div><p>These error messages are created by operator actions performed with
DSE.</p><p>The DSE commands CRITICAL INITIALIZE RESET, ALL RESET, and ALL RENEW induce
CRITRESET errors in all processes attempting to access the target
database(s).</p><p>Any process attempting to access a database that has its "corrupt" flag set to
TRUE receives a DBCRPT error.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Warning]" src="images/warning.jpg"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Using the DSE command CHANGE FILEHEADER CORRUPT=TRUE is very dangerous. If
the DSE session EXITs before issuing a CHANGE FILEHEADER CORRUPT=FALSE, the
database becomes entirely useless.</p></td></tr></table></div></div><div class="sect2" title="K1&#8211;Bad Key"><div class="titlepage"><div><div><h3 class="title"><a name="k1_bad_key"></a>K1&#8211;Bad Key</h3></div></div></div><p>This section describes appropriate actions when the error message indicates a
damaged key. GDS transforms subscripted or unsubscripted global variable names
into keys, which are part of the database record used to index the corresponding
global variable data values. The keys are stored in a compressed form which
omits that part of the prefix held in common with the previous key in the block.
The compression count is the number of common characters. Except in the
Directory Tree, all records after the first one have a non-zero count. The first
record in a block always has a compression count of zero (0).</p><p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), refer to section
O3.</p><p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), examine the record with the
DSE command DUMP BLOCK= OFFSET where the block and offset values are provided by
the INTEG error report. If the record appears to have a valid block pointer,
note the pointer. Otherwise, refer to section O2.</p><p>After noting the pointer, SPAWN and use MUPIP INTEG BLOCK=pointer (if you have
time constraints, you may use the FAST qualifier) to check the structure.</p><p>IF THE SUB-TREE IS INVALID, according to the MUPIP INTEG, DSE REMOVE the
record containing the reported bad key, INTEG, and refer to section O4.</p><p>Otherwise use the DSE command DUMP BLOCK= RECORD=9999 to find the last record
in the block and examine it using the DUMP RECORD= command. Continue using DSE
to follow the pointer(s) down to level 0, always choosing the right-hand branch.
Note the largest key at the data level. REMOVE the record containing the
reported bad key. Determine the proper placement for the noted key using FIND
KEY= and ADD KEY= POINTER where the key and the pointer are those noted in the
preceding actions. </p></div><div class="sect2" title="K2&#8211;Keys Misplaced"><div class="titlepage"><div><div><h3 class="title"><a name="k2_keys_misplaced"></a>K2&#8211;Keys Misplaced</h3></div></div></div><p>When the error is a misplaced key, the keys are not in proper collating
sequence.</p><p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p><p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), you may choose to reposition
the record in its proper place or use the salvage strategy discussed in section
O4. In general, the salvage strategy is less demanding and less dangerous.
However, it may be time consuming if the index block holding the record has a
level much greater than one (1). If you decide against the salvage strategy,
note the contents of the damaged record. In either case, REMOVE the record. If
using salvage, refer to section O4. If not, determine the proper location for
the record using FIND KEY= to display the closest existing path, then follow the
procedure outlined in the last paragraph of K1.</p></div><div class="sect2" title="K3&#8211;Block Doubly Allocated"><div class="titlepage"><div><div><h3 class="title"><a name="k3_block_doubly_allocated"></a>K3&#8211;Block Doubly Allocated</h3></div></div></div><p>A doubly allocated block is dangerous because it causes data to be
inappropriately mingled. As long as no KILLs occur, double allocation does not
cause permanent loss of additional data. However, it may cause the application
programs to generate errors and/or inappropriate results. When a block is doubly
allocated, a KILL may remove data outside its proper scope.</p><p>A doubly allocated index block may also cause increasing numbers of blocks to
become corrupted. Use the following process to correct the problem.</p><p>First, identify all pointers to the block, using FIND EXHAUSTIVE and/or
information reported by MUPIP INTEG. If the error report identifies the block as
containing inappropriate keys or a bad level, INTEG has identified all paths
that include the block. In that case, INTEG reports all paths after the first
with the doubly allocated error, and the first path with some other, for
example, "Keys out of order" error. </p><p>IF THE INTEG REPORT DOES NOT MENTION THE BLOCK PRIOR TO THE DOUBLY ALLOCATED
ERROR, use FIND EXHAUSTIVE to identify all pointers to that block.</p><p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p><p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), you may sort through the block
and its descendants to disentangle intermixed data. If the block has a level of
more than one (1), this may be worth a try. The salvage strategy (discussed in
section O4) may be time consuming and there may be only one misplaced node.
However, in general, the salvage strategy is less demanding and less
dangerous.</p><p>IF YOU CHOOSE THE SALVAGE STRATEGY, REMOVE the records that point to the
block, MAP it FREE, and refer to section O4.</p><p>IF YOU DECIDE TO WORK WITH THE BLOCK, choose the path to retain, REMOVE the
other pointer record, and relocate any misplaced descendants with DSE ADD and
REMOVE. </p></div><div class="sect2" title="K4&#8211;Pointer Problems"><div class="titlepage"><div><div><h3 class="title"><a name="k4_pointer_prbl"></a>K4&#8211;Pointer Problems</h3></div></div></div><p>Each index block is made up of records that contain keys and corresponding
pointers. In the case where database damage is a symptom of an incorrect key
paired with a valid pointer, the repair strategy, which may be implemented with
a number of tactics, is to use the pointer to locate the data and reconstruct
the key. </p><p>While they occur very infrequently, invalid pointers do not permit the same
strategy. If there is an invalid pointer, always eliminate the record containing
the bad pointer using the DSE REMOVE command. Since no data can be stored under
an invalid pointer, either the pointer error was discovered on the first attempt
to use it and no data has been lost, or the pointer was damaged during use. If
the pointer was damaged during use, the lost data should be located by examining
"Block incorrectly marked busy" errors and generally be recovered as described
in section O4.</p><p>IF MUCH DATA IS LOST, it may be worthwhile attempting to reconstruct the bad
record as follows. Before removing the record containing the bad pointer, use
the DUMP command to note the key in the record. Using the error reports and/or
the DSE RANGE command, locate the block to which the key should point. Then use
DSE ADD to replace the previously deleted record with a new record that has the
correct key and pointer in place.</p></div><div class="sect2" title="K5&#8211;Star Key Problems"><div class="titlepage"><div><div><h3 class="title"><a name="i5_star_key_prblms"></a>K5&#8211;Star Key Problems</h3></div></div></div><p>The last record in every index block must be a star-key record that points to
a block that continues the path to all data not covered by the preceding records
in the block. Star-key records have a unique format with a size of seven (7), or
eight (8), depending on the platform, and a compression count of zero (0). The
errors discussed in this section indicate a missing or damaged star-key and may
be attacked with two strategies.</p><p>In general, you should turn the last existing record into a star-key. This
works well as long as the block holds at least one valid record. If you choose
this strategy, locate the last record using DUMP RECORD=9999. Then DUMP the last
record and note its pointer. Next, REMOVE the last record. Finally, ADD STAR
POINTER= to the key you noted.</p><p>If the star-key is the only record in a root block, you should add a new empty
level 0 descendent. If you choose this strategy, add a new star-key using FIND
FREEBLOCK HINT=this-block to locate a nearby block. Next, MAP the new block BUSY
and CHANGE LEVEL= 0 and BSIZ=7(or 8, if your platform dictates). If the new
block has a level of zero (0), return to the damaged block and ADD STAR
POINTER=the-first-new-block.</p></div><div class="sect2" title="K6&#8211;Compression Count Error"><div class="titlepage"><div><div><h3 class="title"><a name="k6_compression_count_error"></a>K6&#8211;Compression Count Error</h3></div></div></div><p>"Compression count not maximal" indicates that the compression count that is
used to save space in key storage is not correct.</p><p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p><p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), REMOVE the record and ADD it
back in the same location with the same KEY=, and POINTER= or STAR.</p><p>You may also adjust the compression count using CHANGE CMPC=. Because this
changes the value of all subsequent keys in the block (except the star-key), you
should try this alternative only if those keys also appear incorrect. </p></div><div class="sect2" title="K7&#8211;Key Warning"><div class="titlepage"><div><div><h3 class="title"><a name="k7_key_warning"></a>K7&#8211;Key Warning</h3></div></div></div><p>"Key too large for database maximum" indicates that the database holds a key
that is legal to GT.M but exceeds the KEY_MAX_SIZE for the database. </p><p>Use the DSE command CHANGE FILEHEADER KEY_MAX_SIZE= to adjust the file
limitation. Alternatively, you may remove the record, using the M command KILL
on an ancestor node. If any user attempts to modify or replace the record in the
database while the key is over-length, GT.M will reject the SET with an error.
</p></div><div class="sect2" title="M1&#8211;Bitmap Errors"><div class="titlepage"><div><div><h3 class="title"><a name="m1_bitmap_errors"></a>M1&#8211;Bitmap Errors</h3></div></div></div><p>Every block in the file has a corresponding bit in a bitmap. All blocks with
valid data are marked busy in their maps; all blocks that are unused or no
longer hold data are marked free. GDS uses bitmaps to locate free blocks
efficiently. The errors discussed in this section indicate problems with
bitmaps.</p><p>"Block incorrectly marked free" is the only potentially dangerous bitmap
error. This error means that the block is within the B-tree structure, but that
the bitmap shows it available for use (i.e., it is a "Block doubly allocated"
waiting to happen). Immediately use DSE to MAP such blocks BUSY.</p><p>Bitmap information is redundant (i.e., bitmaps can be recreated by scanning
the B-tree); however, the majority of bitmap errors reflect secondary errors
emanating from flaws in the B-tree, which are often reported as key or data
errors by MUPIP INTEG. </p><p>When INTEG encounters an error, it stops processing that leaf of the tree.
When it subsequently compares its generated bitmaps to those in the database, it
reports the blocks belonging in the tree that it could not find as "Block
incorrectly marked busy." This error type can be viewed as a flag, marking the
location of a block of lost data whose index is disrupted.</p><p>INTEG reports each block that it concludes is incorrectly marked, and also the
local map that holds the "bad" bits. Furthermore, if the local map "errors"
affect whether the local map should be marked full or not full in the master
map, INTEG also reports the (potential) problem with the master map. Therefore,
a single error in a level one (1) index block will generate, in addition to
itself, one or more "Block incorrectly marked busy", one or more "Local bitmap
incorrect", and possibly one or more "Master bitmap shows..." Errors in higher
level index blocks can induce very large numbers of bitmap error reports.</p><p>Because bitmap errors are typically secondary to other errors, correcting the
primary errors usually also cures the bitmap errors. For this reason and, more
importantly, because bitmap errors tend to locate "lost" data, they should
always be corrected at, or close to, the end of a repair session.</p><p>The DSE command MAP provides a way to switch bits in local maps with FREE and
BUSY, propagate the status of a local map to the master map with MASTER, and
completely rebuild all maps from the B-tree with RESTORE. Never use MAP MASTER
until all non-bitmap errors have been resolved.</p></div><div class="sect2" title="M2&#8211;Bitmap Header Problems"><div class="titlepage"><div><div><h3 class="title"><a name="m2_bitmap_header_problms"></a>M2&#8211;Bitmap Header Problems</h3></div></div></div><p>Bitmaps are stored in blocks that have a unique header format with a level of
minus one (-1) and a block size of 87 or 88 depending on the Euclidian ordering
of the platform. The errors discussed in this section indicate a bitmap block
header that violates that format.</p><p>Use the DSE command CHANGE with the BSIZ=87 or 88 (depending on platform) and
LEVEL=-1FF qualifiers to correct the problem. If the block size is too small,
the bitmap will have to be reconstructed using MAP RESTORE or manually from
INTEG error reports using MAP FREE. If there are other errors, defer any MAP
RESTORE until after they have been repaired. </p></div><div class="sect2" title="O1&#8211;Bad Block"><div class="titlepage"><div><div><h3 class="title"><a name="O1_bad_block"></a>O1&#8211;Bad Block</h3></div></div></div><p>GDS organizes the B-tree into logical blocks, each of which GT.M handles
discretely. A block consists of a block header and a lexically increasing
sequence of records. Blocks starting with the root block up to the data blocks
are index blocks. The last block in any complete path is a data block. The
errors discussed in this section indicate a damaged block.</p><p>Determine if the block has other problems by using the DSE command INTEGRIT.
Examine the contents of the block using the DSE command DUMP. You may also
examine the block preceding this block in the path and/or blocks pointed to by
records in this block. If you can determine an appropriate action, use CHANGE
with the BSIZ= and/or LEVEL= qualifiers. If you cannot quickly repair the block,
examine its level with DUMP HEADER. If the block is a data block, that is, level
zero (0), refer to section O3. If the block has a level greater than zero (0),
REMOVE the record that points to the block and refer to section O4.</p></div><div class="sect2" title="O2&#8211;Record Errors"><div class="titlepage"><div><div><h3 class="title"><a name="o2_record_errors"></a>O2&#8211;Record Errors</h3></div></div></div><p>GDS organizes keys with pointers or data to form records. A record has a
header, which holds the record size, and a compression count, which identifies
how much of the preceding key is held in common by this record. Records in the
block are ordered by the values of their keys. The errors discussed in this
section indicate damage to a record. Record errors present an added challenge,
in that they potentially prevent GT.M from correctly interpreting subsequent
records in the same block.</p><p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), refer to section
O3.</p><p>IF THE BLOCK IS AN INDEX BLOCK, that is, has a level greater than zero (0),
the best option is generally to use the salvage strategy discussed in section
O4. REMOVE the damaged record and INTEG the block. If the block is still
corrupt, repeat the last step, REMOVE the pointer to it, and MAP it FREE. In any
case, refer to section O4. </p></div><div class="sect2" title="O3&#8211;Data Block Errors"><div class="titlepage"><div><div><h3 class="title"><a name="o3_data_block_errors"></a>O3&#8211;Data Block Errors</h3></div></div></div><p>The errors described in this section include damage to the header, the
records, or the keys.</p><p>IF THE BLOCK IS LEVEL ZERO (0), use DSE DUMP to examine the contents of the
block. Note any information that might allow you to correct the problem or might
help to identify and recreate the endangered data. If you are familiar with GDS
and hexadecimal representations, you may be able to recognize data that DSE
cannot recognize because of misalignment.</p><p>IF THE BEGINNING OF THE BLOCK IS VALID, DUMP GLO may be able to capture its
contents up to the point where it is damaged. In the worst case, REMOVE the
record that points to the block, MAP it FREE, and lose its entire contents. The
extent and importance of the damage depends on the size of the block and what it
should be holding. In a similar but not quite as drastic case, REMOVE the record
with the problem and lose the contents of that record. </p></div><div class="sect2" title="O4&#8211;Salvage of Data Blocks with Lost Indices"><div class="titlepage"><div><div><h3 class="title"><a name="o4_salvage"></a>O4&#8211;Salvage of Data Blocks with Lost Indices</h3></div></div></div><p>This strategy uses bitmap errors to locate data blocks containing information
that belongs in the B-tree, but are no longer indexed because of errors and/or
repairs to defective indices.</p><p>The algorithm is based on the fact that most bitmap errors are secondary to
index errors. Therefore, it is optimistic about bitmaps and pessimistic about
indices, and tends to error on the side of restoring more rather than less data
to the B-tree. After using this technique, you should always check to see if
obsolete, deleted data was restored. If data was restored, and GDS integrity has
been restored, you can safely KILL the "extra" data.</p><p>IF THE INDICES HAVE BEEN DAMAGED FOR SOME TIME AND THE DAMAGE CAUSED DUPLICATE
KEYS TO BE CREATED, this strategy raises the issue of which value is the
"correct" value. Because most applications either form new nodes or update
existing nodes rather than simply overlaying them, this issue seldom arises.
Usually the application will fail in an attempt to update any "misplaced" node.
If the problem does arise, the issue may not be determining the "correct" value,
but the best available value. </p><p>IF THE DUPLICATE NODE PROBLEM COULD BE AN APPLICATION ISSUE, you can load the
sequential file produced in DSE with an M program that detects and reports
duplicate nodes. You can also use the block transaction numbers as clues to the
order in which blocks were updated. However, remember that you generally cannot
know which record was modified on the last update, and that DSE repair actions
modify the block transaction number. </p><p>If the duplicate node problem poses a significant problem, you should probably
not use DSE to repair the database, but instead, use journals to recover or
restore from backups.</p><p>This strategy works well when the missing indices are level one (1). However,
the time required increases dramatically as the level of the missing index
increases. If you have a problem with a level four (4) or level five (5) index,
and you have developed skill with DSE, you may wish to try the more technically
demanding approach of repairing the indices.</p><p>Once you have corrected all errors except bitmap errors, SPAWN and use MUPIP
INTEG FAST REGION NOMAP to get a list of all remaining bitmap errors. If the
report includes any "Blocks incorrectly marked free", MAP them BUSY. Then use
DUMP HEADER BLOCK= to examine each "Block incorrectly marked busy." If the level
is one (1), DUMP the block GLO. In any case, MAP it FREE. Once all blocks have
been collected in a sequential file in this fashion, use MUPIP LOAD to reclaim
the data from the sequential file.</p><p>Example:</p><pre class="programlisting">r !,"SET REGION to &lt;$default&gt;: ",r s:r="" r="$default"
w !
s out="db_integ.com",in="db_integ.log"
o out:newv u out
w "$ define/user sys$output ",in,!
w "$ mupip integ/fast/nomap/region ",r,!
w "$ exit",!
c out
zsy "@db_integ"
s out="db_drive.com",skip=$c(32,10,13)
s prefix="map/bl=",old="",lenold=0,blk=0
o in:(read:exc="g done"),out:newv
u out 
w "$ dse",!,"FIND/REGION=",r,!,"open/file=db.go",!
u in
f r x i x["marked" u out d out u in
; CAUTION: in the above line, 
; "marked" MUST be in  lower-case
done u out
w "close",!,"exit",!
w "$ mupip load db.go",!,"$ exit",!
; comment out the line above if you wish 
; to examine db.go 
; and initiate the load separately
c in,out
zsy "@db_drive"
q
out  f j=1:1:$l(x) q:skip'[$e(x,j)
s blk=$p($e(x,j,999)," ",1)
s state=$s($e(x,44)="f":"/busy",1:"/free")
; CAUTION: in the above line, "f" MUST be in lower-case
i state="/free" w "dump/glo/bl=",blk,!
; CAUTION: in the above line, "/free" MUST match 
; the case in the $SELECT above 
; comment out the above line (starting with "i state")
; if you wish to eliminate, rather than save, 
; the contents of loose busy blocks
w prefix,blk,state,! 
q</pre><p>This routine provides a basic example of automating the technique described in
this section. It must be run from an appropriate directory with a properly
defined <span>GTM$GBLDIR</span>
 but can be extended to be more user
friendly.</p></div><div class="sect2" title="P1&#8211;Process Damage"><div class="titlepage"><div><div><h3 class="title"><a name="p1_process_damage"></a>P1&#8211;Process Damage</h3></div></div></div><p>A damaged process is one that has become internally "confused" and is
executing in a pathological way not caused by circumstances in the external
environment.</p><p>IF YOU HAVE DISCOVERED THAT A PROCESS WAS DAMAGED, carefully review all events
related to that process leading to the discovery of the problem. It may be
possible that the process had an elevated priority and was not hanging, but
rather was "hogging" system resources. It is also possible that the problem is
an application loop problem, missed by not performing the steps in section H3
with enough rigor. </p><p>
<span>Review the OpenVMS error logs</span>
for evidence of any hardware problem that might damage a process.
</p></div><div class="sect2" title="Q1&#8211;Restricting Database Access"><div class="titlepage"><div><div><h3 class="title"><a name="q1_restict_db_access"></a>Q1&#8211;Restricting Database Access</h3></div></div></div><p>Prevent new users from attempting to access the database by taking
steps such as setting the limit on interactive users to zero (0), and
deassigning logical names. Also, abort with MUPIP STOP or DCL STOP all processes
accessing the database in question. Because the DSE command CRITICAL /INITIALIZE
/RESET generates errors for all processes accessing a database file, it provides
a quick way to terminate such processes.</p></div><div class="sect2" title="R1&#8211;GT.M Run-Time Errors"><div class="titlepage"><div><div><h3 class="title"><a name="r1_gtm_run_time_errors"></a>R1&#8211;GT.M Run-Time Errors</h3></div></div></div><p>GT.M processes may detect errors at run-time. These errors trigger the GT.M
error handling mechanism, which generally places the process in direct mode, or
triggers the application programs to transcribe an error context to a sequential
file or to a global. For more information on error handling, refer to the "Error
Processing" chapter of the <a class="ulink" href="../../pg/VMS_manual/index.html" target="_top">GT.M Programmer's Guide</a>.</p><p>Most run-time errors are related to the application and its environment.
However, some errors reflect the inability of a process to properly deal with a
database. Some errors of this type are also, or only, generated by the GT.M
utility programs.</p><p>For descriptions of individual errors, refer to the GT.M Message and Recovery
Procedure Reference Manual.</p><p>IF YOU CANNOT REPRODUCE SUCH ERRORS WITH ANOTHER PROCESS PERFORMING THE SAME
TASK, or with an appropriately directed MUPIP INTEG, they were most likely
reported by a damaged process. In this case, refer to section P1.</p><p>The following table lists run-time errors, alphabetically by mnemonic, each
with a section reference for further information.</p><div class="informaltable"><table width="100%" border="1"><colgroup><col><col><col></colgroup><thead><tr><th colspan="3">
<p>Run-Time Error Messages Identifying Potential System
Problems</p>

</th></tr><tr><th>
<p>ERROR MNEMONIC</p>
</th><th>
<p>ERROR MESSAGE TEXT</p>
</th><th>
<p>SECTION</p>
</th></tr></thead><tbody><tr><td>
<p>BADDVER</p>
<p>BITMAPSBAD</p>
<p>BTFAIL</p>
<p>CCPINTQUE</p>
<p>CRITRESET</p>
</td><td>
<p>Incorrect database version vvv</p>
<p>Database bitmaps are incorrect</p>
<p>The database block table is corrupt</p>
<p>Interlock failure accessing Cluster Control Program
queue</p>
<p>The critical section crash count for rrr region has been
incremented</p>
</td><td>
<p>I2</p>
<p>M1</p>
<p>R3</p>
<p>R7</p>
<p>I8</p>
</td></tr><tr><td>
<p>DBCCERR</p>
<p>DBCRPT</p>
<p>DBFILERR</p>
<p>DBNOFILEP</p>
<p>DBNOTGDS</p>
</td><td>
<p>Interlock instruction failure in critical mechanism for
region rrr</p>
<p>Database is flagged corrupt </p>
<p>Error with database file</p>
<p>No database file has been successfully opened</p>
<p>Unrecognized database file format</p>
</td><td>
<p>R7</p>
<p>I8</p>
<p>I5</p>
<p>I5</p>
<p>I5</p>
</td></tr><tr><td>
<p>DBOPNERR</p>
<p>DBRDERR</p>
<p>FORCEDHALT</p>
<p>GBLDIRACC</p>
<p>GBLOFLOW</p>
</td><td>
<p>Error opening database file</p>
<p>Cannot read database file after opening</p>
<p>Image HALTed by MUPIP STOP</p>
<p>Global Directory access failed, cannot perform database
functions</p>
<p>Database segment is full</p>
</td><td>
<p>I5</p>
<p>I5</p>
<p>R4</p>
<p>I5</p>
<p>R5</p>
</td></tr><tr><td>
<p>GVKILLFAIL</p>
<p>GVORDERFAIL</p>
<p>GVPUTFAIL</p>
<p>GVQUERYFAIL</p>
<p>GVRUNDOWN</p>
</td><td>
<p>Global variable KILL failed. Failure code: cccc</p>
<p>Global variable $ORDER or $NEXT function failed. Failure
code: cccc </p>
<p>Global variable put failed. Failure code: cccc</p>
<p>Global variable $QUERY function failed. Failure code:
cccc</p>
<p>Error during global database rundown</p>
</td><td>
<p>R2</p>
<p>R2</p>
<p>R2</p>
<p>R2</p>
<p>I5</p>
</td></tr><tr><td>
<p>GDINVALID</p>
<p>GTMCHECK</p>
<p>GVDATAFAIL</p>
<p>GVDIRECT</p>
<p>GVGETFAIL</p>
</td><td>
<p>Unrecognized Global Directory format: fff</p>
<p>Internal GT.M error&#8211;report to FIS</p>
<p>Global variable $DATA function failed. Failure code:
cccc</p>
<p>Global variable name could not be found in global
directory</p>
<p>Global variable retrieval failed. Failure code:
cccc</p>
</td><td>
<p>I5</p>
<p>R6</p>
<p>R2</p>
<p>I5</p>
<p>R2</p>
</td></tr><tr><td>
<p>GVZPREVFAIL</p>
<p>MUFILRNDWNFL</p>
<p>UNKNOWNFOREX</p>
<p>TOTALBLKMAX</p>
<p>WCFAIL</p>
</td><td>
<p>Global variable $ZPREVIOUS function failed. Failure code:
cccc</p>
<p>File rundown failed</p>
<p>Process halted by a forced exit from a source other than
MUPIP</p>
<p>Extension exceeds maximum total blocks, not
extending</p>
<p>The database cache is corrupt</p>
</td><td>
<p>R2</p>
<p>I5</p>
<p>R4</p>
<p>R5</p>
<p>R3</p>
</td></tr></tbody></table></div></div><div class="sect2" title="R2&#8211;Structural Database Integrity Errors"><div class="titlepage"><div><div><h3 class="title"><a name="r2_structure_db_integ"></a>R2&#8211;Structural Database Integrity Errors</h3></div></div></div><p>These run-time errors indicate that the process detected an integrity error
within the body of the database.</p><p>Verify the error using the MUPIP command INTEG SUBSCRIPT=, specifying an
immediate ancestor node of the global variable displayed in the error message.
Alternatively, you may try the access by running the same routine in another
process or by using Direct Mode to perform the same actions as those performed
by the M line that triggered the error. If you cannot reproduce the error, refer
to section P1.</p><p>Most of these errors terminate with a four-character failure code. Each
character in the code represents the failure type for an attempt to perform the
database access. In cases where the letters are not all the same, the last code
is the most critical, because it reflects what happened when the process made
its last retry. Earlier tries show error codes that are important to
establishing the context of the last error.</p><p>The following table lists the failure codes, whether or not they require a
MUPIP INTEG, a brief description of the code's meaning, and a section reference
for locating more information.</p><div class="informaltable"><table width="100%" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th colspan="4">
<p>Run-Time Database Failure Codes</p>

</th></tr><tr><th>
<p>FAIL CODE</p>
</th><th>
<p>RUn INTEG</p>
</th><th>
<p>DESCRIPTION</p>
</th><th>
<p>SECTION</p>
</th></tr></thead><tfoot><tr><th colspan="4">
<p>* Indicates a process problem</p>

</th></tr></tfoot><tbody><tr><td>
<p>A</p>
<p>B</p>
<p>C</p>
<p>D</p>
<p>E</p>
</td><td>
<p>x</p>
<p>x</p>
<p>x</p>
<p>x</p>

</td><td>
<p>Special case of code C.</p>
<p>Key too large to be correct.</p>
<p>Record unaligned: properly formatted record header did not
appear where expected.</p>
<p>Record too small to be correct.</p>
<p>History overrun prevents validation of a block.</p>
</td><td>
<p>O2</p>
<p>K1</p>
<p>O2</p>
<p>O2</p>
<p>R3</p>
</td></tr><tr><td>
<p>G</p>
<p>H*</p>
<p>J</p>
<p>K</p>
<p>L</p>
</td><td>

<p>-</p>
<p>x</p>


</td><td>
<p>Cache record modified while in use by the
transaction.</p>
<p>Development of a new version of a block encountered an out
of design condition.</p>
<p>Level on a child does not show it to be a direct
descendent of its parent.</p>
<p>Cache control problem encountered or suspected.</p>
<p>Conflicting update of a block took priority.</p>
</td><td>
<p>R3</p>
<p>P1</p>
<p>O1</p>
<p>C1</p>
<p>R3</p>
</td></tr><tr><td>
<p>M</p>
<p>N</p>
<p>O</p>
<p>P</p>
<p>Q</p>
</td><td>
<p>x</p>


<p>x</p>

</td><td>
<p>Error during commit that the database logic does not
handle.</p>
<p>A primitive such as a file or queue operation
failed.</p>
<p>Before image was lost prior to its transfer to the journal
buffer.</p>
<p>Multi-block update aborted - database damage
likely.</p>
<p>Shared memory interlock failed.</p>
</td><td>
<p>P1</p>
<p>R7</p>
<p>R3</p>
<p>I5</p>
<p>R7</p>
</td></tr><tr><td>
<p>R</p>
<p>S</p>
<p>U</p>
<p>V</p>
<p>X</p>
</td><td>




<p>x</p>
</td><td>
<p>Critical section reset (probably by DSE).</p>
<p>Attempt to increase the level beyond current
maximum.</p>
<p>Cache record unstable while in use by the
transaction.</p>
<p>Read-only process could not find room to work.</p>
<p>Bitmap block header invalid.</p>
</td><td>
<p>R5</p>
<p>R8</p>
<p>R3</p>
<p>R9</p>
<p>M2</p>
</td></tr><tr><td>
<p>Y</p>
<p>Z</p>
<p>a</p>
<p>b</p>
<p>c</p>
</td><td>
<p>x</p>
<p>x</p>



</td><td>
<p>Record offset outside of block bounds.</p>
<p>Block did not contain record predicted by the
index.</p>
<p>Predicted bitmap preempted by another update.</p>
<p>History overrun prevents validation of a bitmap.</p>
<p>Bitmap cache record modified while in use by the
transaction.</p>
</td><td>
<p>02</p>
<p>02</p>
<p>R3</p>
<p>R3</p>
<p>R3</p>
</td></tr><tr><td>
<p>d</p>
<p>e</p>
<p>f</p>
<p>g</p>
</td><td>

<p>x</p>



</td><td>
<p>Not currently used.</p>
<p>Attempt to read a block outside the bounds of the
database.</p>
<p>Conflicting update took priority on a non-isolated global
and a block split requires a TP_RESTART.</p>
<p>The number of conflicting updates on non-isolated global
nodes exceed an acceptable level and requires a
TP_RESTART.</p>
</td><td>
<p>-</p>
<p>02</p>
<p>R3</p>
<p>R3</p>
</td></tr></tbody></table></div></div><div class="sect2" title="R3&#8211;Run-time Database Cache Problems"><div class="titlepage"><div><div><h3 class="title"><a name="r2_run_time_db_cache"></a>R3&#8211;Run-time Database Cache Problems</h3></div></div></div><p>These messages indicate probable process damage or database cache corruption.
Retry the action with another process. If the second process also fails, refer
to section H4; otherwise, refer to section P1.</p></div><div class="sect2" title="R4&#8211;Stopped Processes"><div class="titlepage"><div><div><h3 class="title"><a name="r4_stopped_processes"></a>R4&#8211;Stopped Processes</h3></div></div></div><p>These errors indicate the process received a message from a <span>an OpenVMS FORCEX</span>
system service
requesting that the image terminate.</p><p>The MUPIP STOP command uses <span>OpenVMS FORCEX</span>
 with a distinguished code. The code provided by
MUPIP STOP allows the process to include the source of the stop directive in the
error message. </p></div><div class="sect2" title="R5&#8211;No More Room in the File"><div class="titlepage"><div><div><h3 class="title"><a name="r5_no_more_room"></a>R5&#8211;No More Room in the File</h3></div></div></div><p>IF THE DATABASE FILLS UP AND CANNOT EXPAND, processes that try to add new
information to the database experience run-time errors. The following conditions
prevent automatic database expansion.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Using the MM access method</p></li><li class="listitem"><p>Using a file extension of zero (0)</p></li><li class="listitem"><p>Inadequate free blocks available on the volume to handle the specified
extension</p></li></ul></div><p>You can handle the first two cases by using the MUPIP EXTEND command. MUPIP
EXTEND may also help in dealing with the third case by permitting an extension
smaller than that specified in the file header. Note that the extension size in
the file header, or /BLOCKS= qualifier to MUPIP EXTEND, is in GDS blocks and
does not include overhead for bitmaps.</p><p>IF THERE IS NO MORE SPACE ON A VOLUME, you may use the M command KILL to
delete data from the database. To KILL an entire global, the database file must
contain one free GDS block. You may acquire these by KILLing a series of
subscripted nodes or by doing a small extension.</p><p>You may also use DCL commands such as COPY, DELETE, and PURGE to
remove files from the volume and place them on another.</p><p>Finally, you may create or add to a bound volume set with the MOUNT utility
invoked by the DCL command MOUNT. If you change the RMS placement of the files,
be sure to adjust the Global Directory and/or the logical names to match the new
environment.</p><p>You can also add a new disk. If you change the placement of the files, be sure
to also adjust the Global Directory and/or the environment variables to match
the new environment.</p></div><div class="sect2" title="R6&#8211;GTMASSERT and GTMCHECK Errors"><div class="titlepage"><div><div><h3 class="title"><a name="r6_gtmassert_and_gtmcheck_errors"></a>R6&#8211;GTMASSERT and GTMCHECK Errors</h3></div></div></div><p>GTMCHECK errors indicate that a process has detected some sort of
logical inconsistency. GTMCHECK errors usually produce a context file called
GTMDUMP.DMP in the SYS$LOGIN directory of the account of the process that
experienced the error. Consult FIS after gathering all
information about the circumstances surrounding the error. </p><div class="sect3" title="Dealing with Untrapped GT.M Errors"><div class="titlepage"><div><div><h4 class="title"><a name="dealing_with_gtm_err"></a>Dealing with Untrapped GT.M Errors</h4></div></div></div><p>When certain errors occur GT.M does not process $ZTrap. The following
section help you gather information from an OpenVMS DUMP to help you
identify the problem and select an appropriate method of resolution.</p><div class="sect4" title="Gathering Information from an OpenVMS Process Dump"><div class="titlepage"><div><div><h5 class="title"><a name="gathering_info"></a>Gathering Information from an OpenVMS Process Dump </h5></div></div></div><p>In the following cases the process is deemed to be damaged beyond
reasonable expectation of recovery.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>In the following cases the process is deemed to be damaged
beyond reasonable expectation of recovery.</p></li><li class="listitem"><p>Access Violation (ACCVIO)&#8211;an attempt to access protected
memory.</p></li><li class="listitem"><p>GTMCHECK&#8211;failure of an internal consistency check.</p></li><li class="listitem"><p>OPCDEC&#8211;the operation code at the indicated address is not
known.</p></li><li class="listitem"><p>ROPRAND&#8211;an instruction contains an operand in a format that is
not acceptable.</p></li><li class="listitem"><p>Stack overflow; however this is preceded by a STACK CRIT
(warning) error.</p></li></ul></div><p>OpenVMS provides a facility to dump the memory of a process for
subsequent analysis. This requires significant time and disk space when
a process has large amounts of virtual address space. Contact FIS for guidance on whether this technique can be
safely employed at your production sites.</p><p>In OpenVMS, additional protection has been added to help detect
inappropriate modifications to memory.</p><p>If it is possible to use process dump, the following DCL command
should be added to the LOGIN.COM files for users who are experiencing
untrapped failures:</p><pre class="programlisting">$ set proc/dump
</pre><p>Your terminal may become unavailable for several minutes if your
process dumps. A procedure should also be established to ensure that the
.dmp files which are generated are copied to tape and deleted promptly
so that they do not create a disk space crisis.</p><p>Please do not try to use process dumps unless you have a thorough
understanding of the possible unpleasant side effects.</p></div></div></div><div class="sect2" title="R7&#8211;Interlocked Queue Hardware Problems"><div class="titlepage"><div><div><h3 class="title"><a name="r7_interlock_q"></a>R7&#8211;Interlocked Queue Hardware Problems</h3></div></div></div><p>These messages indicate possible problems with multiple processor
synchronization. Initiate running of hardware diagnostics. If the diagnostics do
not locate a problem, consider consulting with FIS 
after gathering all information about the circumstances of the error.</p></div><div class="sect2" title="R8&#8211;Database Tree Maximum Level Exceeded"><div class="titlepage"><div><div><h3 class="title"><a name="r8_db_tree"></a>R8&#8211;Database Tree Maximum Level Exceeded</h3></div></div></div><p>An attempt has been made to create a tree in the database that contains seven
or more levels. The legal levels for a tree are zero to seven. You can add new
levels to the global either by killing some of the existing subscripts, or by
extracting the global and reloading it into a database with a larger block size,
so it does not require as large a tree.</p></div><div class="sect2" title="R9&#8211;Read-only Process Blocked"><div class="titlepage"><div><div><h3 class="title"><a name="r9_read"></a>R9&#8211;Read-only Process Blocked</h3></div></div></div><p>While it is unlikely in normal operation, there is a possibility that a
process that has read-only access to a database file may fail because it cannot
acquire enough cache space to do its work. Because it does not have authority to
write to the database, such a process cannot flush modified cache records to
disk: it must rely on updating processes to keep the number of modified records
down to a point that permits read-only access to the database to proceed
successfully. However, if updating processes exit in a fashion that does not
permit them to flush out modified records, the read-only process (particularly
one doing a large transaction) may fail because the cache cannot supply enough
blocks. This condition can be cleared by a DSE BUFFER command in the affected
region(s).</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch11s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch11.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="go01.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Repairing the Database with DSE </td><td width="20%" align="center"><a accesskey="h" href="titlepage.html">Home</a></td><td width="40%" align="right" valign="top"> Glossary</td></tr></table></div></body>
<!-- Mirrored [from host tinco.pair.com [file /bhaskar/gtm/doc/books/ao/OpenVMS_manual/ch11s04.html]] -->
</html>
