<html>
<HEAD><META HTTP-EQUIV="Pragma" CONTENT="no-cache"><META HTTP-EQUIV="Expires" CONTENT="-1">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Name, Region, and Segment Qualifiers</title>
<link rel="stylesheet" href="gtm.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="GT.M Administration and Operations Guide">
<link rel="up" href="gdechap.html" title="Chapter 4. Global Directory Editor">
<link rel="prev" href="gdecmds.html" title="Global Director Editor Commands">
<link rel="next" href="gde_cmmd_summ.html" title="GDE Command Summary">
<link rel="copyright" href="ln-idm45807489303168.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">
<span>Name, Region, and Segment </span>Qualifiers</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="gdecmds.html">Prev</a> </td>
<th width="60%" align="center">Chapter 4. Global Directory Editor</th>
<td width="20%" align="right"> <a accesskey="n" href="gde_cmmd_summ.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">GT.M Administration and Operations Guide</a></span> &gt; <span class="breadcrumb-link"><a href="gdechap.html">Global Directory Editor</a></span> &gt; <span class="breadcrumb-node"><span>Name, Region, and Segment </span>Qualifiers</span>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="nameregseg"></a><span>Name, Region, and Segment </span>Qualifiers</h2></div></div></div>
<p> The <span>-</span>NAME, <span>-</span>REGION, and <span>-</span>SEGMENT qualifiers each have additional qualifiers used to further define or specify characteristics of a name, region, or segment. <span>The following sections describe these additional qualifiers.</span> </p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="name_qualifiers"></a>Name Qualifiers<a class="indexterm" name="idm45807487705552"></a>
</h3></div></div></div>
<p>The following <span>-</span>NAME qualifier can be used with the ADD or CHANGE commands.</p>
<pre class="programlisting">-REGION=region-name</pre>
<p>Specifies the name of a region. Region names are not case-sensitive, but are
represented as uppercase by GDE.</p>
<p>The minimum length is one alphabetic character. </p>
<p>The maximum length is 31 alphanumeric characters.</p>
<p>Example:</p>
<a class="indexterm" name="idm45807487668416"></a><pre class="programlisting">GDE&gt; add -name a* -region=areg</pre>
<p>This command creates the namespace a*, if it does not exist, and maps it to the region areg.</p>
<p><span class="emphasis"><em>Summary</em></span></p>
<div class="informaltable">
<a name="tblgdenamequal"></a><table border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="4">
<p>GDE NAME Qualifiers</p>
</th></tr>
<tr>
<th>
<p>QUALIFIER</p>
</th>
<th>
<p>DEFAULT</p>
</th>
<th>
<p>MINIMUM</p>
</th>
<th>
<p>MAXIMUM</p>
</th>
</tr>
</thead>
<tbody><tr>
<td>
<p><span>-</span>R[EGION]=region-name (characters)</p>
</td>
<td>
<p>(none)</p>
</td>
<td>
<p>1A</p>
</td>
<td>
<p>16A/N</p>
</td>
</tr></tbody>
</table>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="region_qual"></a>Region Qualifiers<a class="indexterm" name="idm45807487639184"></a>
</h3></div></div></div>
<p>The following <span>-</span>REGION qualifiers can be used with the ADD, CHANGE, or TEMPLATE commands. </p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]AU[TODB]<a class="indexterm" name="idm45807488075504"></a>
</em></span>
</p>
<p>Specifies whether GT.M should implicitly create a database file for the region if none exists when a process attempts to access it. Because it carries lower operational risk and provides better operational control, the common practice is to create database files with MUPIP CREATE. However, AUTODB may simplify operations when you have scratch or temporary databases which are best deleted and recreated as a part of standard operation procedures. </p>
<p>The default is NOAUTODB.</p>
<p>
<span class="emphasis"><em>
<span>-</span>C[OLLATION_DEFAULT]=number <a class="indexterm" name="idm45807487635760"></a>
</em></span>
</p>
<p>Specifies the number of the collation sequence definition to be used
as the default for this database file. The number can be any integer from 0 to
255. The number you assign as a value must match the number of a defined
collation sequence that resides in the shared library pointed to by the
environment variable gtm_collate_n. For information on defining this environment
variable and creating an alternate collation sequence, refer to the
"Internationalization" chapter in the <a class="ulink" href="../../pg/UNIX_manual/index.html" target="_top">GT.M Programmer's Guide</a>.</p>
<p>The minimum COLLATION_DEFAULT number is zero, which is the standard M
collation sequence.</p>
<p>The maximum COLLATION_DEFAULT number is 255.</p>
<p>By default, GDE uses zero (0) as the COLLATION_DEFAULT.</p>
<p>
<span class="emphasis"><em>
<span>-</span>D[YNAMIC_SEGMENT]=segment-name 
<a class="indexterm" name="idm45807487736064"></a>
</em></span>
</p>
<p>Specifies the name of the segment to which the region is mapped. Segment-names
are not case-sensitive, but are displayed as uppercase by GDE.</p>
<p>The minimum length is one alphabetic character. </p>
<p>The maximum length is 31 alphanumeric characters.</p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]EPOCHTAPER<a class="indexterm" name="idm45807487673888"></a>
<a class="indexterm" name="idm45807487665376"></a></em></span></p>
<p>Tries to minimize epoch duration by reducing the number of buffers to flush by GT.M and the file system (via an fsync()) as the epoch (time-based or due to a journal file auto-switch) approaches. By default, EPOCHTAPER is enabled. Epoch tapering reduces the impact of I/O activity during an epoch event. Application that experience high load and/or need to reduce latency may benefit from epoch tapering. </p>
<p><span class="emphasis"><em>
-[NO]INST[_FREEZE_ON_ERROR]<a class="indexterm" name="idm45807487617488"></a>
</em></span></p>
<p>Controls whether custom errors in a region should automatically cause an Instance Freeze. This qualifier modifies the value of "Inst Freeze on Error" file header element. </p>
<p>For more information on setting up a list of custom errors that automatically invoke an Instance Freeze, refer to <a class="xref" href="ch07s02.html#inst_freeze" title="Instance Freeze">&#8220;Instance Freeze&#8221;</a>.</p>
<p>For more information on setting or clearing an Instance Freeze on an instance irrespective of whether any region is enabled for Instance, refer to <a class="xref" href="replication.html#start_src_srvr" title="Starting the Source Server">&#8220;<span>Starting the </span> Source Server&#8221;</a>.</p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]J[OURNAL][=journal-option-list]  <a class="indexterm" name="idm45807487611168"></a>
</em></span>
</p>
<p>This qualifier establishes characteristics for the journal file on newly created databases. </p>
<p>
<span>-</span>NOJOURNAL specifies that updates to the database file are not journaled. 
<span>-</span>NOJOURNAL does not accept an argument assignment.</p>
<p>
<span>-</span>JOURNAL specifies that journaling is allowed. 
<span>-</span>JOURNAL takes one or more arguments in a journal-option-list. The journal-option-list contains keywords separated with commas (,) enclosed in parentheses ( ) with file-names quoted (for example, change -region test -journal=(before,file="foo") . If the list contains only one keyword, the parentheses and quotes are optional.</p>
<p>Although you do not have to establish the criteria for your journaling process
at this point, it is efficient to do so, even if you are not entirely sure you
will use journaling. The options available for <span>-</span>JOURNAL set up the environment, so it is ready for you to enable with MUPIP SET <span>-</span>JOURNAL. You can also change or add any of the established options at that time.</p>
<p>For more information about journaling, see <a class="xref" href="journaling.html" title="Chapter 6. GT.M Journaling">Chapter 6: &#8220;<i><span>GT.M </span>Journaling</i>&#8221;</a>. </p>
<p>The journal-option-list includes:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle">
<p>A[LLOCATION]=blocks</p>
<a class="indexterm" name="idm45807487604592"></a>
</li>
<li class="listitem" style="list-style-type: circle">
<p>AUTOSWITCHLIMIT=blocks</p>
<a class="indexterm" name="idm45807487597472"></a>
</li>
<li class="listitem" style="list-style-type: circle"><p>[NO]BE[FORE_IMAGE]</p></li>
<li class="listitem" style="list-style-type: circle"><p>BU[FFER_SIZE]=pages<a class="indexterm" name="idm45807487595744"></a></p></li>
<li class="listitem" style="list-style-type: circle"><p>E[XTENSION]=blocks<a class="indexterm" name="idm45807487610784"></a></p></li>
<li class="listitem" style="list-style-type: circle">
<p>F[ILE_NAME]=file-specification-name</p>
<a class="indexterm" name="idm45807487600752"></a>
</li>
</ul></div>
<p>The following section describes some <span>-</span>JOURNAL options.</p>
<p>
<span class="emphasis"><em><a class="indexterm" name="idm45807487743072"></a>
<span>-</span>AU[TOSWITCHLIMIT]=blocks</em></span></p>
<p>Specifies the limit on the size of a journal file. When the journal file size reaches the limit, GT.M automatically switches to a new journal file with a back-pointer to the prior journal file.</p>
<p>
<span class="emphasis"><em><a class="indexterm" name="idm45807487593280"></a>
<span>-</span>[NO]BE[FORE_IMAGE]  <a class="indexterm" name="idm45807487592656"></a>
</em></span>
</p>
<p>[NO]BEFORE_IMAGE controls whether the journal should include before-image records.</p>
<p>The BEFORE_IMAGE option is required if you plan to consider "roll-back" (Backward) recovery of the associated database file or if you plan to use certain database replication options.<span> For a description of this type of recovery, refer to <a class="xref" href="journaling.html" title="Chapter 6. GT.M Journaling">Chapter 6: &#8220;<i><span>GT.M </span>Journaling</i>&#8221;</a>.</span> </p>
<p>
<span class="emphasis"><em>
<span>-</span>F[ILE_NAME]=<span>"file-name"</span> <a class="indexterm" name="idm45807487610144"></a>
</em></span>
</p>
<p>
Specifies the name of the journal file.</p>
<p>Unless the name is the sole journaling option, and is the last parameter on the line, it should always be enclosed in quotation marks in this context.</p>
<p>Journal file-specifications-names are limited to 255 characters.</p>
<p>By default, GDE derives the file-specification-name from the database <span>"file-name"</span>.</p>
<p>By default, GDE uses a journal file extension of <span>.mjl</span>. </p>
<p><span class="emphasis"><em>Journal Options Summary</em></span></p>
<p>With GDE, you can create the journal files and define the journal parameters; however, you must use
MUPIP SET to explicitly turn it ON, and you must specify BEFORE/NOBEFORE at that time.</p>
<p>Example:</p>
<pre class="programlisting">CHANGE -REGION DEFAULT -JOURNAL=(ALLOCATION=2048,AUTOSWITCHLIMIT=8386560,BEFORE_IMAGE,BUFFER_SIZE=2312,EXTENSION=2048)</pre>
<p>For information on all Journal options and their allowable minimum and maximum values, see <a class="xref" href="mup_jnl_set.html#set_jnl_options" title="SET -JOURNAL Options">&#8220;<span>SET -</span>JOURNAL Options &#8221;</a> in the "GT.M Journaling" chapter. </p>
<p><span class="emphasis"><em>Summary</em></span></p>
<p>
<span class="emphasis"><em>
<span>-</span>K[EY_SIZE]=size in bytes 
<a class="indexterm" name="idm45807487575600"></a>
</em></span>
</p>
<p>Specifies the maximum size of keys, in bytes, which can be stored in the 
region. The KEY_SIZE must be less than the RECORD_SIZE. GDE rejects the command
if the KEY_SIZE is inappropriate for the RECORD_SIZE.</p>
<p>The minimum KEY_SIZE is three bytes. </p>
<p>The maximum KEY_SIZE is 1,019 bytes. </p>
<p>When determining the maximum key size, applications should consider the following:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>GT.M uses packed decimal representation for numeric subscripts which may be larger or smaller than the original representation.</p></li>
<li class="listitem" style="list-style-type: circle"><p>GT.M substitutes an element terminator for the caret (^), any comma (,), and any right parenthesis ()).</p></li>
<li class="listitem" style="list-style-type: circle"><p>GT.M adds an extra byte for every string element, including the global name.</p></li>
</ul></div>
<p>For example, the key ^ACN ("Name", "Type") internally occupies 17 bytes.</p>
<p>By default, GDE uses a KEY_SIZE of 64 bytes
</p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]L[OCK_CRIT]<a class="indexterm" name="idm45807487562432"></a>
</em></span>
</p>
<p>
</p>
<p>GT.M uses critical sections for LOCK management and various database activities. LOCK_CRIT in GDE specifies that GT.M should use separate critical sections for LOCK management and database activity. NOLOCK_CRIT specifies the use of the database critical section for both LOCK and database activity.</p>
<p>
  
</p>
<p>Because, in the current implementation, FIS has not identified any reason to share resource management between LOCKs and database actions, we have no recommendations other than to choose what seems to work better for your application.</p>
<p>
</p>
<p>By default, GDE uses LOCK_CRIT - separate resource management for LOCKs and database actions.</p>
<p>
</p>
<p>The -[NO]L[OCK_CRIT] setting appears with a different name in other utilities and report output. The following table shows the equivalent setting of the [NO]L[OCK_CRIT] GDE qualifier in other utilities: </p>
<p>
  
</p>
<div class="informaltable">
<a name="lckcrit"></a><table border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
     <p>Utility/Report  </p>
    </th>
<th>
     <p>LOCK and DB share the SAME critical section</p>
    </th>
<th>
     <p>LOCK and DB have SEPARATE critical section (default)</p>
    </th>
</tr></thead>
<tbody>
<tr>
<td>
     <p>GDE Region Qualifier </p>
    </td>
<td>
                  <p><code class="code">-NOLOCK_CRIT</code></p>
    </td>
<td>
                  <p><code class="code">-LOCK_CRIT</code></p>
    </td>
</tr>
<tr>
<td>
     <p><a class="link" href="dse_cmmds_quals.html#dump_dse_cmmd" title="Dump">DSE DUMP -FILEHEADER</a></p>
    </td>
<td>
     <p><code class="code">LOCK shares DB critical section : TRUE</code></p>
    </td>
<td>
     <p><code class="code">LOCK shares DB critical section : FALSE</code></p>
    </td>
</tr>
<tr>
<td>
      <p><a class="link" href="gdm.html#lck_shares_db_crit" title="-Lck_shares_db_crit">MUPIP SET</a> </p>
    </td>
<td>
                  <p><code class="code">-LCK_SHARES_DB_CRIT</code></p>
    </td>
<td>
                  <p><code class="code">-NOLCK_SHARES_DB_CRIT</code></p>
    </td>
</tr>
<tr>
<td>
     <p><a class="link" href="gdm.html#mup_dumpfhead" title="DUMPFHEAD">MUPIP DUMPFHEAD</a> </p>
    </td>
<td>
                  <p><code class="code">("sgmnt_data.lock_crit_with_db")=1</code></p>
    </td>
<td>
                  <p><code class="code">("sgmnt_data.lock_crit_with_db")=0</code></p>
    </td>
</tr>
</tbody>
</table>
</div>
<p>
</p>
<a class="indexterm" name="idm45807487515888"></a><p>
<span class="emphasis"><em>
<span>-</span>[NO]N[ULL_SUBSCRIPTS]=[ALWAYS|NEVER|EXISTING]<a class="indexterm" name="idm45807487513104"></a>
</em></span>
</p>
<p>Indicates whether GT.M allows null subscripts for global variables stored in the region (that is, whether GT.M permits references such as ^aaa("",1)).</p>
<p>ALWAYS indicates that the null subscripts for global variables are allowed.</p>
<p>NEVER indicates that null subscripts for global variables are not allowed.</p>
<p>EXISTING indicates that null subscripts for global variable can be accessed and updated, but not created anew.</p>
<p>By default, regions have <span>-</span>NULL_SUBSCRIPTS=NEVER.</p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]Q[DBRUNDOWN]<a class="indexterm" name="idm45807487549600"></a>
<a class="indexterm" name="idm45807487532432"></a></em></span></p>
<p>Shortens normal process shutdown when a large number of processes accessing a database file need to shutdown almost simultaneously, for example, in benchmarking scenarios or emergencies. </p>
<p>When a terminating GT.M process observes that a large number of processes are attached to a database file and QDBRUNDOWN is enabled, it bypasses checking whether it is the last process accessing the database. Such a check occurs in a critical section and bypassing it also bypasses the usual RUNDOWN actions which accelerates process shutdown removing a possible impediment to process startup. By default, QDBRUNDOWN is disabled.</p>
<p>Note that with QDBRUNDOWN there is a possibility that the last process to exit might leave the database shared memory and IPC resources in need of cleanup. Except after the number of concurrent processes exceeds 32Ki, QDBRUNDOWN minimizes the prossibility of abandoned resources, but it cannot eliminate it. When using QDBRUNDOWN, use an explicit MUPIP RUNDOWN of the database file after the last process exits, to ensure the cleanup of database shared memory and IPC resources; not doing so risk database damage.</p>
<p>When a database has QDBRUNDOWN enabled, if the number of attached processes ever exceeds 32Ki, GT.M stops tracking the number of attached processes, which means that it cannot recognize when the number reaches zero (0) and the shared resources can be released. The process that detects this event issues a NOMORESEMCNT in the system log. This means an orderly, safe shutdown requires a MUPIP JOURNAL -ROLLBACK -BACKWARD for replicated databases, a MUPIP JOURNAL -RECOVER -BACKWARD for unreplicated journaled databases and a MUPIP RUNDOWN for journal-free databases.</p>
<p>
<span class="emphasis"><em>
<span>-</span>R[ECORD_SIZE]=size in bytes <a class="indexterm" name="idm45807487527824"></a>
</em></span>
</p>
<p>Specifies the maximum size (in bytes) of a global variable node's value that can be stored in a region. </p>
<p>If the size of a global exceeds one database block, GT.M implicitly spans that global across multiple database blocks. In the event a global variable node spans multiple blocks, and the process is not already within a TP transaction, the GT.M run-time system automatically and transparently performs the entire operation within an implicit TP transaction (as it does for Triggers).</p>
<p>The minimum RECORD_SIZE is zero. A RECORD_SIZE of zero only allows a global variable node that does not have a value. A typical use of a global variable node with RECORD_SIZE of zero is for creating indices (where the presence of a node is all that is required).</p>
<p>The maximum RECORD_SIZE is <span>1,048,576 bytes (1MiB). </span></p>
<p>By default, GDE uses a RECORD_SIZE of 256 bytes.</p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO][STA[TS]<a class="indexterm" name="idm45807487521920"></a>
</em></span>
</p>
<p>Specifies whether GT.M should permit processes to share their database access statistics for other processes to monitor.  When on, this characteristic causes GT.M to create a small MM database for the associated region to hold the shared statistics. There may be operational or security reasons to prohibit sharing of statistics. For example, GT.M does not share statistics on database files that exist solely to support GT.M features. </p>
<p>Note that a process disables itself from maintaining the shared statistics when it fails to open a statsDB. It does not, however, disable subsequently starting processes from maintaining the shared statistics.</p>
<p>By default, GDE uses STATS.</p>
<p>For more information, refer to VIEW "[NO]STATSHARE" and ^%YGBLSTAT in GT.M Programmer's Guide and gtm_statshare and gtm_statsdir in <a class="xref" href="ch03s02.html" title="Environment Variables">&#8220;Environment Variables&#8221;</a>. </p>
<p>
<span class="emphasis"><em>
<span>-</span>[NO]STD[NULLCOLL] <a class="indexterm" name="idm45807487509728"></a>
</em></span>
</p>
<p>Determines whether GT.M null subscripts collate in conformance to the M standard.</p>
<p>If STDNULLCOLL is specified, subscripts of globals in the database follow the M standard where the null subscript collates before all other subscripts.</p>
<p>If NOSTDNULLCOLL is specified, null subscripts collate between numeric and string subscripts. FIS strongly recommends that you use STDNULL and against using this non-standard null collation, which is the default for historical reasons.</p>
<p>The following table summarizes GDE region qualifiers. It provides their abbreviations, defaults (as provided by FIS), and
allowable minimum and maximum values.</p>
<div class="informaltable">
<a name="tblgdejnlopt"></a><a class="indexterm" name="idm45807487557408"></a><table border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="4">
<p>GDE REGION Qualifiers</p>
</th></tr>
<tr>
<th>
<p>QUALIFIER</p>
</th>
<th>
<p>DEFAULT</p>
</th>
<th>
<p>MINIMUM</p>
</th>
<th>
<p>MAXIMUM</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><span>-</span>[NO]AU[TODB]</p>
</td>
<td>
<p>Disabled</p>
</td>
<td>
<p>-</p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>C[OLLATION_DEFAULT]=number (integer)</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>255</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>D[YNAMIC_SEGMENT] =segment-name (char)</p>
</td>
<td>
-</td>
<td>
<p>1</p>
</td>
<td>
<p>31</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]EPOCHTAPER </p>
</td>
<td>
<p>ENABLED</p>
</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]INST[_FREEZE_ON_ERROR] </p>
</td>
<td>
<p>DISABLED</p>
</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]J[OURNAL] [=journal-option-list]</p>
</td>
<td>
<p>-NOJ</p>
</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><span>-</span>K[EY_SIZE]=size in bytes (integer)</p>
</td>
<td>
<p>64</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>1,019</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]L[OCK_CRIT]</p>
</td>
<td>
<p>Disabled (not shared)</p>
</td>
<td>
<p>-</p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>N[ULL_SUBSCRIPTS]=[ALWAYS|NEVER|EXISTING]</p>
</td>
<td>
<p>NEVER</p>
</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]Q[DBRUNDOWN]</p>
</td>
<td>
<p>Disabled</p>
</td>
<td>
<p>-</p>
</td>
<td>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p><span>-</span>R[ECORD_SIZE]=size in bytes (integer)</p>
</td>
<td>
<p>256</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1,048,576 (1 MiB)</p>

</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]STA[TS] </p>
</td>
<td>
<p>ENABLED</p>
</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><span>-</span>[NO]STD[NULLCOLL] </p>
</td>
<td>
<p>No</p>
</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="segment_quals"></a>Segment Qualifiers<a class="indexterm" name="idm45807487546192"></a>
</h3></div></div></div>
<p>The following <span>-</span>SEGMENT qualifiers can be used with the ADD, CHANGE, or TEMPLATE commands.</p>
<p>
<span class="emphasis"><em>
<span>-</span>AC[CESS_METHOD]=code <a class="indexterm" name="idm45807487488112"></a>
<a class="indexterm" name="idm45807487656112"></a>
</em></span>
</p>
<p>Specifies the access method or the GT.M buffering strategy for storing and retrieving data from the global database file. </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>code can have 2 values - Buffered Global (BG) or Memory Mapped (MM). The default value is BG. </p></li>
<li class="listitem">
<p>With BG, the global buffer pool manages the buffers (the OS/file system may also provide additional buffering). You get the choice of using BEFORE_IMAGE or NOBEFORE_IMAGE journaling for your database. <span>For details on the implications of these forms of Journaling, see <a class="xref" href="journaling.html" title="Chapter 6. GT.M Journaling">Chapter 6: &#8220;<i><span>GT.M </span>Journaling</i>&#8221;</a>.</span></p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>BG supports both forward and backward recovery and rollback to recover a database without a restore. <span>For more information forward and backward recovery and rollback, see <a class="xref" href="mupipchap.html" title="Chapter 5. General Database Management">Chapter 5: &#8220;<i>General Database Management</i>&#8221;</a>.</span> </p></li>
<li class="listitem" style="list-style-type: circle"><p>BG is a likely choice when you need faster recovery times from system failures.</p></li>
</ul></div>
</li>
<li class="listitem">
<p>With MM, GT.M bypasses the global buffer pool and relies entirely on the OS/file system to manage the data traffic between memory and disk. GT.M has no control over the timing of disk updates, therefore there is a greater reliance on the OS/file system for database performance.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>MM supports NOBEFORE_IMAGE journaling only. GT.M issues an error if you use MM with BEFORE_IMAGE Journaling. MM supports MUPIP JOURNAL -RECOVER -FORWARD and MUPIP JOURNAL -ROLLBACK -FORWARD. With MM, MUPIP JOURNAL -RECOVER -BACKWARD only generates lost and broken transaction files but cannot recover the database.
 </p></li>
<li class="listitem" style="list-style-type: circle"><p>Depending on your file system, MM may be an option when you need performance advantage in situations where the above restrictions are acceptable.</p></li>
</ul></div>
</li>
<li class="listitem"><p>GDE maintains a separate set of segment qualifier values for each ACCESS_METHOD. </p></li>
<li class="listitem"><p>When GDE modifies the ACCESS_METHOD, it activates the appropriate set of TEMPLATEs and sets all unspecified qualifiers to the default values of the new ACCESS_METHOD.</p></li>
</ul></div>
<p>Example: </p>
<a class="indexterm" name="idm45807487429264"></a><pre class="programlisting">GDE&gt; change -segment DEFAULT -access_method=MM </pre>
<p>This command sets MM as the access method or the GT.M buffering strategy for storing and retrieving database for segment DEFAULT.</p>
<p>
<span class="emphasis"><em>
<span>-</span>AL[LOCATION]=blocks<a class="indexterm" name="idm45807487462432"></a> 
</em></span> 
</p>
<p>Specifies the number of blocks GT.M allocates to a disk file when MUPIP creates the file. For GDS files, the number of bytes allocated is the size of the database file header plus the ALLOCATION size times the BLOCK_SIZE. </p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>The minimum ALLOCATION is 10 blocks. </p></li>
<li class="listitem" style="list-style-type: circle"><p>The maximum ALLOCATION is 1,040,187,392 blocks. </p></li>
<li class="listitem" style="list-style-type: circle"><p>By default, GDE uses an ALLOCATION of 100 blocks.</p></li>
<li class="listitem" style="list-style-type: circle"><p>The maximum size of a database file is 1,040,187,392(992Mi) blocks.</p></li>
<li class="listitem" style="list-style-type: circle"><p>The default ALLOCATION was chosen for initial development and experimentation with GT.M. Because file fragmentation impairs performance, make the initial allocation for production files and large projects large enough to hold the anticipated contents of the file for a length of time consistent with your UNIX file reorganization schedule.</p></li>
</ul></div>
<p>
<span class="emphasis"><em>
<span>-</span>-[NO]AS[YNCIO] <a class="indexterm" name="idm45807487557568"></a>
</em></span>
</p>
<p>Determines whether an access method BG database file uses asynchronous I/O rather than using synchronous I/O through the file system cache.</p>
<p>With ASYNCIO, GT.M assumes responsibility for writing database updates directly to secondary storage, essentially bypassing the file system and its cache. This can yield improved behavior if the file system has trouble handling GT.M database I/O, particularly file synchronization (fsync). ASYNCIO eliminates some memory activities and may improve performance in some configurations.</p>
<p>Some notes and observations:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>As asynchronous IO dispenses with the UNIX file buffer cache, GT.M global buffers are the sole caching mechanism. To make asynchronous IO perform well, you will likely need to increase the number of global buffers considerably. Assign adequate database global buffers to compensate for async I/O bypassing the file system cache. With GT.M's limit of 2GiB per shared memory segment, a database segment with 4KiB blocks has a limit of almost two million global buffers.  </p></li>
<li class="listitem"><p>
A large number of global buffers potentially implies a large number of dirty global buffers to be flushed at an epoch. You should investigate the impact on application response time of GT.M epoch tapering vs. turning off epoch tapering and using a separate stand-alone process that executes a line of code such as: <code class="code">for  set x="" for  set x=$view("gvnext",x) quit:""=x  view "dbflush":x,"dbsync":x,"epoch":x hang </code><span class="emphasis"><em>n</em></span> where <span class="emphasis"><em>n</em></span> is a number that causes each region to be flushed at an appropriate interval. If you choose this option, remember to turn off epoch tapering, and to set the epoch interval in the file header to be large enough to prevent application processes from performing epochs, and consider scripted timely switching of journal files by other than application processes (switching journal files involves an epoch).</p></li>
<li class="listitem"><p>On AIX, consider mounting file systems with the CIO mount option. The CIO mount option drops support for the file buffer cache (unused by asynchronous IO), and also eliminates a lock that is a potential bottleneck to GT.M performance on the AIX jfs2 filesystem.  </p></li>
<li class="listitem"><p>If a process encounters a situation where it needs to perform an asynchronous write, but has no available slots with which to manage an additional one, it either falls back to synchronous writing if the write is blocking other actions, and otherwise defers the write until a slot becomes available as other writes complete. Linux allocates the structures on a system-wide basis with the setting of /proc/sys/fs/aio-max-nr. FIS recommends setting /proc/sys/fs/aio-max-nr to 1048576.</p></li>
<li class="listitem"><p>For Linux x86_64, set the environment variable gtm_aio_nr_events: the gtm_aio_nr_events environment variable controls the number of structures a process has per global directory to manage asynchronous writes, and therefore determines the number of concurrent writes a process can manage across all regions within a global directory. If not specified, the value controlled by gtm_aio_nr_events defaults to 128. If a process encounters a situation where it needs to perform an asynchronous write, but has no available slots with which to manage an additional one, it either falls back to synchronous writing if the write is blocking other actions, and otherwise defers the write until a slot becomes available as other writes complete. The default value for gtm_aio_nr_events (that is, 128) should be sufficient for most applications. Change the value for the gtm_aio_nr_events environment variable based on benchmarking. </p></li>
<li class="listitem"><p>Monitor the number of database writes errors for each global directory with set x="" for set x=$view("gvnext",x) quit:""=x $$^%PEEKBYNAME("sgmnt_data.wcs_wterror_invoked_cntr",x). If there are database write errors, your application may benefit from altering the number of gtm_aio_nr_events. </p></li>
<li class="listitem"><p> While database write errors may indicate a problem with database writes if your storage system is starting to degrade, in a well-functioning environment, they indicate that a write attempt was unable to start an asynchronous write because it was unable to obtain a free resource of the type associated with /proc/sys/fs/aio-max-nr and gtm_aio_nr_events. In such a case, GT.M either defers the write in hopes that a resource will come available for a future attempt, or, if the write is blocking the application, GT.M performs a synchronous direct I/O. A synchronous direct I/O tends to lengthen response times and reduce throughput, so if you see non-trivial counts of such errors, you should revisit your settings for the resource.</p></li>
<li class="listitem"><p>Limited experience with solid-state storage (SSDs) on Linux in the GT.M development environment suggests a considerable difference in asynchronous IO performance on the same underlying hardware, with f2fs performing better than xfs, which in turn performed better than ext4.</p></li>
</ul></div>
<p>While there is reason to hope that ASYNCIO can provide better and more uniform performance, to this point we have limited information on performance comparisons, so FIS recommends well thought out benchmarking of your application in a suitable test environment. Please consider the above observations in this light.</p>
<p>By default GDE uses NOASYNCIO. On segments with an access method of MM, GT.M ignores this setting.</p>
<p>
<span class="emphasis"><em>
<span>-</span>BL[OCK_SIZE]=size <a class="indexterm" name="idm45807487489584"></a>
</em></span>
</p>
<p>Specifies the size, in bytes, of each database block in the file system. The BLOCK_SIZE
must be a multiple of 512. If the BLOCK_SIZE is not a
multiple of 512, GDE rounds up the BLOCK_SIZE to the next highest multiple of
512 and issues a warning message.</p>
<p>If the specified BLOCK_SIZE is less than the minimum, GDE uses the minimum
BLOCK_SIZE. If the specified BLOCK_SIZE is greater than the maximum, GDE issues
an error message.</p>
<p>A BLOCK_SIZE that is equal to the page size used by your UNIX implementation
serves well for most applications, and is a good starting point.</p>
<p>You should determine the block sizes for your application through performance
timing and benchmarking. In general, larger block sizes are more efficient from
the perspective of the input/output subsystem. However, larger block sizes use
more system resources (CPU and shared memory) and may increase collision and retry rates
for transaction processing.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>Global nodes that span blocks incur some overhead and optimum application performance is likely to be obtained from a BLOCK_SIZE that accommodates the majority of nodes within a single block. If you adjust the BLOCK_SIZE, you should also adjust GLOBAL_BUFFER_COUNT.</p></td></tr>
</table></div>
<p>GDE does not allow you to change the block size to an arbitrary number. It
always rounds the block size to the next higher multiple of 512, because the
database block size must always be a multiple of 512.</p>
<p>The minimum BLOCK_SIZE is 512 bytes.</p>
<p>The maximum BLOCK_SIZE is 65,024 bytes.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>FIS recommends against using databases with block sizes larger than 16KiB. If a specific global variable has records that have large record sizes, FIS recommends placing that global variable in a file by itself with large block sizes and using more appropriate block sizes for other global variables. 4KiB and 8KiB are popular database block sizes.</p></td></tr>
</table></div>
<p>By default, GDE uses a BLOCK_SIZE of 4096 bytes.</p>
<p>
<span class="emphasis"><em>
<span>-</span>-[NO]DEFER_ALLOCATE <a class="indexterm" name="idm45807487429136"></a>
</em></span>
</p>
<p>With -DEFER_ALLOCATE, GT.M instructs the file system to create the database file as a sparse file. Before using -DEFER_ALLOCATE, ensure that your underlying file system supports sparse files. By default UNIX file systems, and GT.M, use sparse (or lazy) allocation, which defers actual allocation until blocks are first written.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Utilities such as du report typically show lower disk space usage for a database file with -DEFER_ALLOCATE because GT.M instructs the file system to defer disk space allocation to the time when there is an actual need. With -NODEFER_ALLOCATE, such utilities report higher disk space usage count as GT.M instructs the file system to preallocate disk space without waiting for a need to arise.</p></li>
<li class="listitem"><p>-DEFER_ALLOCATE makes database file extensions lighter weight. However, disk activity may tend towards causing fragmentation.</p></li>
<li class="listitem"><p> To switch an existing database file so it immediately preallocates all blocks, first use MUPIP SET -NODEFER_ALLOCATE to set the switch in the database file header, followed by <code class="code">MUPIP EXTEND -BLOCKS=n</code>, where <code class="code">n &gt;= 0</code>. Failures to preallocate space produce a PREALLOCATEFAIL error.</p></li>
<li class="listitem"><p>The default is DEFER_ALLOCATE. </p></li>
</ul></div>
<p>
   <span class="emphasis"><em><span>-</span>[NO]ENcryption </em></span><a class="indexterm" name="idm45807487618960"></a>
</p>
<p>Specifies whether or not the database file for a segment is flagged for encryption. Note that MUPIP CREATE acquires an encryption key for this file and puts a cryptographic hash of the key in the database file header. </p>
<p>
<span class="emphasis"><em>
<span>-</span>EX[TENSION_COUNT]=blocks <a class="indexterm" name="idm45807487399888"></a>
</em></span>
</p>
<p>Specifies the number of extra GDS blocks of disk space by which the file
should extend. The extend amount is interpreted as the number of usable GDS
blocks to create with the extension. To calculate the number of host operating
system blocks added with each extension, multiply the number of GDS blocks
by (GDS BLOCK_SIZE/host BLOCK_SIZE); add one local bitmap block for each 512
blocks added in each extension to the amount from step 1. If the extension is
not a multiple of 512, remember to roundup when figuring the number of bitmap
blocks.</p>
<p>When a MUPIP EXTEND command does not include a <span>-</span>BLOCKS= qualifier, EXTEND uses the
extension size in the database header.</p>
<p>The extension amount may be changed with the MUPIP SET command. </p>
<p>The minimum EXTENSION is zero blocks.</p>
<p>When a database file with automatic extension disabled (EXTENSION_COUNT=0) starts to get full, GT.M records the FREEBLSLOW warning in the system log. So as to not compromise performance, GT.M checks whenever the master bit map must be updated to show that a local bit map is full, and issues the warning if there are fewer than 512 free blocks or if the number of free blocks is less than total blocks/32. This means that for databases whose size is 512 blocks or less the warning comes at the last successful update before the database becomes full.</p>
<p>The maximum EXTENSION is 1,048,575 blocks.</p>
<p>By default, GDE uses an EXTENSION of 100 blocks.</p>
<p>Like allocation, the default extension amount was chosen for initial
development and experimentation. Use larger extensions for
larger actual applications. Because multiple file extensions adversely affect performance, set
up extensions appropriate to the file allocation.</p>
<p>
   <span class="emphasis"><em><span>-</span>F[ILE_NAME]=<span>file-name</span> </em></span><a class="indexterm" name="idm45807487392704"></a>
</p>
<p>Specifies the file for a segment. </p>
<p>The maximum file name length is 255 characters. </p>
<p>By default, GDE uses a file-name of mumps followed by the default extension, which is .dat. You can specify any filename and extension of your choice for a database file as long as it is valid on your operating system. </p>
<a class="indexterm" name="idm45807487408016"></a><p>
<span class="emphasis"><em>
-FU[LLBLKWRT]={0|1|2}<a class="indexterm" name="idm45807487390464"></a>
<a class="indexterm" name="idm45807487383600"></a>
</em></span>
</p>
<p>Determines whether GT.M writes only valid database blocks contents, or a full block including meaningless trailing content. Full block writes are more efficient with some secondary storage because they avoid read-before-write. </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>When -FULLBLKWRT=2, a process writes all newly allocated database blocks in their entirety regardless of their actual valid contents. This relieves some file systems from tracking as much unallocated space and thus reduces file system metadata maintenance.</p></li>
<li class="listitem"><p>When -FULLBLKWRT=1, a process writes entire file system blocks in their entirety regardless of their actual valid contents, on some file systems, this avoids reading in advance of most writes and thus reduces file system load and increases response time. </p></li>
<li class="listitem"><p>When -FULLBLKWRT=0 (the default), a process writes only valid data. FIS advises using the same value of -FULLBLKWRT for all processes.</p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>When the file system block size and the database block size are the same there is no difference between the settings of 1 and 2. </p></td></tr>
</table></div>
<p>
<span class="emphasis"><em>
<span>-</span>G[LOBAL_BUFFER_COUNT]=size  <a class="indexterm" name="idm45807487381120"></a>
</em></span>
</p>
<p>Specifies the number of global buffers for a file. Global buffers reside in shared memory and are part of the database caching mechanisms. Global buffers do not apply to MM databases.<a class="indexterm" name="idm45807487396176"></a></p>
<p>Choose the settings for this qualifier carefully. Small numbers of global buffers tend to throttle database performance. However, if your system has limited memory and the database file traffic is not heavy enough to hold the cache in RAM, increasing GLOBAL_BUFFER_COUNT may trigger  paging. </p>
<p>If database global buffers are paged out, it will result in poor performance. Therefore, do not increase this factor to a large value without careful observation.</p>
<p>The proper number of GLOBAL_BUFFERs depends on the application and the amount of primary memory available on the system. Most production databases exhibit a direct relationship between the number of GLOBAL_BUFFERs and performance. However, the relationship is not linear, but asymptotic, so that increases past some point have progressively less benefit. This point of diminishing returns
depends on the application. For most applications, FIS expects the optimum number of GLOBAL_BUFFERs to be between 1K and 64K. </p>
<p>Because transaction processing can be involved in an update and a transaction is limited to half the GLOBAL_BUFFER_COUNT, the value for GLOBAL_BUFFER_COUNT should therefore be at least 32 plus twice the number of the blocks required by the largest global variable node in your application.</p>
<p>Generally, you should increase the number of GLOBAL_BUFFERs for production GDS
database files. This is because GT.M uses the shared memory database cache associated
with each GDS file for the majority of caching. </p>
<p>The minimum GLOBAL_BUFFER_COUNT for BG is 64 blocks. </p>
<p>The maximum for GLOBAL_BUFFER_COUNT for BG is 2,097,151 blocks, but may vary depending on your platform. </p>
<p>By default, GDE uses a GLOBAL_BUFFER_COUNT that is appropriate for initial development use on each platform, but probably too small for production applications.  </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>If global buffers are "paged out," improvements in system performance resulting from more global buffers will be more than offset by the dramatic slowdown that results from globals buffers that are "paged out."</p>
<p>Out of the requested allocation, GT.M always reserves 32 global buffers for BG access method for read-only use to ensure that non-dirty global buffers are always available.</p>
</td></tr>
</table></div>
<p>
<span class="emphasis"><em>
<span>-</span>L[OCK_SPACE]=<span>integer</span><a class="indexterm" name="idm45807487373664"></a>
</em></span>
</p>
<p>Specifies the number of pages of space to use for the lock database stored with this segment. The size of a page is always 512 bytes. </p>
<p>As GT.M runs out of space to store LOCK control information, LOCKs become progressively less efficient. If a single process consumes all the LOCK space, it cannot continue, and any other processes cannot proceed using LOCKs.</p>
<p>The minimum LOCK_SPACE is 10 pages.</p>
<p>The maximum LOCK_SPACE is 262,144 pages.</p>
<p>By default, GDE uses a LOCK_SPACE of 40 pages.</p>
<p>LOCK_SPACE usage depends on the number of locks and the number of processes waiting for locks. To estimate lock space needs, here is a rule of thumb:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>1.5KiB overhead for the lock space, plus</p></li>
<li class="listitem"><p>640 bytes for each lock base name, plus</p></li>
<li class="listitem"><p>128 bytes for each subscript, plus</p></li>
<li class="listitem"><p>128 bytes for each waiting process.</p></li>
</ul></div>
<p>Generally, you would limit LOCK_SPACE only when memory is scarce or you want to be made aware of unexpected levels of LOCK usage. For most other cases, there is no reason to limit the LOCK_SPACE. If you are introducing new code, FIS recommends using TSTART and TCOMMIT as a more efficient alternate for most LOCKs because it pushes the responsibility for Isolation onto GT.M, which internally manages them with optimistic algorithms.</p>
<p>
<span class="emphasis"><em>
<span>-</span>M[UTEX_SLOTS]=<span>integer</span><a class="indexterm" name="idm45807487371744"></a>
</em></span></p>
<p>Specifies the number of mutex slots for a database file. GT.M uses mutex slots to manage database contention. FIS recommends you configure the slots to cover the maximum number of processes you expect to concurrently access the database file, as an insufficient number of slots can lead to much steeper and more severe degradation of performance under heavy loads. The minimum is 1Ki and the maximum is 32Ki.  </p>
<p>
<span class="emphasis"><em><a class="indexterm" name="idm45807487482336"></a>
<span>-</span>R[ESERVED_BYTES]=size 
</em></span>
</p>
<p>Specifies the size for GT.M to reserve in each database block. RESERVED_BYTES is
generally used to reserve room for compatibility with other implementations of M
or to observe communications protocol restrictions. RESERVED_BYTES may also be
used as a user-managed fill factor. GDE -RESERVED_BYTES controls both index and
data reserved bytes.</p>
<p>The minimum RESERVED_BYTES is zero bytes.</p>
<p>The maximum Reserved_Bytes = Block Size - Key Size - 40(block/record header overheads) </p>
<p>By default, GDE uses a RESERVED_BYTES size of zero bytes.</p>
<p><span class="emphasis"><em>Summary</em></span></p>
<p>The following table summarizes GDE segment qualifiers. It provides
abbreviations, defaults (as provided by FIS), and
allowable minimum and maximum values.</p>
<div class="informaltable">
<a name="tblgdesegqual"></a><table width="100%" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="4">
<p>GDE SEGMENT Qualifiers</p>
</th></tr>
<tr>
<th>
<p>QUALIFIER</p>
</th>
<th>
<p>DEFAULT</p>
</th>
<th>
<p>MIN</p>
</th>
<th>
<p>MAX</p>
</th>
</tr>
</thead>
<tfoot><tr><th colspan="4">
<p>* May vary by platform</p>
</th></tr></tfoot>
<tbody>
<tr>
<td>
               <p>-AC[CESS_METHOD]=BG|MM </p>
            </td>
<td>
               <p>BG </p>
            </td>
<td>
               <p>- </p>
            </td>
<td>
               <p>- </p>
            </td>
</tr>
<tr>
<td>
               <p>-AL[LOCATION]=size (blocks) </p>
            </td>
<td>
               <p>100 </p>
            </td>
<td>
               <p>10</p>
            </td>
<td>
               <p>1,040,187,392(992Mi)</p>
            </td>
</tr>
<tr>
<td>
               <p>-[NO]AS[YNCIO] </p>
            </td>
<td>
               <p>FALSE</p>
            </td>
<td>
               <p>-</p>
            </td>
<td>
               <p>-</p>
            </td>
</tr>
<tr>
<td>
               <p>-BL[OCK_SIZE]=size (bytes) </p>
            </td>
<td>
               <p>1,024 </p>
            </td>
<td>
               <p>512 </p>
            </td>
<td>
               <p>65,024 </p>
            </td>
</tr>
<tr>
<td>
               <p>-[NO]DEFER_[ALLOCATE] </p>
            </td>
<td>
               <p>TRUE</p>
            </td>
<td>
               <p>-</p>
            </td>
<td>
               <p>-</p>
            </td>
</tr>
<tr>
<td>
               <p>-[NO]E[NCRYPTION] </p>
            </td>
<td>
               <p>FALSE</p>
            </td>
<td>
              <p>-</p>
            </td>
<td>
               <p>-</p>
            </td>
</tr>
<tr>
<td>
               <p>-EX[TENSION_COUNT]=size (blocks) </p>
            </td>
<td>
               <p>100 </p>
            </td>
<td>
               <p>0 </p>
            </td>
<td>
               <p>1,048,575</p>
            </td>
</tr>
<tr>
<td>
               <p>-F[ILE_NAME]=file-name (chars) </p>
            </td>
<td>
               <p>mumps.dat </p>
            </td>
<td>
               <p>- </p>
            </td>
<td>
               <p>255 </p>
            </td>
</tr>
<tr>
<td>
               <p>-FU[LLBLKWRT]={0|1|2} </p>
            </td>
<td>
               <p>0 </p>
            </td>
<td>
               <p>0 </p>
            </td>
<td>
               <p>2 </p>
            </td>
</tr>
<tr>
<td>
               <p>-G[LOBAL_BUFFER_COUNT]=size (blocks) </p>
            </td>
<td>
               <p>1024 </p>
            </td>
<td>
               <p>64 </p>
            </td>
<td>
               <p>2,097,151*</p>
            </td>
</tr>
<tr>
<td>
               <p>-L[OCK_SPACE]=size (pages) </p>
            </td>
<td>
               <p>40 </p>
            </td>
<td>
               <p>10 </p>
            </td>
<td>
               <p>262,144</p>
            </td>
</tr>
<tr>
<td>
               <p>-M[UTEX_SLOTS]=integer </p>
            </td>
<td>
               <p>1,024 </p>
            </td>
<td>
               <p>64 </p>
            </td>
<td>
               <p>32,768</p>
            </td>
</tr>
<tr>
<td>
               <p>-R[ESERVED_BYTES]=size (bytes) </p>
            </td>
<td>
               <p>0 </p>
            </td>
<td>
               <p>0 </p>
            </td>
<td>
               <p>Block Size - Key Size - 32 </p>
            </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="gblname_qual"></a>Gblname Qualifiers<a class="indexterm" name="idm45807487335424"></a>
</h3></div></div></div>
<p>The following <span>-</span>GBLNAME qualifier can be used with the ADD, CHANGE, or TEMPLATE commands.</p>
<p>
<span class="emphasis"><em>
<span>-</span>C[OLLATION]=collation_number <a class="indexterm" name="idm45807487352320"></a>
</em></span>
</p>
<p>Specifies the collation number for a global name; a value of 0 specifies standard M collation.  The first time that a GT.M processes accesses a global variable name in a database file, it determines the collation sequence as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>If a Global Variable Tree (GVT) exists (that is, global variable nodes exist, or have previously existed, even if they have been KILL'd), use the existing collation:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem"><p>If there is a collation specified in the Directory Tree (DT) for that variable, use it after confirming that this matches the collation in the global directory.</p></li>
<li class="listitem">
<p>else (that is, there is no collation specified in the DT): </p>
<div class="itemizedlist"><ul class="itemizedlist" type="square">
<li class="listitem"><p>If there is collation specified for that global variable in the global directory use it</p></li>
<li class="listitem"><p>else if there is a default for that database file, use it</p></li>
<li class="listitem"><p>else (that is, neither exists), use standard M collation</p></li>
</ul></div>
</li>
</ul></div>
</li>
<li class="listitem">
<p>else (that is, a GVT does not exist, which in turn means there is no DT):</p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem"><p>If there is collation specified for that global variable in the global directory use it</p></li>
<li class="listitem"><p>else, if there is a default for that database file, use it</p></li>
<li class="listitem"><p>else (that is, neither exists), use standard M collation</p></li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="instance_qual"></a>Instance Qualifier<a class="indexterm" name="idm45807487284384"></a>
</h3></div></div></div>
<p>The following <span>-</span>INSTANCE qualifier is used with the CHANGE command.</p>
<p>
<span class="emphasis"><em>
<span>-</span>F[ILE_NAME=[repl_inst_filename|""] <a class="indexterm" name="idm45807487276160"></a>
</em></span>
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>-FILE_NAME=repl_inst_filename maps a replication instance file with the global directory. -FILE_NAME="" removes the mapping of a global directory with a replication instance file. </p></li>
<li class="listitem"><p>When a global directory is use, the mapping set with CHANGE -INSTANCE FILE_NAME=repl_inst_filename overrides any setting of the gtm_repl_instance environment variable. However, other utilities (MUPIP, LKE, and DSE) use the setting of the gtm_repl_instance environment variable. </p></li>
</ul></div>
<p>For more information, refer to <a class="xref" href="ch07s01.html#repl_gesz" title="Instance Bound Global Directories">&#8220;Instance Bound Global Directories &#8221;</a>. </p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="gdecmds.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="gdechap.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="gde_cmmd_summ.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">
<span>Global Director Editor </span>Commands </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> <span>GDE Command </span>Summary</td>
</tr>
</table>
</div>
</body>
</html>
