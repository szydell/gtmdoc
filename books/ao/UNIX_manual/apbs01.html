<html>
<HEAD><META HTTP-EQUIV="Pragma" CONTENT="no-cache"><META HTTP-EQUIV="Expires" CONTENT="-1">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Monitoring GT.M Messages</title>
<link rel="stylesheet" href="gtm.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="GT.M Administration and Operations Guide">
<link rel="up" href="monitoring_gtm.html" title="Appendix B. Monitoring GT.M">
<link rel="prev" href="monitoring_gtm.html" title="Appendix B. Monitoring GT.M">
<link rel="next" href="apbs02.html" title="Managing core dumps">
<link rel="copyright" href="ln-idp160089856.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Monitoring GT.M Messages</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="monitoring_gtm.html">Prev</a> </td>
<th width="60%" align="center">Appendix B. Monitoring GT.M </th>
<td width="20%" align="right"> <a accesskey="n" href="apbs02.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">GT.M Administration and Operations Guide</a></span> &gt; <span class="breadcrumb-link"><a href="monitoring_gtm.html">Monitoring GT.M </a></span> &gt; <span class="breadcrumb-node">Monitoring GT.M Messages</span>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="GTM_Monitoring"></a>Monitoring GT.M Messages<a class="indexterm" name="idp170668928"></a>
</h2></div></div></div>
<p>This section covers information on monitoring GT.M messages. There are several types of messages.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>The GT.M run-time system sends messages (such as when a database file extends) to the system log. These are not trapped by the application error trap.</p></li>
<li class="listitem"><p>Compilation errors generated by GT.M are directed to STDERR. These are not trapped by the application error trap. You can avoid them by compiling application code before deploying it in production, or log them by running GT.M processes with STDERR directed to a file.</p></li>
<li class="listitem"><p>Errors trapped by the application and logged by the application. These are outside the purview of this discussion.</p></li>
</ul></div>
<p>A system management tool will help you automate monitoring messages.</p>
<p>GT.M sends messages to the system log at the LOG_INFO level of the LOG_USER facility. GT.M messages are identified by a signature of the form <code class="code">GTM-</code><em class="replaceable"><code>s</code></em><code class="code">-abcdef</code> where <em class="replaceable"><code>-s-</code></em> is a severity indicator and <code class="code">abcdef</code> is an identifier. The severity indicators are: <em class="replaceable"><code>-I-</code></em> for informational messages, <em class="replaceable"><code>-W-</code></em> for warnings, <em class="replaceable"><code>-E-</code></em> for errors and <em class="replaceable"><code>-F-</code></em> for events that cause a GT.M process to terminate abnormally. Your monitoring should recognize the important events in real time, and the warning events within an appropriate time. All messages have diagnostic value. It is important to create a baseline pattern of messages as a <span class="emphasis"><em>signature</em></span> of normal operation of your system so that a deviation from this baseline - the presence of unexpected messages, an usual number of expected messages (such as file extension) or the absence of expected messages - allows you to recognize abnormal behavior when it happens. In addition to responding to important events in real time, you should regularly review information and warning messages and ensure that deviations from the baseline can be explained.
</p>
<p>Some message identifiers are described in the following table:</p>
<div class="informaltable"><table border="1" width="75%">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th><p>Component</p></th>
<th><p>Instance File 
or Replication 
Journal Pool</p></th>
<th>
<p>Receiver Pool</p> </th>
<th><p>Identifier</p></th>
</tr></thead>
<tbody>
<tr>
<td rowspan="2" valign="middle"><p>Source Server</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>SRCSRVR</p></td>
</tr>
<tr>
<td><p>N</p></td>
<td><p>N/A</p></td>
<td><p>MUPIP</p></td>
</tr>
<tr>
<td rowspan="2" valign="middle"><p>Receiver Server</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>RCVSRVR</p></td>
</tr>
<tr>
<td><p>N</p></td>
<td><p>N/A</p></td>
<td><p>MUPIP</p></td>
</tr>
<tr>
<td rowspan="2" valign="middle"><p>Update Process</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>UPD</p></td>
</tr>
<tr>
<td><p>N</p></td>
<td><p>N/A</p></td>
<td><p>MUPIP</p></td>
</tr>
<tr>
<td rowspan="2" valign="middle"><p>Reader Helper</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>UPDREAD</p></td>
</tr>
<tr>
<td><p>N/A</p></td>
<td><p>N</p></td>
<td><p>UPDHELP</p></td>
</tr>
<tr>
<td rowspan="2" valign="middle"><p>Writer Helper</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>UPDWRITE</p></td>
</tr>
<tr>
<td><p>N/A</p></td>
<td><p>N</p></td>
<td><p>UPDHELP</p></td>
</tr>
</tbody>
</table></div>
<a class="indexterm" name="idp170730768"></a><p>In addition to messages in the system log, and apart from database files and files created by application programs, GT.M creates several types of files: journal files, replication log files, gtmsecshr log files, inter-process communication socket files, files from recovery / rollback and output and error files from JOB'd processes. You should develop a review and retention policy. Journal files and files from recovery / rollback are likely to contain sensitive information that may require special handling to meet business or legal requirements. Monitor all of these files for growth in file numbers or size that is materially different than expectations set by the baseline. In particular, monitoring file sizes is computationally inexpensive and regular monitoring - once an hour, for example - is easily accomplished with the system crontab.</p>
<p>While journal files automatically switch to new files when the limit is reached, log files can grow unchecked. You should periodically check the sizes of log files and switch them when they get large - or simply switch them on a regular schedule.</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p><code class="code">gtmsecshr</code> log file - <code class="code">gtm_secshr_log</code> in the directory <code class="code">$gtm_log</code> (send a SIGHUP to the <code class="code">gtmsecshr</code> process to create a new log file).</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Important">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Important]" src="images/important.jpg"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>Starting with V6.0-000, GT.M logs gtmsecshr messages in the system log and ignores the environment variable gtm_log. </p></td></tr>
</table></div>
</li>
<li class="listitem"><p>Source Server, Receive Server, and Update Process log files. For more information, refer to <a class="xref" href="replication.html#chng_log_file" title="Changing the Log File">Section : &#8220;<span>Changing the Log File</span>&#8221;</a> in the Database Replication chapter.</p></li>
</ol></div>
<p>Since database health is critical, database growth warrants special attention. Ensure every file system holding a database file has sufficient space to handle the anticipated growth of the files it holds. Remember that with the lazy allocation used by UNIX file systems, all files in a system complete for its space. GT.M issues an informational message each time it extends a database file. When extending a file, it also issues a warning if the remaining space is less than three times the extension size. You can use the $VIEW() function to find out the total number of blocks in a database as well as the number of free blocks.</p>
<p>As journal files grow with every update they use up disk faster than database files do. GT.M issues messages when a journal file reaches within three, two and one extension size number of blocks from the automatic journal file switch limit. GT.M also issues messages when a journal file reaches its specified maximum size, at which time GT.M closes it, renames it and creates a new journal file. Journal files covering time periods prior to the last database backup (or prior to the backup of replicating secondary instances) are not needed for continuity of business, and can be deleted or archived, depending on your retention policy. Check the amount of free space in file systems at least hourly and perhaps more often, especially file systems used for journaling, and take action if it falls below a threshold.</p>
<p>GT.M uses monotonically increasing relative time stamps called transaction numbers. You can monitor growth in the database transaction number with DSE DUMP -FILEHEADER. Investigate and obtain satisfactory explanations for deviations from the baseline rate of growth.</p>
<p>After a MUPIP JOURNAL -ROLLBACK (non replicated application configuration) or MUPIP JOURNAL -RECOVER -FETCHRESYNC (replicated application configuration), you should review and process or reconcile updates in the broken and unreplicated (lost) transaction files.</p>
<p>In a replicated environment, frequently (at least hourly; more often suggested since it takes virtually no system resources), check the state of replication and the backlog with MUPIP REPLICATE -CHECKHEALTH and -SHOWBACKLOG. Establish a baseline for the backlog, and take action if the backlog exceeds a threshold.</p>
<p>When a GT.M process terminates abnormally, it attempts to create a <code class="code">GTM_FATAL_ERROR.ZSHOW_DMP_*.txt </code>file containing a dump of the M execution context and a core file containing a dump of the native process execution context. The M execution context dump is created in the current working directory of the process. Your operating system may offer a means to control the naming and placement of core files; by default they are created the current working directory of the process with a name of core.*. The process context information may be useful to you in understanding the circumstances under which the problem occurred and/or how to deal with the consequences of the failure on the application state. The core files are likely to be useful primarily to your GT.M support channel. If you experience process failures but do not find the expected files, check file permissions and quotas. You can simulate an abnormal process termination by sending the process a SIGILL (with <code class="code">kill -ILL</code> or <code class="code">kill -4</code> on most UNIX/Linux systems).</p>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution: Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Caution]" src="images/caution.jpg"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>Dumps of process state files are likely to contain confidential information, including database encryption keys. Please ensure that you have appropriate confidentiality procedures as mandated by applicable law and corporate policy.</p></td></tr>
</table></div>
<p>GT.M processes issued with the JOB command create .mje and .mjo files for their STDERR and STDOUT respectively. Analyze non-empty .mje files. Design your application and/or operational processes to remove or archive .mjo files once they are no longer needed.</p>
<p>Use the environment variable gtm_procstuckexec to trigger monitoring for processes holding a resource for an unexpectedly long time. $gtm_procstuckexec specifies a shell command or a script to execute when any of the following conditions occur:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>An explicit MUPIP FREEZE or an implicit freeze, such as for a BACKUP or INTEG -ONLINE that lasts longer than one minute.</p></li>
<li class="listitem"><p>MUPIP actions find kill_in_prog (KILLs in progress) to be non-zero after a one minute wait on a region.</p></li>
<li class="listitem"><p>BUFOWNERSTUCK, INTERLOCK_FAIL, JNLPROCSTUCK, SHUTDOWN, WRITERSTUCK, MAXJNLQIOLOCKWAIT, MUTEXLCKALERT, SEMWT2LONG, and COMMITWAITPID operator messages are being logged.</p></li>
</ul></div>
<p>The shell script or command pointed to by gtm_procstuckexec can send an alert, take corrective actions, and log information.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>Make sure user processes have sufficient space and permissions to run the shell command / script. For example for the script to invoke the debugger, the process must be of the same group or have a way to elevate privileges.</p></td></tr>
</table></div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="monitoring_gtm.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="monitoring_gtm.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="apbs02.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Appendix B. Monitoring GT.M  </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Managing core dumps </td>
</tr>
</table>
</div>
</body>
</html>
