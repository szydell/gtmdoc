<html>
<HEAD><META HTTP-EQUIV="Pragma" CONTENT="no-cache"><META HTTP-EQUIV="Expires" CONTENT="-1">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Commands and Qualifiers</title>
<link rel="stylesheet" href="gtm.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="GT.M Administration and Operations Guide">
<link rel="up" href="ch07.html" title="Chapter 7. Database Replication">
<link rel="prev" href="ch07s03.html" title="Procedures">
<link rel="next" href="lkechap.html" title="Chapter 8. M Lock Utility (LKE)">
<link rel="copyright" href="ln-idm46171623595264.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Commands and Qualifiers</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch07s03.html">Prev</a> </td>
<th width="60%" align="center">Chapter 7. Database Replication</th>
<td width="20%" align="right"> <a accesskey="n" href="lkechap.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">GT.M Administration and Operations Guide</a></span> &gt; <span class="breadcrumb-link"><a href="ch07.html">Database Replication</a></span> &gt; <span class="breadcrumb-node">Commands and Qualifiers</span>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="repl_commands_qualifiers"></a><span>Commands and Qualifiers<a class="indexterm" name="idm46171617970848"></a></span>
</h2></div></div></div>
<p>The following MUPIP commands and qualifiers control database replication in a GT.M
environment.</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="trng_repl_on_off"></a><span>Turning Replication On/Off</span><a class="indexterm" name="idm46171618704032"></a>
</h3></div></div></div>
<p>Command Syntax:</p>
<a class="indexterm" name="idm46171617898048"></a><pre class="programlisting">mupip set {<span>-</span>file db-file|<span>-</span>region reg-list} <span>-</span>replication={ON|OFF}</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em><a class="indexterm" name="idm46171617893408"></a>
<a class="indexterm" name="idm46171617886160"></a>
<span>-file and -region</span>

</em></span>
</p>
<p>Use these qualifiers in the same manner that you would use them for a MUPIP SET. <span>For more information refer to <a class="xref" href="mupipchap.html" title="Chapter 5. General Database Management">Chapter 5: &#8220;<i>General Database Management</i>&#8221;</a>.</span></p>
<p><a class="indexterm" name="idm46171617899888"></a>
<span class="emphasis"><em>
<span>-replication=<em class="replaceable"><code>replication-state</code></em></span>

</em></span>
</p>
<p>Switches the GT.M replication subsystem ON/OFF and possibly modify the current journaling [no-]before image field (which is stored in the database file header).</p>
<a class="indexterm" name="idm46171617909680"></a><p><em class="replaceable"><code>replication-state</code></em> is either of the following keywords:</p>
<p>
<span class="emphasis"><em>OFF</em></span>
</p>
<p>Disable replication of the database file(s) or region(s). Even if you turn off replication, journaling continues to operate as before.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Important">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Important]" src="images/important.jpg"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>GT.M creates a new set of journal files and cuts the back link to the previous journal files if the replication-state is OFF and then turned ON again. The database cannot rollback to a state prior to ON. Therefore, ensure that replication-state remains ON throughout the span of database replication. Turn replication-state OFF only if database replication is no longer needed or the instance is about to be refreshed from the backup of the originating instance.</p></td></tr>
</table></div>
<p>
<a class="indexterm" name="idm46171617877408"></a>
<span class="emphasis"><em>ON</em></span>
</p>
<p>Enables replication for the selected database file(s) or region(s). When the JOURNAL qualifier is not specified, this action turns BEFORE_IMAGE journaling on. Specify -JOURNAL=NOBEFORE_IMAGE to enable replication with no-before-image journaling. In both cases, GT.M creates a new journal file for each database file or region, and switches the current journal file. FIS recommends you to specify the desired journaling characteristics (MUPIP SET -JOURNAL=BEFORE_IMAGE or MUPIP SET -JOURNAL=NOBEFORE_IMAGE).</p>
<p>When replication is ON, a MUPIP SET REPLICATION=ON command with no JOURNAL qualifier assumes the current journaling characteristics (which are stored in the database file header). By default GT.M sets journal operation to BEFORE_IMAGE if this command changes the replication state from OFF to ON and JOURNAL=NOBEFORE_IMAGE is not specified. Therefore, conservative scripting should always specify the desired journaling characteristics using the JOURNAL qualifier of the MUPIP SET command.</p>
<p>The replication state ON in the file header denotes normal replication operation.</p>
<p>
<a class="indexterm" name="idm46171617873936"></a>
<span class="emphasis"><em>[WAS_ON] OFF</em></span>
</p>
<p>Denotes an implicit replication state when GT.M attempts to keep replication working even if run-time conditions such as no available disk space or no authorization for a process attempting to auto-switch a journal file cause GT.M to turn journaling off. Even with journaling turned off, the Source Server attempts to continue replication using the records available in the replication journal pool. In this state, replication can only continue as long as all the information it needs is in the replication journal pool. Events such as an operationally significant change on the replicating instance(s) or communication problems are likely to cause the Source Server to need information older than that in the replication journal pool and because it cannot look for that information in journal files, at that point the Source Server shuts down.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>If the replication ON state is like a bicycle running smoothly on the road, replication WAS_ON is like a bicycle with a flat front tire being ridden like a unicycle - the system is operating outside its intended mode of use and is more subject to misfortune.</p></td></tr>
</table></div>
<p>WAS_ON is an implicit replication state. At all times during the WAS_ON state, you can see the current backlog of transactions and the content of the Journal Pool (MUPIP REPLICATE -SOURCE -SHOWBACKLOG and MUPIP REPLICATE -SOURCE -JNLPOOL -SHOW). This information is not available in the replication OFF state.</p>
<p>For more information on recovering originating and replicating instances from WAS_ON, refer to <a class="xref" href="ch07s03.html#recwason" title="Recovering from the replication WAS_ON state">Recovering from the replication WAS_ON state </a>.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip set -replication=on -file mumps.dat</pre>
<p>This example enables database replication and turns before-image journaling on for mumps.dat.</p>
<pre class="programlisting">$ mupip set -replication=on -journal=nobefore_image -file mumps.dat</pre>
<p>This example enables database replication and turns no-before-image journaling on for mumps.dat.</p>
<pre class="programlisting">$ mupip set -replication=off -file mumps.dat</pre>
<p>This example turns off database replication for mumps.dat. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="create_repl_inst"></a><span>Creating the Replication Instance File</span>
</h3></div></div></div>
<p>Command Syntax:<a class="indexterm" name="idm46171617925344"></a>
<a class="indexterm" name="idm46171617863600"></a></p>
<pre class="programlisting">mupip replicate -instance_create -name=&lt;instance name&gt; [-noreplace] [-supplementary] [-noqdbrundown] </pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>-instance_create</em></span>
</p>
<p>Creates a replication instance file. mupip replicate -instance_create takes the file name of the replication instance file from the environment variable gtm_repl_instance.</p>
<p>If an instance file already exists, GT.M renames it with a timestamp suffix, and creates a new replication instance file. This behavior is similar to the manner in which GT.M renames existing journal files while creating new journal files. Creating an instance file requires standalone access.</p>
<a class="indexterm" name="idm46171617860496"></a><p>
<span class="emphasis"><em>-name</em></span>
</p>
<p>Specifies the instance name that uniquely identifies the instance and is immutable. The instance name can be from 1 to 16 characters. GT.M takes the instance name (not the same as instance file name) from the environment variable gtm_repl_instname. If either gtm_repl_instname is not set or -name is not specified, GT.M produces an error. <span>For more information, refer to the entries for gtm_repl_instname and gtm_repl_instance in <a class="xref" href="ch03s02.html" title="Environment Variables">&#8220;Environment Variables&#8221;</a>.</span></p>
<p>
<a class="indexterm" name="idm46171617855760"></a>
<a class="indexterm" name="idm46171617854752"></a>
<span class="emphasis"><em>-noreplace</em></span>
</p>
<p>Prevents the renaming of an existing replication instance file. </p>
<p>
<a class="indexterm" name="idm46171617852720"></a>
 <span class="emphasis"><em>-supplementary</em></span></p>
<p>Specifies that the replication instance file is suitable for use in a supplementary instance.</p>
<p>
<a class="indexterm" name="idm46171617850816"></a>
 <span class="emphasis"><em>-noqdbrundown</em></span></p>
<p>Permits more than 32,767 udpating processes to concurrently the replication instance file and database file(s). The default (-noqdbrundown) permits up to 32,767 concurrent updating processes to access a database file or a replication instance file. </p>
<p>This permission is effected by the QDBRUNDOWN flags in database file headers and in replication instance files. When an open database file or replication instance file with QDBRUNDOWN set is first concurrently accessed by more than 32,767 processes, GT.M:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>logs a NOMORESEMCNT message in the system log, and </p></li>
<li class="listitem"><p>stops counting the number of attached processes. This means that GT.M cannot recognize when the number of attached processes reaches zero (0) in order to release the corresponding shared resources, and therefore requires explicit manual clean up of resources for an orderly shutdown. </p></li>
</ol></div>
<p>Except in application configurations that require it, FIS recommends not setting QDBRUNDOWN. Not setting QDBRUNDOWN allows GT.M to clean up resources, instead of putting the burden on the operational procedures. Where GT.M cannot perform an orderly shutdown, an explicit, clean shutdown must be performed as follows:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>Replicated instances require a mupip journal -rollback -backward "*" executed after the mupip replicate -source -shutdown command (remember that even instances receiving a replication stream have one or more Source Servers).</p></li>
<li class="listitem"><p>Database files that are journaled but not part of a replication instance require a mupip journal -recover -backward command.</p></li>
<li class="listitem"><p>For database files that are not journaled (and hence not replicated), perform a mupip rundown, or if appropriate, delete and recreate them.</p></li>
</ol></div>
<p>Example:</p>
<pre class="programlisting">$ export gtm_repl_instance=mutisite.repl
$ export gtm_repl_instname=America
$ mupip replicate -instance_create</pre>
<p>This example creates a replication instance file called multisite.repl specified by gtm_repl_instance with an instance name America specified by environment variable gtm_repl_instname. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="disp_change_repl"></a><span>Displaying/Changing the attributes of Replication Instance File and Journal Pool</span>
</h3></div></div></div>
<p>Command Syntax:</p>
<pre class="programlisting">mupip replicate
 -edit[instance] {&lt;instance-file&gt;|-source -jnlpool} 
  {-show [-detail]|-change [-offset=] [-size=] [-value=]|-cleanslots} 
 [-name=&lt;new-name&gt;]
 [-[no]qdbrundown]</pre>
<p>
<a class="indexterm" name="idm46171617903728"></a>
<a class="indexterm" name="idm46171617837552"></a>
<span class="emphasis"><em>-editinstance</em></span>
</p>
<p>Displays or changes the attributes of the specified <em class="replaceable"><code>instance-file</code></em>. Use -editinstance in combination with the SHOW, CHANGE, or CLEANSLOTS qualifiers.</p>
<p>
<a class="indexterm" name="idm46171617835136"></a>
<a class="indexterm" name="idm46171617834128"></a>
<span class="emphasis"><em>-cleanslots</em></span>
</p>
<p>Goes through all 16 slots in the replication instance file, identifies the slots that are inactive, and clears them to make them available for reuse. </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>Initially, all the slots are unused. A Source Server replicating to a secondary instance for the first time utilizes an unused slot to store the information related to that secondary. Any Source Server process replicating to the same secondary instance updates information using the same slot until -CLEANSLOT clears the slot to make it reusable. Use -CLEANSLOT to clear inactive slots when the originating instance connects to more than 16 different secondary instances throughout its lifetime.</p></td></tr>
</table></div>
<p>
<a class="indexterm" name="idm46171617830784"></a>
<a class="indexterm" name="idm46171617829776"></a>
<span class="emphasis"><em>-jnlpool</em></span>
</p>
<p>Displays or changes the attributes of Journal Pool. Always specify -source with -jnlpool. Use -jnlpool in combination with SHOW or CHANGE qualifiers.</p>
<p>
<a class="indexterm" name="idm46171617827712"></a>
<span class="emphasis"><em>-change</em></span>
 </p>
<p>The CHANGE qualifier is intended only for use under the guidance of FIS and serves two purposes. When used with -editinstance -offset -size, it changes the contents of the replication instance file. When used with -jnlpool, it changes the contents of journal pool header. Although MUPIP does not enforce standalone access when using this feature on the instance file or the journal pool, doing so when replication is actively occurring can lead to catastrophic failures.</p>
<p>
<a class="indexterm" name="idm46171617825200"></a>
<span class="emphasis"><em>-name=&lt;new-name&gt;</em></span>
</p>
<p>Changes the instance name in the replication instance file header to the new-name. Note that changing an instance name preserves the instance history.</p>
<p>
<a class="indexterm" name="idm46171617823008"></a>
<span class="emphasis"><em>-show</em></span>
</p>
<p>Displays File Header, Source Server slots, and History Records from the Replication Instance file.</p>
<p>
<a class="indexterm" name="idm46171617820976"></a>
<span class="emphasis"><em>-detail</em></span>
</p>
<p>When specified, all fields within each section are displayed along with their offset from the beginning of the file and the size of each field. Use this qualifier to find the -offset and -size of the displayed field. To edit any displayed field, use the -change qualifier.  </p>
<p>
<a class="indexterm" name="idm46171617818544"></a>
<span class="emphasis"><em>-size</em></span>
</p>
<p>Indicates the new size of the new value in bytes. The value of size can be either 1, 2, 4, or 8.</p>
<p>
<a class="indexterm" name="idm46171617816512"></a>
<span class="emphasis"><em>-offset</em></span>
</p>
<p>Takes a hexadecimal value that is a multiple of -size. With no -offset specified, GT.M produces an error. GT.M also produces an error if the offset is greater than the size of the instance file or the journal pool header.</p>
<p>
<a class="indexterm" name="idm46171617814128"></a>
<span class="emphasis"><em>-value</em></span>
</p>
<p>Specifies the new hexadecimal value of the field having the specified -offset and -size. With no value specified, GT.M displays the current value at the specified offset and does not perform any change. Specifying -value=&lt;new_value&gt; makes the change and displays both the old and new values.</p>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution: Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Caution]" src="images/caution.jpg"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>Change the instance file or the journal pool only on explicit instructions from FIS.</p></td></tr>
</table></div>
<p>
<a class="indexterm" name="idm46171617811152"></a>
<span class="emphasis"><em>-show</em></span>
</p>
<p>The SHOW qualifier serves two purposes. When used with -editinstance, it displays the content of the replication instance file. When used with -jnlpool, it displays the content of the journal pool.</p>
<p>
<a class="indexterm" name="idm46171617808912"></a>
<span class="emphasis"><em>-[no]qdbrundown</em></span>
</p>
<p>Controls the setting of the "HDR Quick database rundown is active" field in a replication instance file. For more information about this setting, refer to <a class="xref" href="replication.html#create_repl_inst" title="Creating the Replication Instance File">&#8220;<span>Creating the Replication Instance File</span>&#8221;</a>.  </p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -editinstance -show -detail multisite.repl</pre>
<p>This example displays the content of the replication instance file multisite.repl. The optional detail qualifier displays each section along with its offset from the beginning of the file and the size of each field. Use this information when there is a need to edit the instance file.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -editinstance -change -offset=0x00000410 -size=0x0008 -value=0x010 multisite.repl</pre>
<p>This command sets the value of the field having the specified offset and size to 16. Note that mupip replicate -editinstance -show -detail command displays the offset and size of all fields in an instance file. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="start_src_srvr"></a><span>Starting the </span> Source Server<a class="indexterm" name="idm46171617869760"></a>
</h3></div></div></div>
<p>The MUPIP REPLICATE -SOURCE -START command starts a Source Server process. The general syntax for starting a Source Server in active mode is:</p>
<pre class="programlisting">mupip replicate -source -start 
[connection_qualifiers] 
[instance_freeze_qualifiers]
[jnlpool_setup_qualifiers]
log_file_management_qualifiers
[primary_role_qualifiers]
secondary_identification_qualifiers
[tls_replication_qualifiers]
[replication_filter_qualifier]</pre>
<p>The square brackets [] denote an optional qualifier group. The optional and mandatory qualifiers in each qualifier group are as follows: </p>
<div class="informaltable"><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
   <p>Category</p>
   </th>
<th>
     <p>Qualifiers </p>
  </th>
</tr></thead>
<tbody>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#connection_qualifiers">connection_qualifiers</a> </code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">[-cmplvl=&lt;compression_level&gt;]</code></p></li>
<li class="listitem"><p><code class="code">[-connectparams=&lt;hard_tries&gt;, &lt;hard_tries_period&gt;, &lt;soft_tries_period&gt;, &lt;alert_time&gt;, &lt;heartbeat_period&gt;, &lt;max_heartbeat_wait&gt;]</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
 <p><code class="code"><a class="link" href="replication.html#jnlpool_setup_qualifiers">jnlpool_setup_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">[-buffsize=&lt;Journal Pool size in bytes&gt;]</code></p></li>
<li class="listitem"><p><code class="code">[-[no]jnlfileonly]</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#logfile_management_qualifiers">logfile_management_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">-log=&lt;log file name&gt; </code></p></li>
<li class="listitem"><p><code class="code">[-log_interval=&lt;integer&gt;]</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#primary_role_qualifiers">primary_role_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">{-rootprimary|-propagateprimary} </code></p></li>
<li class="listitem"><p><code class="code">[{-updok|-updnotok}]</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#replication_filter_qualifiers">replication_filter_qualifier</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-filter=&lt;filter command&gt;</code></p></li></ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#secondary_identification_qualifiers">secondary_identification_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">-instsecondary=&lt;secondary_instance_name&gt;</code></p></li>
<li class="listitem"><p><code class="code">-secondary=&lt;hostname:port&gt; </code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#tls_replication_qualifiers">tls_replication_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">[-[no]plaintextfallback]</code></p></li>
<li class="listitem"><p><code class="code">[-renegotiate_interval=&lt;minutes&gt;]</code></p></li>
<li class="listitem"><p><code class="code">-tlsid=&lt;label&gt;</code></p></li>
</ul></div>
</td>
</tr>
</tbody>
</table></div>
<p>You can start the Source Server in passive mode with mupip replicate -source -start -passive. The general syntax for starting a Source Server in passive mode is the same as that of starting a Source Server in active mode except that -passive is not compatible with -secondary=&lt;hostname:port&gt;. </p>
<p><span class="bold"><strong><a name="connection_qualifiers"></a>Connection Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617768736"></a>
<a class="indexterm" name="idm46171617899248"></a>
<a class="indexterm" name="idm46171617883600"></a>
<a class="indexterm" name="idm46171617740736"></a>
<span class="emphasis"><em>-cmplvl=n</em></span>
</p>
<p>Specifies the desired compression level for the replication stream. n is a positive integer value indicating the level of compression desired. Level 0 offers no compression. Level 1 offers the least compression while Level 9 (as of version 1.2.3.3 of the zlib library) offers the most compression (at the cost of the most CPU usage). Specifying -cmplvl without an accompanying -start produces an error. In the case of the source server, if N specifies any value outside of the range accepted by the compression library or if -cmplvl is not specified, the compression level defaults to zero (0). In the case of the receiver server, as long as N is non-zero the decompression feature is enabled; since the source server setting determines the actual level, any legal non-zero value enables compressed operation at the receiver.</p>
<p>Alternatively, the environment variable gtm_zlib_cmp_level can specify the desired compression level (in the same value range as N above) and the source server can then be started without -cmplvl. This has the same effect as starting it with -cmplvl specified. An explicitly specified value on the command line overrides any value specified by the environment variable.</p>
<p>Whenever the source and receiver server connect with each other, if the source server was started with a valid non-zero compression level, they first determine whether the receiver server is running a version of GT.M which handles compressed records and has been started with a non-zero compression level. Only if this is true, do they agree to use compressed journal records. They also verify with a test message that compression/decompression works correctly before sending any compressed journal data across. They automatically fall back to uncompressed mode of transmission if this test fails or if, at any point, either side detects that compression or decompression has failed. That is, any runtime error in the compression/decompression logic results in uncompressed replication (thereby reducing replication throughput) but never jeopardizes the functional health of replication.</p>
<p>The Source and Receiver Servers log all compression related events and/or messages in their respective logs. The source server also logs the length of the compressed data (in addition to the uncompressed data length) in its logfile.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>If you plan to use the optional compression facility for replication, you must provide the compression library. The GT.M interface for compression libraries accepts the zlib compression libraries without any need for adaptation. These libraries are included in many distributions and are downloadable from the zlib home page. If you prefer to use other compression libraries, you need to configure or adapt them to provide the same API provided by zlib.</p></td></tr>
</table></div>
<p>By default, GT.M searches for the libz.so shared library in the standard system library directories (for example, /usr/lib, /usr/local/lib, /usr/local/lib64). If the shared library is installed in a non-standard location, before starting replication, you must ensure that the environment variable $LIBPATH (AIX and z/OS) or $LD_LIBRARY_PATH (other UNIX platforms) includes the directory containung the library. The Source and Receiver Server link the shared library at runtime. If this fails for any reason (such as file not found, or insufficient authorization), the replication logic logs a DLLNOOPEN error and continues with no compression.</p>
<p>
<span class="emphasis"><em>-connectparams=&lt;hard tries&gt;,&lt;hard tries period&gt;,&lt;soft tries period&gt;,&lt;REPLALERT time&gt;,&lt;heartbeat period&gt;,&lt;max heartbeat wait&gt;</em></span>
 </p>
<p>Specifies the connection parameters as a comma delimited series of integer values. If the connection between the Source and Receiver Servers breaks or the Source Server fails to connect to the Receiver Server at startup, the Source uses the first four parameters for reconnection attempts as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>It makes the number of new connection attempts specified by the &lt;hard tries&gt; value every &lt;hard tries period&gt; milliseconds.</p></li>
<li class="listitem"><p>Then, the Source Server attempts connection every &lt;soft tries period&gt; seconds and logs the REPLALERT message every &lt;alert time&gt; seconds. </p></li>
<li class="listitem"><p>The only difference between hard and soft connection attempts is their interval duration measurement units (milliseconds vs. seconds) and the association of the REPLALERT message with failed soft connection attempts.</p></li>
<li class="listitem"><p>The presence of the REPLALERT message in the Source Server log file can be used with a monitoring tool to alert the operator about an unaccessible Receiver Server. </p></li>
<li class="listitem"><p>Specifying 0 for &lt;alert time&gt; disables the REPLALERT messages. By default, REPLAERT messages are disabled. Specifying 0 for &lt;hard tries&gt; disables making hard connection attempts which is useful in a situation where the early of logging of the REPLALERT messages is relevant. </p></li>
</ul></div>
<p>The Source Server uses the fifth and sixth parameters when the connection is established with the Receiver Server. It send a heartbeat message to the Receiver Server every &lt;heartbeat period&gt; seconds and expects a response back from the Receiver Server within &lt;max heartbeat wait&gt; seconds. If the response does not arrive within &lt;max heartbeat wait&gt;, the Source Server closes the connection and starts to establish a new conection using the first four parameters. The Source Server temporarily stalls the heartbeat message interchange mechanism during events such as secured renegotiation or online rollback. The stalling of heartbeat connection attempts may also occur when the Receiver Server is not started or is not accessible on the network. </p>
<p>GT.M automatically adjusts the values for &lt;soft tries period&gt; and &lt;hard tries period&gt; to about half of the GT.M determined shutdown wait time. GT.M logs these adjustments in the Source Server log file. This helps prevent inadvertent timeouts of a Source Server shutdown due to high &lt;soft tries period&gt; and/or &lt;hard tries period&gt; and prevents out-of-design conditions.</p>
<p>The default -CONNECTPARAMS values are 5,500,5,0,15,60. With this setting, the Source Server makes 5 hard connection attempts in 500 milliseconds intervals, and then makes soft connection attempts every 5 seconds without logging the REPLALERT message. Once the connection is established, the Source Server sends a heartbeat messages every 15 seconds and closes the connection if a response does not arrive in 60 seconds. Then, the Source Server starts establishings a new connection with hard connection attempts. </p>
<p> You can specify up to six parameters with -CONNECTPARAMS. MUPIP uses the defaults for the parameters not specified.</p>
<p><span class="bold"><strong><a name="jnlpool_setup_qualifiers"></a>Journal Pool Setup Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617760144"></a>
<a class="indexterm" name="idm46171617777120"></a>
<span class="emphasis"><em>
<span>-buffsize=&lt;Journal Pool size in bytes&gt;</span>

</em></span>
</p>
<p>Specifies the size of the Journal Pool. The server rounds the size up or down to suit to align with other specified or implicit requirements. Any size less than 1 MiB is rounded up to 1 MiB. If -BUFFSIZE is not specified, MUPIP sets the Journal Pool size to 64 MiB. Remember that you cannot exceed the system-provided maximum shared memory. For systems with high update rates, specify a larger buffer size to avoid the overflows and file I/O that occur when the Source Server reads journal records from journal files. The maximum value is 68719476736 (64GiB). MUPIP REPLICATE -SOURCE ignores -BUFFSIZE if the Journal Pool is already set up. The first Source Server process started on an instance sets up the Journal Pool. </p>
<p>
<span class="emphasis"><em>-[no]jnlfileonly</em></span>
</p>
<p>Forces the Source Server to read transactions from journal files instead of journal pool shared memory. When combined with the SYNC_IO journal option, this feature delays replication of transactions until their journal records are hardened to disk. This may be useful when replicating to a supplementary instance, as a crash and rollback on the primary could otherwise necessitate a rollback of local updates on the receiving instance. The default is -NOJNLFILEONLY. </p>
<p><span class="bold"><strong><a name="logfile_management_qualifiers"></a>Log File Management Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617767168"></a>
<a class="indexterm" name="idm46171617741072"></a>
<span class="emphasis"><em>
<span>-log=&lt;log file name&gt;</span>

</em></span>
</p>
<p>Specifies the location of the log file. The Source Server logs its unsuccessful connection attempts starting frequently and slowing to approximately once every five minutes. This interval does not affect the rate of connection attempts. The Source Server also directs errors to the log file. Operators should check the Source Server log file for errors.   </p>
<p>
<a class="indexterm" name="idm46171617775216"></a>
<a class="indexterm" name="idm46171617778416"></a>
<span class="emphasis"><em>
-log_interval=&lt;integer&gt;</em></span>
</p>
<p>Specifies the number of transactions for which the Source Server should leave between writing progress to the log file. The default logging interval is 1000 transactions.</p>
<p>-log_interval=0 sets the logging interval to the default value.</p>
<p><span class="bold"><strong><a name="replication_filter_qualifiers"></a>Replication Filter Qualifiers:</strong></span></p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617791712"></a>
<a class="indexterm" name="idm46171617802880"></a>
<span>-filter=&lt;filter command&gt;</span>

</em></span>
</p>
<p>Specifies the complete path of the filter program and any associated arguments. If you specify arguments, then enclose the command string in quotation marks. If a filter is active, the Source Server passes the entire output stream to the filter as input. Then, the output from the filter stream passes to the replicating instance. If the filter program is an M program with entry-ref OLD2NEW^FILTER, specify the following path:</p>
<pre class="programlisting">filter='"$gtm_dist/mumps -run OLD2NEW^FILTER"'</pre>
<p>
<span>Write the filter as a UNIX process that takes its input from STDIN and writes its output to STDOUT.</span>
</p>
<p>You can also define an environment variable like <code class="code">export gtmfilter=""$gtm_dist/mumps -run ^OLD2NEW^FILTER"" </code> to bypass shell escaping and use it in the MUPIP command as follows:</p>
<pre class="programlisting">$gtm_dist/mupip replic -receiver -start -listenport=$portno -filter=$gtmfilter -log=$REC_LOG_FILE </pre>
<p>The format of the input and output data is the MUPIP journal file extract format. The filter must maintain a strict 1:1 relationship between transactions on the input stream and transactions on the output stream. If a transaction on the input results in no sets and kills in the output, the filter must still write an empty transaction to the output stream.</p>
<p>Example:</p>
<a class="indexterm" name="idm46171617757472"></a><pre class="programlisting">extfilter
  ; A command like the following deploys this filter on the Receiver Server:
  ; export gtmfilter=""$gtm_dist/mumps -run ^extfilter""
  ; $gtm_dist/mupip replic -receiver -start -buffsize=$gtm_buffsize 
  ;-listenport=$portno  
  ;-filter=$gtmfilter -log=$REC_LOG_FILE 
  ; deploys this demo filter on the Receiver Server. 
  ; 
  ; This program is a simple filter program that receives journal records 
  ; from standard input and write them back to standard output. 
  ; Journal records between TSTART 
  ; and TCOMMIT are written with single write command. 
  ; 
  ; Do not use this filter program as-is in a production environment.  
  ; While writing filter programs ensure that your programming logic never 
  ; exposes non-public information (NPI) stored in GT.M local variables 
  ; and global variables. You should take additional care about 
  ; managing and sharing GTM_FATAL_ERROR.ZSHOW_DMP_*.txt 
  ; and core dump files that may contain NPI. 
  new TSTART,TCOMMIT,EOT,EOL,log,extrRec,filtrOut,cntr,tmp,rectype,max
  set $ztrap="goto err"
  set TSTART="08"
  set TCOMMIT="09"
  set EOT="99"
  set max=1024*1024               ; maximum size of a local variable;  
  set log=$ztrnlnm("filterlog")   ; use environment variable "filterlog" (if defined) to indicate which logfile to use
  set:log="" log="/dev/null"      ; if filterlog is not defined, write log file output to /dev/null 
  set EOL=$char(10)
  open log:newversion
  use $principal:(nowrap:width=max)
  for  do
  . use $principal
  . read extrRec
  . if $zeof halt
  . set rectype=$piece(extrRec,"",1)
  . if rectype'=EOT do
  .. if rectype'=TSTART set filtrOut=extrRec_EOL  
  .. else  do  ; Write Journal Records within TSTART and TCOMMIT boundary in one go (1MiB limit). 
  ... set filtrOut=extrRec_EOL
  ... for  read extrRec set filtrOut=filtrOut_extrRec_EOL quit:$zextract(extrRec,1,2)=TCOMMIT
  ... if $zeof halt
  .. ; set $x=0 is needed so every write starts at beginning of record position
  .. ; don't write more than "width" characters in one output operation to avoid "chopping" of output
  .. ; and/or eol in the middle of output stream
  .. ; default width=1024*1024
  .. ; use $zsubstr to chop at valid character boundary (single or multi byte character)
  .. set tmp=filtrOut
  .. for  quit:tmp=""  do
  ... set $x=0,record($increment(cntr))=$zsubstr(tmp,1,max-1),tmp=$zextract(tmp,$zlength(record(cntr))+1,$zlength(tmp))
  ... write record(cntr)
  ... kill record(cntr)
  . use log
  . write "Received: ",EOL,$select(rectype'=TSTART:extrRec_EOL,1:filtrOut)  
  . if rectype'=EOT write "Sent: ",EOL,filtrOut
  . else  write "EOT received, halting..." halt
  quit
err
  set $ztrap=""
  use log
  write !!!,"**** ERROR ENCOUNTERED ****",!!!
  zshow "*" 
  halt</pre>
<p>This example reads logical database updates associated with a transaction from STDIN and writes them to a filter log (if filterlog environment variable is defined)  and STDOUT just like the UNIX tee command. It runs on GT.M V5.5-000 where it is no longer required to treat filter output as a transaction. To run this example on a pre-GT.M V5.5-000 version, replace the line:</p>
<pre class="programlisting">.. if rectype'=TSTART set filtrOut=extrRec_EOL</pre>
<p>with</p>
<pre class="programlisting">.. if rectype'=TSTART set filtrOut=TSTART_EOL_extrRec_EOL_TCOMMIT_EOL</pre>
<p>to wrap mini-transactions in 08 09.</p>
<p><span class="bold"><strong><a name="primary_role_qualifiers"></a>Primary Role Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617707824"></a>
<a class="indexterm" name="idm46171617706816"></a>
<span class="emphasis"><em>-propagate[primary]</em></span>
</p>
<p>Use this optional qualifier to assign the current instance as a propagating instance. Specifying -propagateprimary disables updates on the current instance.</p>
<p>Note that it is not possible to transition an originating instance to a propagating instance without bringing down the Journal Pool. However, it is possible to transition a propagating instance to an originating instance without bringing down the Journal Pool for an already running passive Source Server (start one with -propagateprimary if none is running).</p>
<p>Both -rootprimary and -propagateprimary are optional and mutually exclusive. However, FIS recommends you to specify both -rootprimary and -propagateprimary explicitly in the script for clarity.</p>
<p>Example:</p>
<a class="indexterm" name="idm46171617703824"></a><a class="indexterm" name="idm46171617703056"></a><pre class="programlisting">$ mupip replicate -source -activate -rootprimary</pre>
<p>This command transitions a propagating originating instance to an originating instance without bringing down the Journal Pool.</p>
<p>With neither -rootprimary nor -propagateprimary specified, GT.M uses a default value of -propagateprimary for the passive Source Server startup command (mupip replic -source -start -passive) and the deactivate qualifier (mupip replicate -source -deactivate). GT.M uses a default value of -rootprimary for the mupip replicate -source -start -secondary=... and the mupip replic -source -activate commands. These default values make the replication script simpler for users who are planning to limit themselves to one originating instance and multiple replicating instance (without any further replicating instances downstream).</p>
<pre class="programlisting">$ export gtm_repl_instance=multisite.repl
$ mupip set -journal="enable,before,on" -replication=on -region "*"
$ mupip replicate -instance_create -name=America
$ mupip replicate -source -start -buffsize=$jnlpool_size -secondary=localhost:1234 -log=A2B.log -instsecondary=Brazil</pre>
<p>This example starts the Source Server at port 1234 for the replicating instance Brazil. The Source Server creates a Journal Pool. A GT.M Process writes the updated journal records to the Journal Pool. Then, the Source Server process transports each record from the Journal Pool to Brazil via a TCP/IP connection.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Before starting replication, always remember to rundown every replicated database region then start the Source Server.</p></li>
<li class="listitem"><p>GT.M updates to replicated regions are permitted only on the originating instance and disabled on ALL other replicating instances.</p></li>
</ul></div></td></tr>
</table></div>
<p>The Source Server records actions and errors in A2B.log. It also periodically record statistics such as the current backlog, the number of journal records sent since the last log, the rate of transmission, the starting and current JNL_SEQNO, and the path of the filter program, if any. </p>
<p>
<a class="indexterm" name="idm46171617779504"></a>
<a class="indexterm" name="idm46171617722736"></a>
<span class="emphasis"><em>-rootprimary</em></span>
</p>
<p>Assign the current instance as the originating instance. You can specify -rootprimary either explicitly or implicitly to start an instance as an originating instance.</p>
<p>
<a class="indexterm" name="idm46171617690320"></a>
<a class="indexterm" name="idm46171617689424"></a>
<span class="emphasis"><em>-updnotok</em></span>
</p>
<p>Instructs the Source Server to not allow local updates on this instance. This is a synonym for -propagateprimary but is named so it better conveys its purpose.</p>
<p>
<a class="indexterm" name="idm46171617687504"></a>
<a class="indexterm" name="idm46171617686608"></a>
<span class="emphasis"><em>-updok</em></span>
</p>
<p>Instructs the Source Server to allow local updates on this instance. This is a synonym for -rootprimary but is named so it better conveys its purpose.</p>
<p><span class="bold"><strong><a name="secondary_identification_qualifiers"></a>Secondary Identification Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617699328"></a>
<a class="indexterm" name="idm46171617684592"></a>
<span class="emphasis"><em>-instsecondary</em></span>
</p>
<p>Specifies the replicating instance to which the Source Server replicates data. -instsecondary also identifies a Source Server process target for actions like changing to active mode or passive mode, checking Source Server health, or shutting down a Source Server.  </p>
<p>With no -instsecondary specified, the Source Server uses the environment variable gtm_repl_instsecondary for the name of the replicating instance.</p>
<p>With no -instsecondary specified and environment variable gtm_repl_instsecondary not set, mupip replicate -source -checkhealth looks at all the Source Servers (Active or Passive) that are alive and running and those that were abnormally shutdown (say by a kill -9). Any Source Server that was kill -15ed or MUPIP STOPped is ignored because GT.M considers those Source Server shut down in the normal way. This command reports something only if it finds at least one Source Server that is alive and running or was abnormally shutdown. Otherwise it returns a zero (0) status without anything to report even when the Journal Pool exists and GT.M processes (Update Process or Receiver Server on the replicating instance) are up and running.</p>
<p>You can start multiple Source Servers from the same originating instance as long as each of them specifies a different name for -instsecondary.</p>
<p>Specify -instsecondary explicitly (by providing a value) or implicitly (through the environment variable gtm_repl_instsecondary) even for starting a Passive Source Server. Whenever it activates, a Passive Source Server connects to this replicating instance.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -source -start -buffsize=$gtm_buffsize -secondary=localhost:1234 -log=A2B.log -instsecondary=B</pre>
<p>This command starts the Source Server for the originating instance with instance B as its replicating instance.</p>
<p>
<a class="indexterm" name="idm46171617678912"></a>
<a class="indexterm" name="idm46171617677792"></a>
<span class="emphasis"><em>
<span>-secondary=&lt;hostname:port&gt;</span>

</em></span>
</p>
<p>Identifies the replicating instance. &lt;hostname:port&gt; specifies an IPv4 or IPv6 address optionally encapsulated by square-brackets ([]) like "127.0.0.1", "::1", "[127.0.0.1]", or "[::1]" or a hostname that resolves to an IPv4 or IPv6 address and the port at which the Receiver Server is waiting for a connection.</p>
<p>If, in your environment, the same hostname is used for both IPv4 and IPv6, GT.M defaults to IPv6. If you wish to use IPv4, perhaps because you have a Receiver Server running a pre-V6.0-003 version of GT.M that does not support IPv6, set the environment variable gtm_ipv4_only to "TRUE", "YES", or a non-zero integer in order to force GT.M to use IPv4.</p>
<p><span class="bold"><strong><a name="tls_replication_qualifiers"></a>TLS Replication Qualifiers:</strong></span></p>
<p><span class="emphasis"><em><span>-</span>tlsid=&lt;label&gt;
<a class="indexterm" name="idm46171617672528"></a>
<a class="indexterm" name="idm46171617665664"></a></em></span></p>
<p>Instructs the Source or Receiver Server to use the TLS certificate and private key pairs having &lt;label&gt; as the TLSID in the configuration file pointed to by the gtmcrypt_config environment variable. TLSID is a required parameter if TLS/SSL is to be used to secure replication connection between instances. If private keys are encrypted, an environment variable of the form gtmtls_passwd_&lt;label&gt; specifies their obfuscated password. You can obfuscate passwords using the 'maskpass' utility provided along with the encryption plugin. If you use unencrypted private keys, set the gtmtls_passwd_&lt;label&gt; environment variable to a non-null dummy value; this prevents inappropriate prompting for a password.</p>
<p><span class="emphasis"><em><span>-</span>[NO]PLAINtextfallback
<a class="indexterm" name="idm46171617764160"></a>
<a class="indexterm" name="idm46171617661136"></a></em></span></p>
<p>Specifies whether the replication server is permitted to fallback to plaintext communication. The default is -NOPLAINtextfallback. If NOPLAINTEXTFALLBACK is in effect, GT.M issues a REPLNOTLS error in the event it is unable to establish a TLS connection. [Note: GT.M versions prior to V6.1-000 did not support TLS for replication - if needed it could be implemented with an external application such as stunnel (<a class="ulink" href="http://stunnel.org" target="_top">http://stunnel.org</a>).] If PLAINTEXTFALLBACK is in effect, in the event of a failure to establish a TLS connection, GT.M issues REPLNOTLS as a warning. Once a permitted plaintext replication connection is established for a connection session, GT.M never attempts to switch that connection session to TLS connection.</p>
<p><span class="emphasis"><em><span>-</span>RENEGotiate_interval=&lt;minutes&gt;
<a class="indexterm" name="idm46171617668912"></a>
<a class="indexterm" name="idm46171617656304"></a></em></span></p>
<p>Specifies the approximate time in minutes  to wait before attempting to perform a TLS renegotiation. The default -RENEGOTIATE_INTERVAL is a little over 120 minutes. The minimum -RENEGOTIATE_INTERVAL is 1 minute. A value of zero causes GT.M never to attempt a renegotiation. The MUPIP REPLIC -SOURCE -JNLPOOL -SHOW [-DETAIL] command shows the time at which the next TLS renegotiation is scheduled, and how many such renegotiations have occurred thus far for a given secondary instance connection. As renegotiation requires the replication pipeline to be temporarily flushed, followed by the actual renegotiation, TLS renegotiation can cause momentary spikes in replication backlog.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Important]" src="images/important.jpg"></td>
<th align="left"></th>
</tr>
<tr><td align="left" valign="top">TLSv1.3 introduces a number of protocol changes. The concept of renegotiation was removed. As a result, when using TLSv1.3, this qualifier takes on a different meaning. GT.M used TLSv1.2 renegotiation to ensure appropriate refresh of session keys (for rationale, see Luykx, A. and K. Paterson, "Limits on Authenticated Encryption Use in TLS", 2016; http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf). As a result, GT.M uses the term "renegotiation" for SOCKET devices where the mode is "server" and "renegotiation_interval" for the frequency of renegotiation during database replication. For TLSv1.3 sessions, the GT.M Reference TLS plugin treats the "renegotiation" as a request to update the session keys.</td></tr>
</table></div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Important]" src="images/important.jpg"></td>
<th align="left"></th>
</tr>
<tr><td align="left" valign="top">OpenSSL 3.0 by default does not allow client-side initiated TLSv1.2 renegotiation requests due to potential DoS attacks. Because of this, the GT.M Reference TLS plugin built with a pre-OpenSSL 3.0 version does not support client initiated renegotiation when communicating with a plugin build with OpenSSL 3.0. This limitation only affects database replication and not SOCKET devices. There is currently no work-around for this limitation.
</td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="sour_srvr_shutdown"></a><span>Shutting down the</span> Source Server</h3></div></div></div>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -shutdown 
 [-timeout=&lt;timeout in seconds&gt;]
 [-zerobacklog]</pre>
<p>Qualifiers:</p>
<p><a class="indexterm" name="idm46171617658304"></a>
<a class="indexterm" name="idm46171617803424"></a>
<span class="emphasis"><em>
<span>-shutdown</span>

</em></span>
</p>
<p>Shuts down the Source Server.</p>
<p>
<a class="indexterm" name="idm46171617651120"></a>
<a class="indexterm" name="idm46171617650112"></a>
<span class="emphasis"><em>
<span>-timeout=&lt;timeout in seconds&gt;</span>

</em></span>
</p>
<p>Specifies the time (in seconds) the shutdown command should wait before signaling the Source Server to shut down. If you specify -timeout=0, MUPIP initiates the shutdown immediately. The default is 120 seconds and the maximum timeout is 3600 seconds. Any value higher than 3600 produces the INVSHUTDOWN error.</p>
<p>After initiating shutdown of the Source Server, GT.M waits up to 90 * number_of_regions seconds (with a minimum of 120 seconds) for the Source Server process to exit normally. </p>
<p>
   <a class="indexterm" name="idm46171617647120"></a>
   <a class="indexterm" name="idm46171617645920"></a>
   <span class="emphasis"><em>
   <span>-zerobacklog</span>
   </em></span>
 </p>
<p>Restricts Journal Pool in a way that only existing processes can complete their updates and shuts down the Source Server:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>with the REPL0BACKLOG message as soon as there is no backlog and the Source Server has received acknowledgement of all its updates from the Receiver Server.  </p></li>
<li class="listitem"><p>with the REPLBACKLOG message when the timeout expires while there was a backlog and/or unacknowledged updates from the Receiver Server.</p></li>
</ul></div>
<p>The REPL0BACKLOG message helps confirm that two instances are in sync (seqno-wise) because all Source Server updates have reached the Receive Pool at the time of shutdown and there are no-inflight updates. The REPL0BACKLOG message also causes the timeout to expire prematurely. In planned switchover scenarios, the REPL0BACKLOG message assists in operationally preventing lost transaction file generation. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="activate_passive_src_srvr"></a><span>Activating a</span> Passive Source Server</h3></div></div></div>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -activate 
 -secondary=&lt;hostname:port&gt; 
 -log=&lt;log file name&gt; 
 [-log_interval=&lt;integer&gt;]
 -connectparams=&lt;hard tries&gt;,&lt;hard tries period&gt;,
 &lt;soft tries period&gt;,&lt;alert time&gt;,&lt;heartbeat period&gt;,
 &lt;max heartbeat wait&gt;] 
 -instsecondary=&lt;instance_name&gt;
 {-rootprimary|-propagateprimary}</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617637248"></a>
<a class="indexterm" name="idm46171617630000"></a>
<span>-activate</span>

</em></span>
</p>
<p>Activates a passive Source Server. Once activated, the Source Server reads journal records from the Journal Pool and transports them to the system specified by <span class="emphasis"><em>

<span>-secondary</span></em></span>.</p>
<p>Before activation, -activate sets the Source Server to ACTIVE_REQUESTED mode. On successful activation, GT.M sets the Source Server mode to ACTIVE. GT.M produces an error when there is an attempt to activate a Source Server in ACTIVE_REQUESTED mode.</p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617891776"></a>
<a class="indexterm" name="idm46171617624224"></a>
<span>-instsecondary=&lt;instance_name&gt;</span></em></span></p>
<p>Identifies the replicating instance to which the passive Source Server connects after activation.</p>
<p>With no -instsecondary specified, the passive Source Server uses the environment variable gtm_repl_instsecondary
as the value of -instsecondary.</p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617659840"></a>
<a class="indexterm" name="idm46171617619520"></a>
<span>-rootprimary</span></em></span></p>
<p>Specifies that the passive Source Server activation occurs on an originating instance.</p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617633856"></a>
<a class="indexterm" name="idm46171617615472"></a>
<span>-propagateprimary</span></em></span></p>
<p>Specifies that the passive Source Server activation occurs on a propagating instance.</p>
<p>If neither -rootprimary nor -propagateprimary are specified, this command assumes -propagateprimary. </p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617890816"></a>
<a class="indexterm" name="idm46171617611232"></a>
<span>-log_interval</span></em></span></p>
<p>Specifies the number of transactions for which the Source Server should wait before writing to the log file. The default logging interval is 1000 transactions.</p>
<p>-log_interval=0 reverts the logging interval to the default value.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -source -activate -secondary=localhost:8998 -log=A2B.log -instsecondary=America</pre>
<p>This example activates a Source Server from passive mode. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="deavtivate_act_src_srvr"></a><span>Deactivating an</span> Active Source Server</h3></div></div></div>
<a class="indexterm" name="idm46171617667856"></a><p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -deactivate -instsecondary=&lt;instance_name&gt;</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617607744"></a>
<span>-deactivate</span>

</em></span>
</p>
<p>Makes an active Source Server passive. To change the replicating instance with which the Source Server is communicating, deactivate the Source Server and then activate it with a different replicating instance.</p>
<p>Before deactivation, -deactivate sets the Source Server to PASSIVE_REQUESTED mode. On successful deactivation, GT.M sets the Source Server mode to PASSIVE. GT.M produces an error when there is an attempt to deactivate a Source Server in PASSIVE_REQUESTED mode.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617617296"></a>
<span>-instsecondary=&lt;instance_name&gt;</span>
</em></span>
</p>
<p>Identifies the active Source Server to transition to the passive (standby) state.</p>
<p>With no -instsecondary specified, $gtm_repl_instsecondary determines the active Source Server.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617594992"></a>
<span>-rootprimary</span>
</em></span>
</p>
<p>Specifies that the active Source Server is on originating instance.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617607264"></a>
<span>-propagateprimary</span>
</em></span>
</p>
<p>Specifies that the active Source Server is on a propagating instance.</p>
<p>If neither -rootprimary nor -propagateprimary are specified, this command assumes -propagateprimary. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="stop_src_filtr"></a><span>Stopping the</span> Source Filter</h3></div></div></div>
<a class="indexterm" name="idm46171617662080"></a><a class="indexterm" name="idm46171617603328"></a><a class="indexterm" name="idm46171617608688"></a><p>There are two ways to stop an active filter on the Source Server. </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Execute mupip replicate <span>-</span>source <span>-</span>stopsourcefilter -instsecondary on the originating Source Server.  </p></li>
<li class="listitem"><p>Specify <span>-</span>stopsourcefilter as an option for starting the Receiver Server. </p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left"></th>
</tr>
<tr><td align="left" valign="top"><p>If a filter fails to respond within just over a minute to delivery of a mini-transaction or TP transaction, a Source or Receiver Server issues a FILTERTIMEDOUT error, stops the filter, and exits.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="stop_rec_filtr"></a><span>Stopping the</span> Receiver Filter</h3></div></div></div>
<a class="indexterm" name="idm46171617599232"></a><a class="indexterm" name="idm46171617627568"></a><a class="indexterm" name="idm46171617584688"></a><p>Command Syntax:</p>
<pre class="programlisting">mupip replicate -receiver -stopreceiverfilter</pre>
<p>Qualifiers:</p>
<p><span class="emphasis"><em>-stopreceiverfilter</em></span></p>
<p>Turns off any active filter on the Receiver Server without turning off the Receiver Server. Using -stopreceiverfilter when no filter is active returns a non-success return code. -stopreceiverfilter is not compatible with any other -receiver qualifier.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="freeze_src_srv_inst"></a><span>Freezing an </span> Instance<a class="indexterm" name="idm46171617658048"></a>
</h3></div></div></div>
<p>The MUPIP REPLICATE -SOURCE command with instance freeze qualifiers manage the Instance Freeze facility of an instance. The syntax is:</p>
<pre class="programlisting">mupip replicate -source 
  [-[no]comment[='"&lt;string&gt;"']]
  -freeze[=on|off]</pre>
<p>Qualifiers:</p>
<p><span class="emphasis"><em>-[no]comment[='"&lt;string&gt;"']</em></span></p>
<p>Allows specifying a comment/reason associated with an Instance Freeze. Specify -nocomment if you do not wish to specify a comment/reason.</p>
<p><span class="emphasis"><em>-freeze[=on|off]</em></span></p>
<p>Sets or clears an Instance Freeze on an instance irrespective of whether a region is enabled for an Instance Freeze. -freeze with no arguments displays the current state of the Instance Freeze on the instance.</p>
<p>For more information on enabling a region to invoke an Instance Freeze on custom errors, refer to the -INST_FREEZE_ON_ERROR section of <a class="xref" href="gdm.html#mup_set" title="SET">&#8220;SET&#8221;</a>. </p>
<p>For more information on Instance Freeze, refer to <a class="xref" href="ch07s02.html#inst_freeze" title="Instance Freeze">&#8220;Instance Freeze&#8221;</a>.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="chck_srvr_hlth"></a>Check<span>ing</span> Server Health</h3></div></div></div>
<p>Use the following command and qualifier to determine whether the Source
Server is running.</p>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -checkhealth [-instsecondary=&lt;instance_instance&gt;]</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617564208"></a>
<span>-checkhealth</span>

</em></span>
</p>
<p>Determine whether the Source Server is running. If the Source Server is running, the exit code is 0 (zero). If the Source Server is not running or an error exists, the exit code is not 0.</p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617608992"></a>
<a class="indexterm" name="idm46171617553472"></a>
<span>-instsecondary=&lt;instance_name&gt;</span></em></span></p>
<p>Identifies a Source Server process. </p>
<p>If -instsecondary is not specified, -checkhealth checks all Source Server processes. </p>
<p>Example:</p>
<pre class="programlisting">$ mupip replic -source -checkhealth -inst=INSTB
Fri May 21 15:26:18 2010 : Initiating CHECKHEALTH operation on source server pid [15511] for secondary 
instance name [INSTB]
PID 15511 Source server is alive in ACTIVE mode
$ mupip replic -source -checkhealth -inst=INSTB
Fri May 21 15:29:52 2010 : Initiating CHECKHEALTH operation on source server pid [0] for secondary 
instance name [INSTB]
PID 0 Source server is NOT alive
%GTM-E-SRCSRVNOTEXIST, Source server for secondary instance INSTB is not alive</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="chng_log_file"></a><span>Changing the Log File</span>
</h3></div></div></div>
<a class="indexterm" name="idm46171617577840"></a><a class="indexterm" name="idm46171617566400"></a><p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -changelog -log=&lt;log file name&gt; [-log_interval=&lt;integer&gt;] -instsecondary=&lt;instance_name&gt;</pre>
<p>Qualfiers:</p>
<p>
<span class="emphasis"><em>
<span>-changelog</span>

</em></span>
</p>
<p>Instructs the Source Server to change its log file.</p>
<p><span class="emphasis"><em>
<a class="indexterm" name="idm46171617546240"></a>
<a class="indexterm" name="idm46171617538992"></a>
<span>-instsecondary=&lt;instance_name&gt;</span></em></span></p>
<p>Identifies a Source Server process. </p>
<p>
<span class="emphasis"><em>
<span>-log=&lt;log file name&gt;</span>

</em></span>
</p>
<p>Use this mandatory qualifier to specify the name of the new log file. If you specify the name of the current log file, no change occurs.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -source -changelog -log=/more_disk_space/newA2B.log -instsecondary=Brazil</pre>
<p>
<a class="indexterm" name="idm46171617590176"></a>
<a class="indexterm" name="idm46171617536640"></a>
<span class="emphasis"><em>
-log_interval=&lt;integer&gt;</em></span>
</p>
<p>Specifies the number of transactions for which the Source Server should wait before writing to the log file. The default logging interval is 1000 transactions.</p>
<p>-log_interval=0 reverts the logging interval to the default value.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="enable_disable_dtld_log"></a><span>Enabling/Disabling Detailed</span> Logging</h3></div></div></div>
<a class="indexterm" name="idm46171617560080"></a><p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -statslog={ON|OFF} 
 [-log_interval=&lt;integer&gt;</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617532000"></a>
<span>-statslog={ON | OFF}</span>

</em></span>
</p>
<p>Enables or disables detailed logging. When ON, the system logs current-state information of the Source Server and messages exchanged between the Source and Receiver Servers. By default, detailed logging is OFF. Once you enable it (ON), changing <span class="emphasis"><em><span>-</span></em></span>statslog to OFF can stop detailed logging.</p>
<p>
<a class="indexterm" name="idm46171617545344"></a>
<a class="indexterm" name="idm46171617523824"></a>
<span class="emphasis"><em>
-log_interval=&lt;integer&gt;</em></span>
</p>
<p>Specifies the number of transactions for which the Source Server should wait before writing to the log file. The default logging interval is 1000 transactions.</p>
<p>-log_interval=0 reverts the logging interval to the default value.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="rprt_current_backlog"></a><span>Reporting the Current Backlog of Journal Records</span>
</h3></div></div></div>
<a class="indexterm" name="idm46171617609136"></a><p>Command syntax:</p>
<pre class="programlisting">mupip replicate -source -showbacklog</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617519808"></a>
<span>-showbacklog</span>

</em></span>
</p>
<p>Reports four fields that help determine the backlog of updates on the Source Server. These fields are:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>Current backlog of journal records (in terms of the number of JNL_SEQNOs) </p></li>
<li class="listitem"><p>Last JNL_SEQNO written to the Journal Pool</p></li>
<li class="listitem"><p>Last JNL_SEQNO sent by the Source Server to the Receiver Server </p></li>
<li class="listitem"><p>Last JNL_SEQNO acknowledged by the Receiver Server</p></li>
</ol></div>
<p>The backlog is the difference between the second and third fields. When backlog is 0 and the remaining three fields have the same value, it means that all Source Server updates have reached the Receiver Pool and there are no in-flight updates.</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important: Important">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Important]" src="images/important.jpg"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>A -SHOWBACKLOG operation momentarily restricts access to the Journal Pool to determine the backlog. If your operations demand frequent checking for replication backlogs, FIS recommends using the ^%PEEKBYNAME function instead of performing a -SHOWBACKLOG in a continuous loop. Please refer to the examples for more information on using ^%PEEKBYNAME for monitoring replication speed and backlog. </p></td></tr>
</table></div>
<p>Example:</p>
<pre class="programlisting">$ mupip replic -source -showbacklog -inst=INSTB
Tue Jan  5 10:36:46 2021 : Initiating SHOWBACKLOG operation on source server pid [0] for secondary instance [INSTB]
52 : backlog number of transactions written to journal pool and yet to be sent by the source server
102 : sequence number of last transaction written to journal pool
50 : sequence number of last transaction sent by source server
25 : sequence number acknowledged by the secondary instance [INSTB]</pre>
<p>Example: </p>
<pre class="programlisting">replspeed
  ; This routine returns the replication speed, that is the number of seqno updates per second acknowledged by the replicating instance during heartbeat intervals
  ; Usage: $gtm_exe/mumps -r ^replspeed INSTANCE3 20
  ; The second parameter is the sampling size
  set $etrap="write ""REPLSPEED-E-ACKSMPL : unable to fetch sampling data due to "",$zstatus  halt  "
  set $ztimeout="300:write ""Timeout occurred out after 5 minutes"",! zwrite  halt"
  new hrtbtperiod,instance,samplingsize,hrtbts,slot,i,hrtbtdiffs,diff,dump
  set instance=$piece($zcmdline," ",1),slot=0
  set samplingsize=$piece($zcmdline," ",2),hrtbtdiffs=0
  set:$length(samplingsize)=0 samplingsize=10
  if '($length(instance)) write "REPLSPEED-E-ARGS : ",$zcmdline," was specified. This routine requires specifying an instance name.",! halt
  for i=0:1:15 set instname=$$^%PEEKBYNAME("gtmsource_local_struct.secondary_instname",i),instname=$piece(instname,$char(0),1) set:(instname=instance) slot=i
  ; capture heartbeat_jnl_seqno samplingsize times. Wait for hrtbtperiod after every capture of heartbeat_jnl_seqno
  set hrtbtperiod=$piece($$^%PEEKBYNAME("gtmsource_local_struct.connect_parms",slot),",",5)
  for j=1:1:samplingsize do
  . set hrtbts(j)=$$^%PEEKBYNAME("gtmsource_local_struct.heartbeat_jnl_seqno",slot,"I")
  . do:(j&gt;1)
  . . set diff=hrtbts(j)-hrtbts(j-1)
  . . do:(diff&lt;0)
  . . . write "REPLSPEED-E-ACKSEQNO : acknowledgement sequence number received is lower than previous acknowledgement seqno."
  . . . set dump="replspeed.dump" open dump use dump zwrite hrtbts  close dump
  . . . halt
  . . set hrtbtdiffs=hrtbtdiffs+diff
  . hang hrtbtperiod
  set hrtbtdiffs=hrtbtdiffs/samplingsize
  write $justify(hrtbtdiffs/hrtbtperiod,0,0)
  quit</pre>
<p>Example: </p>
<pre class="programlisting">waitforhrtbt
  ; This routine returns 0 when the acknowledged seqno from the specified instance matches or exceeds the specified seqno
  ; If there is no confirmation (network issues etc) from the Receiver Server for 300 seconds, this routines returns 1.
  ; Usage: $gtm_exe/mumps -r ^waitforhrtbt &lt;instname&gt; &lt;seqnocheckpoint&gt;
  set $etrap="write ""WAITFORHRTBT-E-ERROR, Error occurred while waiting for ackseqno confirmation due to "",$zstatus  halt  "
  new heartbeatseqno,hangduration,instance,checkseqno,i,instname,slot
  ; set $ztimeout to align with the REPLALERT threshold for the test system
  set $ztimeout="900:write 1 halt"
  set hangduration=1,slot=""
  set instance=$piece($zcmdline," ",1)
  set checkseqno=$piece($zcmdline," ",2)
  if '($length(instance)&amp;$length(checkseqno)) write "WAITFORHRTBT-E-ARGS : ",$zcmdline," was specified. This routine requires specifying instance name and seqno.",! halt
  for i=0:1:15 set instname=$$^%PEEKBYNAME("gtmsource_local_struct.secondary_instname",i),instname=$piece(instname,$char(0),1) set:(instname=instance) slot=i
  if '($length(slot)) write "WAITFORHRTBT-E-INSTNOMATCH : No matching instance name for ",instance,! halt
  for  do
  . set heartbeatseqno=$$^%PEEKBYNAME("gtmsource_local_struct.heartbeat_jnl_seqno",slot,"I")-1
  . if (heartbeatseqno&gt;=checkseqno) write 0 halt
  . hang hangduration
  quit</pre>
<p>Example:</p>
<pre class="programlisting">waitforseqnosync
  ; This routine returns 0 when there the sequence numbers of the Source Server and the acknowledged sequence number from the Receiver Server is the same.
  ; It returns a non-zero value when there is no confirmation of the receipt of the latest seqno from the secondary even when there is no backlog.
  ; If there is no confirmation (network issues etc) from the Receiver Server for 150 seconds, this routines returns 1.
  ; Usage: $gtm_exe/mumps -r ^waitforseqnosync &lt;instname&gt;
  set $etrap="write ""WAITFORSEQNOSYNC-E-SRCBACKLOG : unable to get current Source Server backlog and seqno updates status due to "",$zstatus  halt  "
  new readseqno,heartbeatseqno,instance,i,instname,slot,hrtbtperiod
  set $ztimeout="150:write 1 halt"
  set slot=""
  ; hrtbtperiod: the heartbeat period (the fifth parameter of -CONNECTPARAMS)
  set instance=$zcmdline
  if '$length(instance) write "WAITFORSEQNOSYNC-E-ARGS : This routine requires specifying an instance name.",! halt
  for i=0:1:15 set instname=$$^%PEEKBYNAME("gtmsource_local_struct.secondary_instname",i),instname=$piece(instname,$char(0),1) set:(instname=instance) slot=i
  if '($length(slot)) write "WAITFORSEQNOSYNC-E-INSTNOMATCH : No matching instance name for ",instance halt
  set hrtbtperiod=$piece($$^%PEEKBYNAME("gtmsource_local_struct.connect_parms",slot),",",5)
  for  do
  . set seqno=$$^%PEEKBYNAME("jnlpool_ctl_struct.jnl_seqno","","I")
  . set readseqno=$$^%PEEKBYNAME("gtmsource_local_struct.read_jnl_seqno",i,"I")
  . set heartbeatseqno=$$^%PEEKBYNAME("gtmsource_local_struct.heartbeat_jnl_seqno",i,"I")
  . if (seqno=readseqno=heartbeatseqno) write 0 halt
  . hang hrtbtperiod
  quit</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="process_lost"></a>Process<span>ing</span> Lost Transactions<span> File</span><a class="indexterm" name="idm46171617554416"></a>
</h3></div></div></div>
<p>Except following a failover when the backlog is zero, whenever a former originating instance comes up as a new replicating instance, there is always a lost transaction file. Apply this lost transaction file at the new originating instance as soon as practicable because there could be additional lost transaction files in the event of other failovers. For example, failure of the new originating instance before the lost transaction file is processed. These additional lost transactions files can complicate the logic needed for lost transaction processing.</p>
<p>Apply the lost transactions on the new originating instance either manually or in a semi-automated fashion using the M-intrinsic function $ZQGBLMOD(). If you use $ZQGBLMOD() , two perform 2 additional steps ( mupip replicate -source -needrestart and mupip replicate -source -losttncomplete ) as part of lost transaction processing. Failure to run these steps can cause $ZQGBLMOD() to return false negatives that in turn can result in application data consistency issues.</p>
<p>Command Syntax:</p>
<pre class="programlisting">mupip replicate -source
{-losttncomplete | -needrestart}
-instsecondary=&lt;replicating instance name&gt;</pre>
<p>
<a class="indexterm" name="idm46171617495440"></a>
<a class="indexterm" name="idm46171617494208"></a>
<span class="emphasis"><em>-losttncomplete</em></span>
</p>
<p>Indicate to GT.M that all lost transaction processing using $ZQGBLMOD() is complete. Use this qualifier either explicitly or implicitly to prevent a future $ZQGBLMOD() on an instance from returning false positives when applying future lost transactions. This ensures accuracy of future $ZQGBLMOD() results.</p>
<p>Always use this qualifier when an originating instance comes up as a replicating instance.</p>
<p>Always run MUPIP REPLICATE -SOURCE -LOSTTNCOMPLETE on each of the replicating instances after applying all lost transaction files except on the following occasions:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>The replicating instance is connected to the originating instance at the time the command is run on the originating instance.</p></li>
<li class="listitem"><p>The replicating instance is not connected at the time the command is run on the originating instance but connects to the originating instance, before the originating instance is brought down.</p></li>
</ul></div>
<p>
<a class="indexterm" name="idm46171617490128"></a>
<a class="indexterm" name="idm46171617489376"></a>
<span class="emphasis"><em>-needrestart</em></span>
</p>
<p>Checks whether the originating instance ever communicated with the specified replicating instance (if the receiver server or a fetchresync rollback on the replicating instance communicated with the Source Server) since the originating instance was brought up. If so, this command displays the message SECONDARY INSTANCE xxxx DOES NOT NEED TO BE RESTARTED indicating that the replicating instance communicated with the originating instnace and hence does not need to be restarted. If not, this command displays the message SECONDARY INSTANCE xxxx NEEDS TO BE RESTARTED FIRST. In this case, bring up the specified instance as a replicating instance before the lost transactions from this instance are applied. Failure to do so before applying the corresponding lost transactions causes $ZQGBLMOD() to return false negatives which can result in application data inconsistencies.</p>
<p>The mupip replic -source -needrestart command should be invoked once for each lost transaction file that needs to be applied. It should be invoked on the new originating instance before applying lost transactions. Specify -instsecondary  to provide the instance name of the replicating instance where the lost transaction file was generated. If not, the environment variable gtm_repl_instsecondary is implicitly assumed to hold the name of the replicating instance.</p>
<p>If the lost transaction file was generated from the same instance to which it is to be applied, a mupip replicate -source -needrestart command is not required.</p>
<p>Always remember to bring the  replicating instance (specified in the -needrestart command) as an immediate replicating instance of the current originating instance. If it is brought up as a replicating instance through a different intermediate replicating instance, the -needrestart command unconditionally considers the instance as not having communicated with the originating instance even though it might be up and running.</p>
<p>The Source Server on the originating instance and/or Receiver Server or fetchresync rollback on the replicating instance need not be up and running at the time you run this command.</p>
<p>However, it is adequate if they were up at some point in time after the originating instance was brought up.</p>
<p>This command protects against a scenario where the originating instance when the lost transaction file is generated is different from the primary instance when the lost transactions are applied (note that even though they can never be different in case of a dual-site configuration, use of this command is nevertheless still required).</p>
<p>$ZQGBLMOD() relies on two fields in the database file header of the originating instance to be set appropriately. Zqgblmod Trans and Zqgblmod Seqno. In an LMS configuration, if there are more than two instances, and no instances other than the originating and replicating instances are involved in the rollback -fetchresync participate in the sequence number determination. Hence, they do not have their Zqgblmod Seqno (and hence Zqgblmod Trans) set when that particular lost transaction file is generated. If any of the non-participating instances is brought up as the new originating instance and that particular lost transaction file is applied on the originating instance, the return values of $ZQGBLMOD() will be unreliable since the reference point (Zqgblmod Trans) was not set appropriately. Hence, this command checks whether the replicating instance where the lost transaction was previously generated has communicated with the current originating instance after it came up as the originating instance. If it is affirmative, the Zqgblmod Seqno and Zqgblmod Trans fields would have been appropriately set and hence $ZQGBLMOD() values will be correct.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replic -source -losttncomplete</pre>
<p>This command updates the Zqgblmod Seqno and Zqgblmod Trans fields (displayed by a dse dump -fileheader command) in the database file headers of all regions in the global directory to the value 0. Doing so causes a subsequent $ZQGBLMOD() to return the safe value of one unconditionally until the next lost transaction file is created.</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="lost_tn_fmt"></a>Lost Transaction File format<a class="indexterm" name="idm46171617480688"></a>
</h4></div></div></div>
<p>The first line of the lost transaction file include up to four fields. The first field displays GDSJEX04 signifying the file format version.The second field indicates whether the lost transaction file is a result of a rollback  or recover.   If the second field is ROLLBACK, a third field indicates whether the instance was a PRIMARY or SECONDARY immediately prior to the lost transaction file being generated. If it was a PRIMARY, the lost transaction file is termed a primary lost transaction file and it needs to be applied on the new originating instance. A fourth field holds the name of the replicating instance on which the lost transactions were generated. This instance name should be used as the -instsecondary qualifier in the mupip replic -source -needrestart command when the lost transactions are applied at the new originating instance.</p>
<p>The first line of a lost transaction file looks like the following:</p>
<pre class="programlisting">GDSJEX07 ROLLBACK SECONDARY Perth</pre>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="strt_rcvr_srvr"></a>Start<span>ing the</span> Receiver Server<a class="indexterm" name="idm46171617548672"></a>
<a class="indexterm" name="idm46171617568224"></a>
</h3></div></div></div>
<p>The MUPIP REPLICATE -RECEIVER -START command starts a Receiver Server and the Update Process. The general syntax for starting a Receiver Server and the Update Process is:</p>
<pre class="programlisting">mupip replicate -receiver -start 
[autorollback_qualifier]
connection_qualifiers 
logfile_management_qualifiers 
[operator_override_qualifiers]
[replication_filter_qualifers]
[si_replication_qualifiers]
[tls_replication_qualifier]</pre>
<p>The square brackets [] denote an optional qualifier group. The optional and mandatory qualifiers in each qualifier group are as follows:</p>
<div class="informaltable"><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
   <p>Category</p>
   </th>
<th>
     <p>Qualifiers </p>
  </th>
</tr></thead>
<tbody>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#autorollback_qualifier_recv">autorollback_qualifier</a> </code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-autorollback[=verbose]</code></p></li></ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#connection_qualifiers_recv">connection_qualifiers</a> </code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code"><a class="link" href="replication.html#connection_qualifiers">[-cmplvl=&lt;compression_level&gt;]</a></code></p></li>
<li class="listitem"><p><code class="code">-listenport=&lt;port number&gt;</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#logfile_management_qualifiers_recv">logfile_management_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">-log=&lt;log file name&gt; </code></p></li>
<li class="listitem"><p><code class="code">[-log_interval="[integer1],[integer2]"]</code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#operator_override_qualifiers_recv">operator_override_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">{-noresync | -updateresync=&lt;/path/to/bkup-orig-repl-inst-file&gt;}</code></p></li></ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code">replication_filter_qualifier</code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code"><a class="link" href="replication.html#replication_filter_qualifiers">-filter=&lt;filter command&gt;</a></code></p></li></ul></div>
</td>
</tr>
<tr>
<td>
 <p><code class="code"><a class="link" href="replication.html#jnlpool_setup_qualifiers">recvpool_setup_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code"><a class="link" href="replication.html#jnlpool_setup_qualifiers">-buffsize=&lt;Receiver Pool size in bytes&gt;</a></code></p></li></ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#si_replication_qualifiers_recv">si_replication_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><code class="code">[-initialize] </code></p></li>
<li class="listitem"><p><code class="code">[{-resume=&lt;strm_num&gt;|-reuse=&lt;instname&gt;}] </code></p></li>
</ul></div>
</td>
</tr>
<tr>
<td>
   <p><code class="code"><a class="link" href="replication.html#tls_replication_qualifiers_recv">tls_replication_qualifiers</a></code></p>
 </td>
<td>
 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-tlsid=&lt;label&gt;</code></p></li></ul></div>
</td>
</tr>
</tbody>
</table></div>
<p><span class="bold"><strong><a name="autorollback_qualifier_recv"></a>Autorollback Qualifier:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617445136"></a>
<a class="indexterm" name="idm46171617392368"></a>
<span class="emphasis"><em>-autorollback[=verbose]</em></span></p>
<p>-AUTOROLLBACK in a Receiver Server startup command of a BC/SI replication instance performs an automatic MUPIP JOURNAL -ROLLBACK -BACKWARD -FETCHRESYNC=&lt;portno&gt;. Choosing between -AUTOROLLBACK and -FETCHRESYNC (with -[NO]LOSTTRANS and -[NO]BROKENTRANS) depends on your replicating configuration and how your application processes lost transaction files. Use a MUPIP JOURNAL -ROLLBACK command with -FETCHRESYNC when you need:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Control over the name and location of the lost/broken transaction files (by specifying -LOSTTRANS and -BROKENTRANS)</p></li>
<li class="listitem"><p>To disable lost transaction file processing if there is no need to apply lost transaction files (by specifying -LOSTTRANS=/dev/null or -NOLOSTTRANS), or</p></li>
<li class="listitem"><p>To disable broken transaction file processing if there is no need to research broken transaction (by specifying -BROKENTRANS=/dev/null or -NOBROKENTRANS), or</p></li>
<li class="listitem"><p>To enable operational intervention when there is a lost transaction file in order to capture, review or process it on the new originating/primary instance before starting the Receiver Server. </p></li>
</ul></div>
<p>For more information on MUPIP JOURNAL -ROLLBACK -BACKWARD -FETCHRESYNC, refer to <a class="xref" href="replication.html#rollback_db_after_sys_fail" title="Rolling Back a Replicated Database">&#8220;<span>Rolling Back a Replicated Database </span>&#8221;</a>. </p>
<p>Use -AUTOROLLBACK when there are no application side restraints on the timing/need of processing of the lost transaction file. With -AUTOROLLBACK, the Receiver Server performs a connection handshake with the originating/upstream Source Server. If the upstream Source Server sends the REPL_ROLLBACK_FIRST message during the handshake, the Receiver Server with -AUTOROLLBACK performs the following operations:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Close its connection with the Source Server.</p></li>
<li class="listitem"><p>Uses the Source Server's connected port number stored in the memory to launch a separate MUPIP process for MUPIP JOURNAL -ROLLBACK -FETCHRESYNC which receives the rollback point (region sequence number) from the originating/upstream Source Server and rolls back the replicating instance to that rollback point and generates a lost transaction file in the default location. </p></li>
<li class="listitem"><p>Once the rollback is complete, the Receiver Server re-establishes the replication connection and resumes receiving updates from the Source Server. </p></li>
<li class="listitem"><p>A Receiver Server started without AUTOROLLBACK shuts down with the message <code class="code">"Receiver was not started with -AUTOROLLBACK. Manual ROLLBACK required. Shutting down"</code>.</p></li>
</ul></div>
<p><span class="bold"><strong><a name="connection_qualifiers_recv"></a>Connection Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617460992"></a>
<a class="indexterm" name="idm46171617435648"></a>
<span class="emphasis"><em>
<span>-listenport=&lt;port
number&gt;</span>

</em></span>
</p>
<p>Specifies the TCP port number the Receiver Server will listen to for incoming connections from a Source Server. Note that the current implementation of the Receiver Server does not support machines with multiple IP addresses.</p>
<p><span class="bold"><strong><a name="logfile_management_qualifiers_recv"></a>Logfile Management Qualifiers:</strong></span></p>
<p>
<span class="emphasis"><em>
<span>-log=&lt;recsrv_log_file_name &gt;</span>

</em></span>
</p>
<p>Specifies the location of the log file of the Receiver Server. When -log is specified, the Update Process writes to a log file named &lt;recsrv_log_file_name&gt;.updproc. Note that the name of the Update Process log file name has .updproc at the end to distinguish it from the Receiver Server's log file name.  </p>
<p>
</p>
<p>
<span class="emphasis"><em><span>-</span>log_interval="[integer1],[integer2]"
<a class="indexterm" name="idm46171617514976"></a>
<a class="indexterm" name="idm46171617501616"></a>
</em></span>
</p>
<p><span class="emphasis"><em>integer1</em></span> specifies the number of transactions the Receiver Server should process between updates to its log file. <span class="emphasis"><em>integer2</em></span> specifies the number of transactions the Update Process should process between updates to its log file. The default logging interval is 1000 transactions.</p>
<p>If <span class="emphasis"><em>integer1</em></span> or <span class="emphasis"><em>integer2</em></span> is 0, the logging interval is set to the default value.</p>
<p><span class="bold"><strong><a name="operator_override_qualifiers_recv"></a>Operator Override Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617478240"></a>
<a class="indexterm" name="idm46171617411408"></a>

<span class="emphasis"><em>-updateresync=&lt;/path/to/bkup-orig-repl-inst-file&gt;</em></span></p>
<p>-updateresync guarantees GT.M that the replicating instance was, or is, in sync with the originating instance and it is now safe to resume replication. Use -updateresync only in the following situations:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>To replace an existing replication instance files when an upgrade to a GT.M version changes the instance file format. Consult the release notes to determine whether this applies to your upgrade.</p></li>
<li class="listitem"><p>When an existing replication instance file is unusable because it was damaged or deleted, and is replaced by a new replication instance file.</p></li>
<li class="listitem"><p>Setting up an A&#8594;P configuration for the first time if P is an existing instance with existing updates that are not, and not expected to be, in the originating instance.</p></li>
<li class="listitem"><p>Setting up a new replicating instance from a backup of the originating instance (A-&gt;P only) or one of its replicating secondary instances. </p></li>
<li class="listitem"><p>If you are running a GT.M version prior to V5.5-000 and you have to set up a replicating instance from a backup of an originating instance.</p></li>
</ul></div>
<p>-updateresync
uses the journal sequence number stored in the replicating instance's database and the history record available in the backup copy of the replication instance file of the originating instance (&lt;/path/to/bkup-orig-repl-inst-file&gt;) to determine the journal sequence number at which to start replication.</p>
<p>When
replication resumes after a suspension (due to network or maintenance issues), GT.M compares the history records stored in the replication instance file of the replicating instance with the history records stored in the replication instance file of the originating instance to determine the point at which to resume replication. This mechanism ensures that two instances always remain in sync when a replication connection resumes after an interruption. -updateresync bypasses this mechanism by ignoring the replication history of the replicating instance and relying solely on the current journal sequence number and its history record in the originating instance's history to determine the point for resuming replication. As it overrides a safety check, use -updateresync only after careful consideration. You can check with your GT.M support channel as to whether -updateresync is appropriate in your situation. </p>
<p>To perform an updateresync, the originating instance must have at least one history record. You need to take a backup (BACKUP -REPLINST) of the replication instance file of the originating instance while the Source Server is running. This ensures that the instance file has at least one history record. Even though it is safe to use a copy (for example, an scp) of the replication instance file of the originating instance taken after shutting down its Source Server, BACKUP -REPLINST is recommended because it does not require Source Server shutdown. You also need an empty instance file (-INSTANCE_CREATE) of the replicating instance to ensure that it bypasses the history information of the current and prior states.</p>
<p>When started with -updateresync, the receiver server continues trying connection attempts to the source server until it gets a successful update in response. Once an update goes through, subsequent connection restarts behave as if the receiver was started without -updateresync.</p>
<p>You also need use -updateresync to replace your existing replication instance files if a GT.M version upgrade changes the instance file format. The instance file format was changed in V5.5-000. Therefore, upgrading a replicating instance from a version prior to GT.M V5.5-000 up to V5.5-000 or higher requires replacing its instance file.</p>
<p>Prior
to V5.5-000, -updateresync did not require the argument (&lt;bckup_orig_repl_inst_file&gt;).
The syntax for -updateresync depends on the GT.M version. </p>
<p>For information on the procedures that use -updateresync, refer to <a class="xref" href="ch07s03.html#updateresyncproc1" title="Setting up a new replicating instance of an originating instance (A&#8594;B, P&#8594;Q, or A&#8594;P)">&#8220;Setting up a new replicating instance of an originating instance (A&#8594;B,
P&#8594;Q, or A&#8594;P)&#8221;</a>,
<a class="xref" href="ch07s03.html#updateresyncproc2" title="Replacing the replication instance file of a replicating instance (A&#8594;B and P&#8594;Q)">&#8220;Replacing the replication instance file of a replicating instance (A&#8594;B
and P&#8594;Q)&#8221;</a>, <a class="xref" href="ch07s03.html#updateresyncproc3" title="Replacing the replication instance file of a replicating instance (A&#8594;P)">&#8220;Replacing the replication instance file of a replicating instance (A&#8594;P)&#8221;</a>, and <a class="xref" href="ch07s03.html#updateresyncproc4" title="Setting up a new replicating instance from a backup of the originating instance (A&#8594;P)">&#8220;Setting up a new replicating instance from a backup of the originating instance
(A&#8594;P)&#8221;</a>. </p>
<p>
<a class="indexterm" name="idm46171617402688"></a>
<a class="indexterm" name="idm46171617400688"></a>
<span class="emphasis"><em>-noresync</em></span>
</p>
<p>Instructs the Receiver Server to accept a SI replication stream even when the receiver is ahead of the source. In this case, the source and receiver servers exchange history records from the replication instance file to determine the common journal stream sequence number and replication resumes from that point onwards. Specifying -noresync on a BC replication stream produces a NORESYNCSUPPLONLY error. Specifying -noresync on a SI replication stream receiver server where the receiving instance was started with -UPDNOTOK (updates are disabled)  produces a NORESYNCUPDATERONLY error. Note also that the noresync qualifier is not the opposite of the resync qualifier of rollback (mupip journal -rollback -resync), which is intended for use under the direction of FIS GT.M support.</p>
<p><span class="bold"><strong><a name="si_replication_qualifiers_recv"></a>SI Replication Qualifiers:</strong></span></p>
<p>
<a class="indexterm" name="idm46171617432272"></a>
<a class="indexterm" name="idm46171617431168"></a>
<span class="emphasis"><em>-initialize</em></span>
</p>
<p>Used when starting a Receiver Server of an SI replication stream with -updateresync to specify that this is the first connection between the instances. MUPIP ignores these qualifiers when starting BC replication (that is, no updates permitted on the instance with the Receiver Server). This qualifier provides additional protection against inadvertent errors.</p>
<p>
<a class="indexterm" name="idm46171617466128"></a>
<a class="indexterm" name="idm46171617464688"></a>
<span class="emphasis"><em>-resume=&lt;strm_num&gt;</em></span>
</p>
<p>Used when starting a Receiver Server of an SI replication stream with -updateresync in case the receiver instance has previously received from the same source but had only its instance file (not database files) recreated in between (thereby erasing all information about the source instance and the stream number it corresponds to recorded in the receiver instance file). In this case, the command mupip replic -receiv -start -updateresync=&lt;instfile&gt; -resume=&lt;strm_num&gt;, where <span class="emphasis"><em>strm_num</em></span> is a number from 1 to 15, instructs the receiver server to use the database file headers to find out the current stream sequence number of the receiver instance for the stream number specified as &lt;strm_num&gt;, but uses the input instance file (specified with -updateresync) to locate the history record corresponding to this stream sequence number and then exchange history with the source to verify the two instances are in sync before resuming replication. Note that in case -resume is not specified and only -updateresync is specified for a SI replication stream, it uses the input instance file name specified with -updateresync to determine the stream sequence number as well as provide history records to exchange with the source instance (and verify the two are in sync). Assuming that instance files are never recreated (unless they are also accompanied by a database recreate), this qualifier should not be required in normal usage situations.</p>
<p>
<a class="indexterm" name="idm46171617379808"></a>
<a class="indexterm" name="idm46171617378800"></a>
<span class="emphasis"><em>-reuse=&lt;instname&gt;</em></span>
</p>
<p>Used when starting a Receiver Server of an SI replication stream with -updateresync in case the receiver instance has previously received from fifteen (all architecturally allowed) different externally sourced streams and is now starting to receive from yet another source stream. The command mupip replic -receiv -start -updateresync=&lt;instfile&gt; -reuse=&lt;instname&gt;, where <span class="emphasis"><em>instname</em></span> is the name of a replication instance, instructs the receiver server to look for an existing stream in the replication instance file header whose <span class="emphasis"><em>Group Instance Name</em></span> (displayed by a mupip replic -editinstance -show command on the receiver replication instance file) matches the instance name specified and if one does, reuse that stream number for the current source connection (erasing any record of the older Group using the same stream number).</p>
<p><span class="bold"><strong><a name="tls_replication_qualifiers_recv"></a>TLS Replication Qualifiers:</strong></span></p>
<p><span class="emphasis"><em><span>-</span>tlsid=&lt;label&gt;
<a class="indexterm" name="idm46171617373360"></a>
<a class="indexterm" name="idm46171617366304"></a></em></span></p>
<p>Instructs the Source or Receiver Server to use the TLS certificate and private key pairs having &lt;label&gt; as the TLSID in the configuration file pointed to by the gtmcrypt_config environment variable. TLSID is a required parameter if TLS/SSL is to be used to secure replication connection between instances. If private keys are encrypted, an environment variable of the form gtmtls_passwd_&lt;label&gt; specifies their obfuscated password. You can obfuscate passwords using the 'maskpass' utility provided along with the encryption plugin. If you use unencrypted private keys, set the gtmtls_passwd_&lt;label&gt; environment variable to a non-null dummy value; this prevents inappropriate prompting for a password.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="strt_upd_proc"></a>Start<span>ing the</span> Update Process<a class="indexterm" name="idm46171617514032"></a>
</h3></div></div></div>
<p>The following command starts the Update Process only, if it has been
shutdown independent of the Receiver Server.</p>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -receiver -start {-updateonly|-helpers[=m[,n]]</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617364336"></a>
<a class="indexterm" name="idm46171617357344"></a>
<span>-updateonly</span>

</em></span>
</p>
<p>If the Update Process has been shutdown independent of the Receiver
Server, use this qualifier to restart the Update Process.</p>
<p>
<a class="indexterm" name="idm46171617372240"></a>
<a class="indexterm" name="idm46171617407600"></a>
<span class="emphasis"><em>-helpers[=m[,n]]</em></span>
</p>
<p>Starts additional processes to help improve the rate at which updates from an incoming replication stream are applied on a replicating instance.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>m is the total number of helper processes and n is the number of reader helper processes, in other words m&gt;=n.</p></li>
<li class="listitem"><p>Helper processes can start only on a receiver server.</p></li>
<li class="listitem"><p>If helper processes are already running, specifying -helpers[=m[,n]]  again starts additional helper processes. There can be a maximum of 128 helper processes for a receiver server. </p></li>
<li class="listitem"><p> If <span class="emphasis"><em>-helpers</em></span> is not specified, GT.M starts no helper processes.</p></li>
<li class="listitem"><p>With the HELPERS qualifier specified but neither m nor n specified, GT.M starts the default number of helper processes with the default proportion of roles. The default number of aggregate helper processes is 8, of which 5 are reader helpers and 3 writers.</p></li>
<li class="listitem"><p>With only m specified, helper processes are started of which floor(5*m/8) processes are reader helpers.</p></li>
<li class="listitem"><p>With both m and n specified, GT.M starts m helper processes of which n are reader helpers and m-n are writers. If m&lt;n, mupip starts m readers, effectively reducing n to m and starting no writers.</p></li>
<li class="listitem"><p>GT.M reports helper processes (for example, by the ps command and in /proc/&lt;pid&gt;/cmdline on platforms that implement a /proc filesystem) as mupip replicate -updhelper -reader and mupip replicate -updhelper -writer. </p></li>
</ul></div>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -receiver -start -listenport=1234 -helpers -log=B2C.log -buffsize=$recpool_size</pre>
<p>This command starts the Receiver Server with Helper Processes. The following sample output from the ps command shows that there are 5 reader processes and 3 writer processes.</p>
<pre class="programlisting">gtmuser1 11943 1     0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -receiver -start 
-listenport=1234 -helpers -log=B2C.log -buff=$rec_pool_size
gtmuser1 11944 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updateproc
gtmuser1 11945 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -reader
gtmuser1 11946 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -reader
gtmuser1 11947 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -reader
gtmuser1 11948 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -reader
gtmuser1 11949 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -reader
gtmuser1 11950 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -writer
gtmuser1 11951 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -writer
gtmuser1 11952 11943 0 06:42 ? 00:00:00 /usr/library/GTM/mupip replicate -updhelper -writer</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="stop_upd_proc"></a>Stop<span>ping the</span> the Receiver Server and/or the Update Process</h3></div></div></div>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -receiver -shutdown [-helpers | -updateonly] [-timeout=&lt;timeout in seconds&gt;] </pre>
<p>Qualifiers:</p>
<p>
    <span class="emphasis"><em>
      <a class="indexterm" name="idm46171617342320"></a>
      <a class="indexterm" name="idm46171617335072"></a>
      <span>-shutdown</span>
      
    </em></span>
  </p>
<p>Initiates the shutdown procedures of the Receiver Server, Update Process, and/or helper processes. If the Receiver Server previously shut down abnormally, -shutdown can shut down helper processes left running. </p>
<p>
<a class="indexterm" name="idm46171617368176"></a>
<span class="emphasis"><em>-helper</em></span></p>
<p>Shuts down only the Helper Processes and leaves the Receiver Server and Update Process to continue operating as before. All helpers processes shut down even if -helper values are specified.</p>
<p>
<span class="emphasis"><em><span>-</span>timeout</em></span></p>
<p>Specifies the period of time (in seconds) the shutdown command should wait before signaling the Receiver Server, Update Process, and/or helper processes to shut down.If you do not specify -timeout, the default timeout period is 30 seconds. If you specify -timeout=0, shutdown occurs immediately.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617331472"></a>
<a class="indexterm" name="idm46171617324608"></a>
<span>-updateonly</span>

</em></span>
</p>
<p>Use this qualifier to stop only the Update Process. If neither -updateonly nor -helper are specified, the Update Process, all helper processes (if any), and Receiver Server shut down.</p>
<p>Example:</p>
<pre class="programlisting">$ mupip replicate -receiver -shutdown -helper</pre>
<p>This example shuts down only the helper processes of the current Receiver Server. Note that all helpers processes shut down even if HELPER values are specified.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="chk_srvr_hlth"></a>Check<span>ing Server</span>  Health</h3></div></div></div>
<p>Use the following command to determine whether the Receiver Server is running.</p>
<p>Command syntax:</p>
<pre class="programlisting">mupip replicate -receiver -checkhealth [-he[lpers]]</pre>
<p>With helpers specified, -checkhealth displays the status of Helper Processes in addition to the status of Receiver Server and Update Process.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="chng_log"></a><span>Changing the Log File</span>
</h3></div></div></div>
<p>Command syntax:</p>
<a class="indexterm" name="idm46171617362288"></a><a class="indexterm" name="idm46171617481632"></a><pre class="programlisting">mupip replicate -receiver -changelog -log=&lt;log file name&gt; [-log_interval="[integer1],[integer2]"]</pre>
<p>
<a class="indexterm" name="idm46171617358448"></a>
<a class="indexterm" name="idm46171617316656"></a>
<span class="emphasis"><em>-log_interval="[integer1],[integer2]"</em></span>
</p>
<p><span class="emphasis"><em>integer1</em></span> specifies the number of transactions for which the Receiver Server should wait before writing to the log file. <span class="emphasis"><em>integer2</em></span> specifies the number of transactions for which the Update Process should wait before writing to the log file. The default logging interval is 1000 transactions.</p>
<p>If <span class="emphasis"><em>integer1</em></span> or <span class="emphasis"><em>integer2</em></span> is 0, the logging interval reverts to the prior value.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="enable_disable_login"></a><span>Enabling/Disabling Detailed Logging</span>
</h3></div></div></div>
<a class="indexterm" name="idm46171617358192"></a><p>Command syntax:</p>
<pre class="programlisting">mupip replicate -receiver -statslog={ON|OFF} 
 [-log_interval="[integer1],[integer2]"]</pre>
<p>
<a class="indexterm" name="idm46171617348640"></a>
<a class="indexterm" name="idm46171617308048"></a>
<span class="emphasis"><em>-log_interval="[integer1],[integer2]"</em></span>
</p>
<p><span class="emphasis"><em>integer1</em></span> specifies the number of transactions for which the Receiver Server should wait before writing to the log file. <span class="emphasis"><em>integer2</em></span> specifies the number of transactions for which the Update Process should wait before writing to the log file. The default logging interval is 1000 transactions.</p>
<p>If <span class="emphasis"><em>integer1</em></span> or <span class="emphasis"><em>integer2</em></span> is 0, the logging interval reverts to the prior value.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="rep_curr_backlog"></a><span>Reporting the Current Backlog of Journal Records</span>
</h3></div></div></div>
<p>Command syntax:</p>
<a class="indexterm" name="idm46171617330224"></a><pre class="programlisting">mupip replicate -receiver -showbacklog</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<span>-showbacklog</span>

</em></span>
</p>
<p>Use this qualifier to report the current backlog (that is, the difference
between the last JNL_SEQNO written to the Receive Pool and the last JNLSEQNO
processed by the Update Process) of journal records on the Receiver
Server.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="rollback_db_after_sys_fail"></a><span>Rolling Back a Replicated Database </span><a class="indexterm" name="idm46171617349856"></a>
</h3></div></div></div>
<p>Command syntax:</p>
<pre class="programlisting">mupip journal -rollback 
 {[-fetchresync=&lt;port number&gt;|-resync=&lt;JNL_SEQNO&gt;] 
  -[no]losttrans=[/dev/null|&lt;unreplicated_updates.lost&gt;]
 -[no]brokentrans=[/dev/null|&lt;brokentrans.broken&gt;] 
 -[no]online
  [-rsync_strm=&lt;strm_num&gt;]}
 -backward *</pre>
<p>Qualifiers:</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617292640"></a>
<span>-rollback</span>

</em></span>
</p>
<a class="indexterm" name="idm46171617341008"></a><p>Use -FETCHRESYNC or -RESYNC to rollback the database as a recovery step after a system failure or to make a change in the LMS replication configuration. If you do not use -FETCHRESYNC or -RESYNC, 
  the database rolls back to the last consistent state.</p>
<p>
<span class="emphasis"><em><span>-online</span>
</em></span>
</p>
<p>Specifies that ROLLBACK can run without requiring exclusive access to the database and the replication instance file. Any utility/command attempted while MUPIP JOURNAL -ONLINE -ROLLBACK operates waits for ROLLBACK to complete; the $gtm_db_startup_max_wait environment variable configures the wait period. <span>For more information on -ROLLBACK -ONLINE, refer to <a class="xref" href="mup_journal.html#rollback" title="-ROLLBACK [{-ON[LINE]|-NOO[NLINE]}]">&#8220;-ROLLBACK <span>[{-ON[LINE]|-NOO[NLINE]}]</span>

&#8221;</a>. </span></p>
<p>
<span class="emphasis"><em>
<span>-fetchresync</span>

</em></span>
</p>
<p>When there are unreplicated updates on a former primary/secondary instance, it cannot become a new replicating instance as its journal sequence number is higher than the journal sequence number of its new replication source. Use -ROLLBACK -FETCHRESYNC to roll back a BC/SI replicating instance to a journal sequence number that matches the journal sequence number of its replication source and generate a lost transaction file containing the unreplicated updates for the organization to reconcile. After the reconcilation (or rejection as the case may be) of the lost transaction file, run MUPIP REPLICATE -SOURCE -LOSTTNCOMPLETE to provide confirmation to GT.M that you have applied the lost transaction file. For -FETCHRESYNC to work on the replicating instance, you need to ensure that an active Source Server is running on the replication source/originating instance.</p>
<p>The format of the -FETCHRESYNC qualifier is:</p>
<p><code class="code">-fetchresync=&lt;port number&gt; -[no]brokentrans=[/dev/null|&lt;brokentrans.broken&gt;] -[no]losttrans=[/dev/null|&lt;unreplicated_updates.lost&gt;] </code></p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>&lt;portno&gt; is the port number that the Receiver Server uses to listen for incoming connection from the Source Server of the originating instance. </p></li>
<li class="listitem"><p>-LOSTTRANS and -BROKENTRANS allows you to specify the name and location of the lost transaction file and broken transaction file. </p></li>
<li class="listitem"><p>-LOSTTRANS=/dev/null or -NOLOSTTRANS disables lost transaction file processing when there is no need to apply lost transaction files.  </p></li>
<li class="listitem"><p>Remember that unless you have a backup of the database and the journal files, you cannot undo a ROLLBACK/RECOVER operation. </p></li>
<li class="listitem"><p>A lost transaction file may sometimes contain data that is critical for your application. Use -LOSTRANS=/dev/null or -NOLOSTTRANS with ROLLBACK/RECOVER only when you are sure that there is a lost transaction file whose transactions you purposely want to discard from your database.</p></li>
<li class="listitem"><p>Unless business considerations dictate otherwise, your database administration scripts/procedure should allow the organization to intervene when there is a need to apply or discard a lost transaction file. </p></li>
<li class="listitem"><p>If you have broken transactions, they may have appeared due to system failures that occurred during processing. Do not reconcile these transactions as they are not considered to be committed.</p></li>
<li class="listitem"><p>In your Receiver Server startup scripts, FIS recommends placing MUPIP JOURNAL -ROLLBACK -BACKWARD -ONLINE -FETCHRESYNC after starting the passive Source Server but before starting the Receiver Server. </p></li>
<li class="listitem"><p>Stopping a ROLLBACK operation before it completes or losing the TCP connection over which replication operates may corrupt the database file header. To recover, wait  up to 60 seconds for the operation to timeout and then reissue the command.</p></li>
</ul></div>
<p>Example:<a class="indexterm" name="idm46171617276032"></a>
</p>
<p><code class="code">$ mupip journal -rollback -fetchresync=2299 -losttrans="glo.lost" -backward </code></p>
<p>This command performs a ROLLBACK -FETCHRESYNC operation on a replicating instance to bring it to a common synchronization point from where the originating instance can begin to transmit updates to allow it to catch up. It also generates a lost transaction file glo.lost of all those transactions that are present on the replicating instance but not on the originating instance at port 2299.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617273344"></a>
<span>-resync=&lt;JNL_SEQNO&gt;</span>

</em></span>
</p>
<p>Use this qualifier to roll back to the transaction identified by
JNL_SEQNO (in decimal) only when the database/ journal files need to be rolled
back to a specific point. If you specify a JNL_SEQNO that is greater
than the last consistent state, the database/journal files will be rolled
back to the last consistent state. Under normal operating conditions, you
would not need this qualifier.</p>
<p>
<span class="emphasis"><em>
<a class="indexterm" name="idm46171617289664"></a>
<a class="indexterm" name="idm46171617263008"></a>
-rsync_strm=&lt;strm_num&gt;
</em></span>
</p>
<p>Used when starting a rollback command with the -resync qualifier. The command mupip journal -rollback -resync=&lt;sequence_num&gt; -rsync_strm=&lt;strm_num&gt; instructs rollback to roll back the database to a sequence number specified with the -resync=&lt;sequence_num&gt; qualifier but that &lt;sequence_num&gt; is a journal stream sequence number (not a journal sequence number) corresponding to the stream number &lt;strm_num&gt; which can be any value from 0 to 15. Note that like the -resync qualifier, the -rsync_strm qualifier is also intended for use under the direction of your GT.M support channel.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch07s03.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="lkechap.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Procedures </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 8. M Lock Utility (LKE)</td>
</tr>
</table>
</div>
</body>
</html>
