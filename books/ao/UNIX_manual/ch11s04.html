<html>
<HEAD><META HTTP-EQUIV="Pragma" CONTENT="no-cache"><META HTTP-EQUIV="Expires" CONTENT="-1">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Finding and Fixing Database Errors</title>
<link rel="stylesheet" href="gtm.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="GT.M Administration and Operations Guide">
<link rel="up" href="ch11.html" title="Chapter 11. Maintaining Database Integrity">
<link rel="prev" href="ch11s03.html" title="Repairing the Database with DSE">
<link rel="next" href="ch12.html" title="Chapter 12. Database Encryption">
<link rel="copyright" href="ln-idm45451844941952.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Finding and Fixing Database Errors</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch11s03.html">Prev</a> </td>
<th width="60%" align="center">Chapter 11. Maintaining Database Integrity</th>
<td width="20%" align="right"> <a accesskey="n" href="ch12.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">GT.M Administration and Operations Guide</a></span> &gt; <span class="breadcrumb-link"><a href="ch11.html">Maintaining Database Integrity</a></span> &gt; <span class="breadcrumb-node">Finding and Fixing Database Errors</span>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="finding_and_fixing_db_errors"></a>Finding and Fixing Database Errors<a class="indexterm" name="idm45451835465792"></a>
</h2></div></div></div>
<p>The rest of this chapter is arranged loosely in the form of a decision tree. The
material covers a wide range of scenarios and possible actions. </p>
<p>As you begin the decision-making process, follow these general guidelines from
this point:</p>
<p>
<span class="italic">IF THE SYMPTOM IS A FAILURE TO PROCESS,</span> refer
to section <a class="xref" href="ch11s04.html#h1_process_hangs" title="H1&#8211;Process Hangs">&#8220;H1&#8211;Process Hangs&#8221;</a>.</p>
<p>
<span class="italic">IF THE SYMPTOM IS A MUPIP INTEG ERROR REPORT</span>,
refer to section <a class="xref" href="ch11s04.html#i1_mupip_integ_errors" title="I1&#8211;MUPIP INTEG Errors">&#8220;I1&#8211;MUPIP INTEG Errors&#8221;</a>. If you are investigating a particular error message, refer to
the "MUPIP INTEG errors" table in that section. </p>
<p>
<span class="italic">IF THE SYMPTOM IS A GT.M RUN-TIME ERROR REPORT</span>,
refer to section R1. Remember the GT.M Message and Recovery Procedures Manual may provide insights.</p>
<p>To facilitate use of the material as a troubleshooting guide, the text in these
sections refers to other sections with alphanumeric designators. Each alphanumeric
section describes suggested actions to employ in handling a particular
situation.</p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="c1_possible_cache_control_problems"></a>C1&#8211;Possible Cache Control Problems</h3></div></div></div>
<p>When a process detects that a normal cache operating principal has been
violated, or that a cache operation is taking an unexpectedly long time, that
process triggers a cache verification and rebuild. Such events can be caused by
abnormal process termination, or by inappropriately configured or managed
database storage subsystems.</p>
<p>When such an event occurs, GT.M sends a series of messages to the operator
facility describing the results of the cache verification. If the cache rebuild
is successful, no further immediate action is required. If the cache rebuild
fails, the database administrator must close off access to the database and use
DSE (CRIT and WCINIT) and MUPIP (INTEG) to reset the cache manually and verify
that the database is not damaged.</p>
<p>If such events are delivered to the operator facility, you should investigate
whether it is appropriate to modify your procedures to prevent abnormal
termination, to reconfigure your disk subsystem, or to change the nature or
schedule of disk activities so that database access is not disrupted during key
periods of operation.</p>
<p>Also see section <a class="xref" href="ch11s04.html#r2_run_time_db_cache" title="R3&#8211;Run-time Database Cache Problems">&#8220;R3&#8211;Run-time Database Cache Problems&#8221;</a>.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h1_process_hangs"></a>H1&#8211;Process Hangs</h3></div></div></div>
<p>The term "hang" refers to a failure to process. Processes may hang for a
variety of reasons that have nothing to do with GT.M. However, hanging GT.M
processes may indicate that a database has become inaccessible. When you suspect
a hang, first determine the extent of the problem.</p>
<p>Your tools include:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Knowledge of the application and how it is used</p></li>
<li class="listitem"><p>Communication with users</p></li>
<li class="listitem"><p>The ps command and other UNIX system utilities</p></li>
</ul></div>
<p>
<span class="italic">WHEN MANY PROCESSES ON A SYSTEM ARE
HANGING</span>, determine if the hangs are confined to a particular
application. If all applications are affected or if processes not using GT.M
databases are affected, the problem is not a database-specific problem, but
something more general, such as 
<span>a UNIX</span> problem. Refer to section H6.</p>
<p>
<span class="italic">WHEN ONLY ONE PROCESS IS HANGING</span>, find out
whether that process is the only one using a particular GT.M application. If it
is the only process, start some appropriate second process and determine whether
the second process is also affected.</p>
<p>
<span class="italic">IF A PROCESS HANGS WHILE OTHER PROCESSES ACCESSING THE
SAME DATABASE CONTINUE TO PROCESS,</span> the problem is not a database
problem. Refer to section H3 and then to section H8.</p>
<p>
<span class="italic">WHEN ONLY GT.M PROCESSES RUNNING A PARTICULAR
APPLICATION HANG,</span> the problem may be a database problem. Refer to
section H?.</p>
<p>Is the system "hung?" If so, consider the following additional questions:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Does LKE work? If not, then a database has problems (see below).</p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem"><p>Are there locks owned by a nonexistent process? Can they be cleared? What were the circumstances of a process leaving locks?</p></li>
<li class="listitem"><p>Are there locks which are not changing? What is the state of the owning process(es)? If not all processes are hung, can the stalled process(es) be MUPIP STOPped? </p></li>
</ul></div>
</li>
<li class="listitem">
<p>Do MUTEXLCKALERT messages indicate a process is holding the critical section for one or more regions?</p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem"><p>If so, and there are more than one such process, examine the MUTEXLCKALERT messages to see if there is a deadlock cycle. GT.M is designed to prevent such a situation, but you should check. Cycles involve processes owning resources needed by another; typical cycles involve two processes, but can involve more.</p></li>
<li class="listitem"><p>Do any persistant critical section owning processes respond to a MUPIP INTRPT, which may provide important diagnostic information? </p></li>
<li class="listitem"><p>Do any persistant critical section owning processes respond to a MUPIP STOP?</p></li>
<li class="listitem"><p>If critical section owning processes do not resond to a MUPIP STOP but all database activity on the held region(s) is at standstill, does one or more respond to a kill -9? FIS does not recommend using a kill -9 on a process that is currently performing, or may perform database updates; however in this case you have determined all activity has stopped.</p></li>
<li class="listitem"><p>If the MUPIP STOP or unmentionalble alternative just makes another process assume control of the critical sections without eliminating the hang, you can try a CRIT <span>-</span>INIT <span>-</span>RESET</p></li>
<li class="listitem"><p>Does a CRIT <span>-</span>INIT <span>-</span>RESET free the critical section or just change who owns it? </p></li>
<li class="listitem"><p>If CRIT <span>-</span>INIT <span>-</span>RESET doesn't free the problem, the global buffer pool management is damaged.</p></li>
</ul></div>
</li>
</ul></div>
<p>The following is another way of testing the cache: If CRIT is cleared and DSE
BUFFER hangs, management of the global buffer pool is not working properly. Use MUPIP STOP and/or CRIT <span>-</span>INIT <span>-</span>RESET to get everyone out of the
segment, then use DSE WCINIT. After a WCINIT, make sure that you can
successfully exit from DSE. Use MUPIP INTEG (<span>-</span>FAST) to check for damage which can be induced by
WCINIT.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h3_db_access_problems"></a>H3&#8211;Database Access Problems</h3></div></div></div>
<p>Use the following diagnostic steps and references to determine an appropriate
course of action for database access problems.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Determine if the disk volume is inaccessible.</p>
<p>Use 
<span>the
UNIX ls utility</span> to display information retrieved from the
volume. If the volume is not accessible to 
<span>UNIX</span>, the problem is not
a database problem. Refer to section H7.</p>
</li>
<li class="listitem">
<p>Determine whether 
<span>UNIX</span> can write to the 
<span>disk</span>.</p>
<p>Use a shell command such as mv or cp. If UNIX cannot write
to the volume, the problem is not a database problem. Refer to section
H7.</p>
</li>
<li class="listitem">
<p>Determine whether any database file used by the application has "Cache
Freeze" set.</p>
<p>Use DSE FIND <span>-</span>REGION=region and DUMP <span>-</span>FILEHEADER to verify that CACHE FREEZE is zero
(00000000) for any hung region(s).</p>
<p>If CACHE FREEZE shows a PID, that process used MUPIP or DSE to FREEZE
the database. In this case, investigate whether the process is currently
producing the desired results. If the FREEZE is legitimate, do whatever
is appropriate to speed up the process using FREEZE. For example,

<span> use the NICE command</span>. If the
process still exists, but should not be running at this time, stop it.
If CACHE FREEZE is non-zero but not in use to protect the database, use
DSE FIND <span>-</span>REGION=region and CHANGE <span>-</span>FILEHEAD <span>-</span>FREEZE=FALSE to clear the FREEZE state.</p>
<p>Use the DSE commands FIND <span>-</span>REGION and DUMP <span>-</span>FILEHEADER. If any region is frozen, determine
who initiated the freeze, and whether the process should be terminated
or allowed to complete. The following actions freeze databases:</p>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem"><p>DSE CHANGE <span>-</span>FILEHEADER <span>-</span>FREEZE=TRUE</p></li>
<li class="listitem"><p>DSE ALL <span>-</span>FREEZE</p></li>
<li class="listitem"><p>MUPIP BACKUP <span>-</span>NOONLINE</p></li>
<li class="listitem"><p>MUPIP FREEZE</p></li>
<li class="listitem"><p>MUPIP INTEG <span>-</span>REGION</p></li>
<li class="listitem"><p>MUPIP EXTRACT <span>-</span>FREEZE</p></li>
</ul></div>
<p>
</p>
<p>DSE CHANGE <span>-</span>FILEHEADER <span>-</span>FREEZE=FALSE and MUPIP FREEZE <span>-</span>OFF clear a freeze. However,
when used with <span>-</span>OVERRIDE, these commands may cause damage to the results of
the process that initiated the freeze. After the freeze is cleared,
re-examine the entire situation.</p>
</li>
<li class="listitem">
<p>Determine whether the database files used by the application are
accessible for reading.</p>
<p>Use an M function such as $DATA() or $ORDER().</p>
</li>
<li class="listitem">
<p>Determine whether the database files used by the application are
accessible for writing.</p>
<p>SET a node a safe dummy node in each database and then KILL it if appropriate. Alternatively make a harmless modification to an existing node, or modify a node and then change it back to its original value. GT.M detects when a SET makes no actual change (the SET value is the same as the original value) and does not perform an actual update in that case.</p>
</li>
</ul></div>
<p>
<span class="italic">IF THE DATA CAN BE BOTH READ AND WRITTEN,</span>
the problem is not a database problem. Refer to section H8.</p>
<p>
<span class="italic">IF DATA CANNOT BE READ OR WRITTEN,</span> some
process is unable to release full ownership of the database critical section.
Determine the process identification number (PID) of the process using the DSE
command CRITICAL. If the process exists, refer to section H4. If the process is
non-existent, use DSE CRITICAL <span>-</span>REMOVE to emulate a release and re-examine the entire
situation.</p>
<p>Example:</p>
<pre class="programlisting">
 Set pipe="pipe"
 Open pipe:(command="/bin/csh")::pipe
 Use pipe
 Set reg="",cmd=$ztrnlnm("gtm_dist")_"/mupip dumpfhead "
 For  Set reg=$View("GVNEXT",reg) Quit:""=reg  Do
 . Set reg(reg)="",file=$view("GVFILE",reg)
 . Write cmd,file,!
 . For i=1:1 read x(i):1 Quit:(x(i)["sgmnt_data.freeze")!$ZEOF!'$Test
 . Set pid=+$Piece(x(i),"=",2)
 . Set:pid frozen(reg)=pid
 Close pipe
 Set g="^%",$etrap="Write $ZStatus Set $ecode="""" Quit"
 Write !,"Attempting read access"
 If $Data(^%) Set reg=$View("REGION",g) Do read1
 For  Set g=$Order(@g) Quit:""=g  Set reg=$View("REGION",g)  Do:""=(reg(reg)) read1
 Set reg=""
 Write !!,"Attempting write access"
 For  Set reg=$Order(reg(reg)) Quit:""=reg  Do write1
 Write !
 Quit
read1
 Write !,"Read in region: ",reg," of ",g," successful"
 If ($Data(@g)#2) Set reg(reg)=g
 Else  Set reg(reg)=$Query(@g)
 Quit
write1
 If $Data(frozen(reg)) Write !,"Region ",reg," Frozen by PID ",frozen(reg) Quit
 If ""=reg(reg) Write !,"Region ",reg," has no data" Quit
 Write !,"Write to region: ",reg
 Set x=$Get(@reg(reg),"Yndef")
 Set @reg(reg)=1,@reg(reg)=x
 If "Yndef"=x ZKill @ref(ref); assumption that a value of Yndef is very unlikely
 Write " of ",reg(reg)," successful"
 Quit</pre>
<p>This routine provides a generalized approach to automating some of the tasks
described in this section. The routine issues a report if a region is frozen or completely empty of data. It may hang reading or writing
a database. However, unless the region(s) holding ^% and the next global after
^% has a problem, it displays the name of the region that it is about to try. If
this routine runs to completion, the databases in the current Global Directory
are completely accessible. The routine can be extended by having it cycle through a set of Global Directories should that be appropriate.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.jpg"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>If you have a Global Directory mapping globals to multiple files, you may create an alternative Global Directory using different mappings to those same files. Such mapping prevents the test program(s) from touching the 
"real" data.</p></td></tr>
</table></div>
<p>Example:</p>
<pre class="programlisting">  Mapping      Production region   Test region
-----------------------------------------------
A   to   M     $DEFAULT            SCRATCH
N   to   Z     SCRATCH             $DEFAULT</pre>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h4_database_cache_problms"></a>H4&#8211;Database Cache Problems</h3></div></div></div>
<p>To increase the access speed, GT.M buffers data exchanged between processes
and database files in the shared memory cache. If information in the memory
cache is damaged, it can block the transfer of data to the disk.</p>
<p>
<span class="italic">IF A PROCESS HAS BEEN DETERMINED (FROM SECTION H3) TO
NEVER RELEASE FULL OWNERSHIP OF THE DATABASE CRITICAL SECTION,</span>
there may be a problem with the database cache. To determine where the problem
is occurring terminate the process. If this clears the hang, the problem was not
in the database but in the process, which was somehow damaged. Refer to section
P1. Otherwise, another process showing the same symptoms takes the place of the
terminated process. In this case, the cache is damaged.</p>
<p>
<span class="italic">IF THE CACHE IS DAMAGED,</span> it must be
reinitialized. It is crucial to stop all other database activity during cache
initialization. Refer to section Q1 before continuing with this section.</p>
<p>To minimize database damage due to cache reinitialization, and to confirm that
the problem is due to a damaged cache, use the DSE command CRITICAL SEIZE
followed by BUFFER_FLUSH. The DSE command BUFFER_FLUSH attempts to flush the
database cache which is a benign operation. Wait at least one minute for this
operation to complete.</p>
<p>
<span class="italic">IF THE BUFFER_FLUSH DOES NOT HANG,</span> the
cache is not damaged, and you should review all previous steps starting with
section H1. </p>
<p>
<span class="italic">IF THE BUFFER_FLUSH DOES HANG,</span> use the DSE
command WCINIT to reinitialize the cache. This command requires confirmation.
Never use WCINIT on a properly operating database. After a WCINIT always perform
at least a MUPIP INTEG FAST to detect any induced damage that has a danger of
spreading. If the WCINIT command hangs, clear the critical section as described
in section H5 and reissue the WCINIT.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h5_critical_section_problems"></a>H5&#8211;Critical Section Problems</h3></div></div></div>
<p>The concurrency control mechanism allows only one process at a time to execute
code within a "critical section." To gain access to the database requires a
process to first gain ownership of the critical section. The errors described in
this section occur when a problem occurs in ownership control of the critical
section.</p>
<p>
<span class="italic">IF YOU HAVE DETERMINED WHICH PROCESS IS HOLDING THE
CRITICAL SECTION</span> (from section H2 using system utilities), try
terminating that process. If this corrects the problem, the damage was to the
process, rather than the critical section. Refer to section P1. </p>
<p>
<span class="italic">IF YOU CANNOT IDENTIFY THE PROCESS</span>, or if
terminating such a process causes other processes to exhibit the same
problem(s), the critical section is damaged and must be reinitialized. Restrict
database activity during the reinitialization. Refer to section Q1 before
continuing with this section.</p>
<p>
<span class="italic">TO REINITIALIZE THE DATABASE CRITICAL SECTION:
</span> Reinitializing a critical section on an active database file carries
some risk of causing database damage. You can minimize this risk by restricting
database activity during the reinitialization. Refer to section Q1 before
continuing with this section.</p>
<p>The DSE command CRITICAL INITIALIZE RESET re-establishes the database-critical
section and induces errors for all processes currently accessing the database in
question. You can avoid the induced errors in other processes by dropping the
RESET qualifier. However, this technique may result in other processes
attempting to use partially created critical section structures, possibly
corrupting them or the database contents.</p>
<p>After the CRITICAL INITIALIZE, use the DSE commands CRITICAL SEIZE and
CRITICAL RELEASE to verify operation of the critical section. Actions such as
those described in section H3 test more thoroughly for proper operation. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h6_Unix_problems"></a>H6&#8211;UNIX Problems</h3></div></div></div>
<p>
<span class="italic">IF YOU HAVE DETERMINED THAT MANY PROCESSES IN THE UNIX
ENVIRONMENT ARE PERFORMING BADLY,</span> some processes may be using
priorities to "hijack" the system. If this is the case, review why priorities
are being adjusted and take appropriate action. Otherwise, you may have a
UNIX-related problem.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h7_disk_hardware_problems"></a>H7&#8211;Disk Hardware Problems</h3></div></div></div>
<p>
<span class="italic">IF YOU HAVE DETERMINED THAT A DISK VOLUME IS
INACCESSIBLE TO UNIX FOR READ AND/OR WRITE,</span> use the df command to
check that the correct volume is properly mounted. If the volume cannot be
written, examine the physical device to see whether write lock switches or plugs
have been disturbed.</p>
<p>
<span class="italic">IF YOU CANNOT LOCATE THE PROBLEM,</span> run disk
diagnostics. Be aware that many disk diagnostics are destructive (that is, destroy
your files). Avoid these diagnostics until you have exhausted all other avenues.
If you have to run destructive disk diagnostics, or you determine that a disk
spindle must be replaced, start planning for the recovery immediately.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="h8_application_problems"></a>H8&#8211;Application Problems</h3></div></div></div>
<p>Application problems may be caused by conflicting M LOCKs or OPEN commands in
more than one process, or by a process waiting for completion of M READ or JOB
command, which is dependent on an asynchronous event.</p>
<p>First, determine if processes are waiting, without relief, for M LOCKs using
the LKE command SHOW ALL WAITING. M routines use LOCK commands to create mutual
exclusion semaphores. </p>
<p>
<span class="italic">IF THE SHOW COMMAND HANGS,</span> you have a cache
or critical section problem. Restart your evaluation in section H5.</p>
<p>
<span class="italic">IF THE SHOW COMMAND DISPLAYS NO LOCKS
WAITING,</span> the problem is not a LOCK problem. If repeated use of
SHOW does not display the one or more LOCKs that persist every time, the problem
is not a LOCK problem. However, even if the problem is not a lock problem,
continue with this section because it discusses the M commands JOB, OPEN, and
READ, which may also produce hangs.</p>
<p>A LOCK identified as belonging to a non-existent process results from an
abnormal process termination. GT.M automatically clears such LOCKs when some
other process requests a conflicting LOCK. </p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="persistent_locks"></a>Persistent LOCKs</h4></div></div></div>
<p>Persistent LOCKs belonging to currently existing processes are best
released by terminating those processes. Using the LKE command CLEAR with
various qualifiers can clear LOCKs, but may cause the routines using the
LOCKs to produce inappropriate results. For more information on LKE, refer
to the "M LOCK Utility" chapter.</p>
<p>The two most common reasons for persistent LOCKs are deadlocks and LOCKS
held during operations that take indeterminate amounts of time.</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="deadlocks"></a>Deadlocks</h4></div></div></div>
<p>Deadlocks occur when two or more processes own resources and are trying to
add ownership of an additional resource already owned by another of the
deadlocked processes.</p>
<p>Example:</p>
<pre class="programlisting">Process 1       Process 2
---------       --------- 
LOCK ^A         LOCK ^B
LOCK +^B        LOCK +^A</pre>
<p>This shows a sequence in which Process 1 owns ^A and Process 2 owns ^B.
Each process is trying to get the resource owned by the other, while
"refusing" to release the resource it owns.</p>
<p>Example:</p>
<pre class="programlisting">Process 1       Process 2        Process 3
---------       ---------        --------- 
LOCK ^A         LOCK ^B          LOCK ^C
LOCK +^B        LOCK +^C         LOCK +^A</pre>
<p>This is similar to the previous example, except that it involves three
processes. When an application uses LOCKs in a complex fashion, deadlocks
may involve many processes.</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="prevention_of_a_deadlock"></a>Preventing Deadlocks</h4></div></div></div>
<p>You can prevent deadlocks by using timeouts on the LOCK commands. Timeouts
allow the program to recognize a deadlock. Once a routine detects a
deadlock, it should release its LOCKs and restart execution from the
beginning of the code that accumulates LOCKs. Without timeouts, there is no
way in M to break a deadlock. You must use outside intervention to terminate
at least one deadlocked process, or use LKE to strip a LOCK from such a
process.</p>
<p>Example:</p>
<pre class="programlisting"> for  quit:$$NEW
 quit
NEW()  lock ^X(0)
 set ^X(0)=^X(0)+1
 quit $$STORE(^X(0))
STORE(x)
 lock +^X(x):10 if  set ^X(x)=name_"^"_bal
 lock
 quit $TEST</pre>
<p>This uses a timeout on the LOCK of ^X(x) to cause a retry of NEW.</p>
<p>In addition to the LOCK command, the M JOB, OPEN, and READ commands can
contribute to deadlocks.</p>
<p>Example:</p>
<pre class="programlisting">Process 1         Process 2
---------         --------- 
LOCK ^A
                  OPEN "MSA0:"
                  OPEN "/dev/nrst0"
OPEN "MSA0:"
OPEN "/dev/nrst0"
                  LOCK +^A
</pre>
<p>This shows a sequence in which Process 1 owns ^A and Process 2
owns device /dev/nrst0. Again, each is trying to get the resource held by
the other. Notice that the LOCK commands could be replaced by OPEN commands
specifying some non-shared device other than /dev/nrst0.</p>
<p>An application may combine the technique of timeouts on "long" commands to
protect the current process, with the technique of minimizing LOCK and OPEN
durations, to minimize conflicts with other processes.</p>
<p>Another type of application hanging occurs when a process acquires
ownership of a resource and then starts an operation that does not complete
for a long period of time. Other processes that need the unavailable
resource(s) then hang.</p>
<p>Example:</p>
<pre class="programlisting">Process 1         Process 2
---------         --------- 
LOCK ^A
READ x
                  LOCK ^A</pre>
<p>If the READ by Process 1 is to an interactive terminal, and the operator
has abandoned that device, the READ may take what seems, at least to Process
2, forever. The M commands OPEN and JOB, as well as READ, can produce this
problem. When this situation arises, take action to get long-running
commands completed or to terminate the process performing those
commands.</p>
<p>There are two programming solutions that help avoid these situations. You
can either limit the duration of those commands with timeouts, or defer
resource ownership until any long operations are complete.</p>
<p>Example:</p>
<pre class="programlisting">
 for  quit:$$UPD
 quit
UPD()  set x=^ACCT(acct)
 do EDITACCT
 lock ^ACCT(acct) 
 if x=^ACCT(acct) set ^ACCT(acct)=y
 else  write !,"Update conflict&#8211;Please Reenter"
 lock
 QUIT $TEST</pre>
<p>This stores the contents of ^ACCT(acct) in local variable x, before the
interactive editing performed by sub-routine EDITACCT (not shown). When the
interaction is complete, it LOCKs the resource name and tests whether
^ACCT(acct) has been changed by some other process. If not, it updates the
global variable. Otherwise, it informs the user and restarts UPD. This
technique eliminates the "open update" problem, but it introduces the
possibility the user may have to re-enter work. An application that needs to
minimize the possibility of re-entry may extend this technique by testing
individual fields (pieces) for conflicting changes.</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i1_mupip_integ_errors"></a>I1&#8211;MUPIP INTEG Errors</h3></div></div></div>
<p>Database errors reported by MUPIP INTEG differ in impact and severity. Some
require an immediate action to prevent extending the damage. Action on other
less severe errors may be delayed.</p>
<p>The next section provides general guidelines for determining your next course
of action and a table with information related to the error messages you may
encounter.</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="evaluate_danger_level"></a>Evaluating the Danger Level of a Database Problem</h4></div></div></div>
<p>If you encounter an anomaly in your database or its operations, the
following list may offer some help in determining your next course of
action. The heading of each section indicates the level of urgency FIS attributes to those items listed below it.</p>
<div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="requires_immed_attention"></a>Requires Immediate Attention</h5></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Block incorrectly marked free errors are very serious and lead
to accelerating damage. They degenerate into block
doubly-allocated errors, which are also very dangerous. A
database with these errors should be closed immediately for
repairs.</p></li>
<li class="listitem"><p>Any (structural) error in an index block is dangerous and
should be repaired as soon as possible. </p></li>
</ul></div>
<p>Repairs for such errors should also be performed on a database that
has been closed to normal activity. The need for both of these actions
occurring quickly arises from the likelihood of the bad index being
used. Only if your knowledge of the application allows you to predict
that a damaged area is used exclusively by restricted functions which
are not active (e.g., monthly processing or purges) should you defer
repairs.</p>
</div>
<div class="sect4">
<div class="titlepage"><div><div><h5 class="title">
<a name="can_be_deferred"></a>Can Be Deferred</h5></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Any (structural) error in a data block (level 0) does not pose
a threat of accelerating damage. However, level 0 errors may
cause errors or unreliable behavior in the application.</p></li>
<li class="listitem"><p>Block "incorrectly marked busy" errors only result in database
space becoming unavailable until the errors are corrected. An
index block error generates incorrectly marked busy errors,
because INTEG cannot process the descendants of the damaged
index. Therefore, incorrectly marked busy errors should be
corrected only after all other errors, except for bitmap errors,
are corrected.</p></li>
<li class="listitem"><p>Any bitmap errors flag not only the incorrectly marked block,
but also the associated bitmap, and sometimes the master map.
Therefore, local and master map errors should be corrected only
after all bitmap marked busy or free errors are
corrected.</p></li>
<li class="listitem"><p>Transaction number errors usually impact only incremental and
online backups.</p></li>
<li class="listitem"><p>File size errors can misdirect MUPIP but do not cause the GT.M
run-time system to generate further errors. An exception is
auto-extend, which may not work properly if there are file size
errors.</p></li>
<li class="listitem"><p>Reference count errors and free block errors are informational
only.</p></li>
</ul></div>
</div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="MUPIP_INTEG_Error_Classification_Table"></a>MUPIP INTEG Error Classification Table</h3></div></div></div>
<p>The following list of INTEG messages classifies error severity using the "nature" codes, and refers you to a section identifying an appropriate follow-up action. </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p><span class="emphasis"><em>A-Access</em></span>: prevents database access - these indicate an operational error or a fundamental file damage that prevents INTEG from providing more information. </p></li>
<li class="listitem"><p><span class="emphasis"><em>B-Benign</em></span>: presents no risk of additional damage and has little or no effect on database performance; many bit map errors come under this nature code, but "incorrectly marked free errors" are dangerous.</p></li>
<li class="listitem"><p><span class="emphasis"><em>D-Dangerous</em></span>: presents a high risk in the sense that  continuing updates may cause significant additional damage</p></li>
<li class="listitem"><p><span class="emphasis"><em>I-Index</em></span>: if the block is an index block, continuing updates will be very dangerous: INTEG reports such errors with a nature of DANGER; if the block is a data block, reported by INTEG with a nature of DATA, continuing updates can only cause limited additional damage, but some data may be lost, become inaccessible, or cause processes to inappropriately loop </p></li>
<li class="listitem"><p><span class="emphasis"><em>S-Spanning</em></span>: prevents access to a block spanning node value; INTEG reports these with a nature of DATA </p></li>
<li class="listitem"><p><span class="emphasis"><em>T-Transient</em></span>: usually cleared by an update to the database or possibly a straightforward operator action</p></li>
</ul></div>
<p>INTEG reports these codes for many of the errors and in so doing transforms Index errors on index block to DANGER and otherwise to Data, meaning the issue is confined to a level 0 data block, and so very localized. However, when an index block has damage, GT.M cannot correctly navigate the tree and if operations continue, subsequent updates can go where they do not belong, causing increasing damage. When a data block has damage, the worst thing that can happen from a GT.M standpoint is that you get an indefinite loop. More commonly, some confined set of nodes becomes inaccessible, which may or may not be important from an application perspective, most commonly the application gets an error when it tries to use the data in question. It is possible for a single issue to cause multiple reports, and, in such a case, focus first on the most serious report.</p>
<p>Repair Dangerous and Access errors immediately. You may assess the benefits of deferring correction of less severe errors until normally scheduled down-time.</p>
<div class="informaltable"><table width="100%" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="4">
<p>MUPIP INTEG Error Messages</p>
</th></tr>
<tr>
<th>
<p>NATURE</p>
</th>
<th>
<p>MNEMONIC</p>
</th>
<th>
<p>ERROR MESSAGE</p>
</th>
<th>
<p>SECTION </p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>T</p>
<p>B</p>
<p>I</p>
<p>I</p>
<p>D</p>
</td>
<td>
<p>BUFFLUFAILED</p>
<p>DBBADFREEBLKCTR</p>
<p>DBBADKYNM</p>
<p>DBBADNSUB</p>
<p>DBBADPNTR</p>
</td>
<td>
<p>Error flushing buffers from rrrr for database file ffff.</p>
<p>Free blocks counter in file header: nnnn appears incorrect, should be mmmm.</p>
<p>Bad key name.</p>
<p>Bad numeric subscript.</p>
<p>Bad pointer value in directory.</p>
</td>
<td>
<p>I7</p>
<p>I3</p>
<p>K1</p>
<p>K1</p>
<p>K4</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
</td>
<td>
<p>DBBDBALLOC</p>
<p>DBBFSTAT</p>
<p>DBBNPNTR</p>
<p>DBBPLMGT2K</p>
<p>DBBPLMLT512</p>
</td>
<td>
<p>Block doubly allocated.</p>
<p>Block busy/free status unknown (local bitmap corrupted).</p>
<p>Bit map block number as pointer.</p>
<p>Blocks per local map is greater than 2K.</p>
<p>Blocks per local map is less than 512.</p>
</td>
<td>
<p>K3</p>
<p>M1</p>
<p>K4</p>
<p>I3</p>
<p>I3</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
<p>I</p>
<p>I</p>
<p>A</p>
<p>T</p>
</td>
<td>
<p>DBBPLNOT512</p>
<p>DBBSIZMN</p>
<p>DBBSIZMX</p>
<p>DBBSIZZRO</p>
<p>DBBTUWRNG</p>
</td>
<td>
<p>Blocks per local map is not a multiple of 512.</p>
<p>Block too small.</p>
<p>Block larger than file block size.</p>
<p>Block size equals zero.</p>
<p>The blocks-to-upgrade file-header field is incorrect. Expected nnnn, found mmmm.</p>
</td>
<td>
<p>I3</p>
<p>O1</p>
<p>O1</p>
<p>I3</p>
<p>H2</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
<p>I</p>
<p>I</p>
<p>A</p>
<p>I</p>
</td>
<td>
<p>DBCMPBAD</p>
<p>DBCMPNZRO</p>
<p>DBCOMPTOOLRG</p>
<p>DBCREINCOMP</p>
<p>DBDATAMX</p>
</td>
<td>
<p>Compression count not maximal.</p>
<p>First record of block has nonzero compression count.</p>
<p>Record has too large compression count.</p>
<p>Header indicates database file creation was interrupted before completion.</p>
<p>Record too large.</p>
</td>
<td>
<p>K6</p>
<p>O1</p>
<p>O2</p>
<p>I3</p>
<p>O2</p>
</td>
</tr>
<tr>
<td>
<p>T</p>
<p>A</p>
<p>D</p>
<p>A</p>
<p>I</p>
</td>
<td>
<p>DBFGTBC</p>
<p>DBFLCORRP</p>
<p>DBFSTBC</p>
<p>DBFSTHEAD</p>
<p>DBGTDBMAX</p>
</td>
<td>
<p>File size larger than block count would indicate.</p>
<p>Header indicates database file is corrupt.</p>
<p>File size smaller than block count would indicate.</p>
<p>File smaller than database header.</p>
<p>Key larger than database maximum.</p>
</td>
<td>
<p>I4</p>
<p>I8</p>
<p>I4</p>
<p>I3</p>
<p>K7</p>
</td>
</tr>
<tr>
<td>
<p>A</p>
<p>D</p>
<p>A</p>
<p>I</p>
<p>I</p>
</td>
<td>
<p>DBHEADINV</p>
<p>DBINCLVL</p>
<p>DBINCRVER</p>
<p>DBINVGBL</p>
<p>DBKEYGTIND</p>
</td>
<td>
<p>Header size not valid for database.</p>
<p>Block at incorrect level.</p>
<p>Incorrect version of GT.M database.</p>
<p>Invalid mixing of global names.</p>
<p>Key greater than index key.</p>
</td>
<td>
<p>I3</p>
<p>O1</p>
<p>I2</p>
<p>K3</p>
<p>K2</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
<p>I</p>
<p>I</p>
<p>I</p>
<p>B</p>
</td>
<td>
<p>DBKEYMN</p>
<p>DBKEYMX</p>
<p>DBKEYORD</p>
<p>DBKGTALLW</p>
<p>DBLOCMBINC</p>
</td>
<td>
<p>Key too short.</p>
<p>Key too long.</p>
<p>Keys out of order.</p>
<p>Key larger than maximum allowed length.</p>
<p>Local bit map incorrect.</p>
</td>
<td>
<p>K1</p>
<p>K1</p>
<p>K2</p>
<p>K1</p>
<p>M2</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
<p>I</p>
<p>B</p>
<p>I</p>
<p>B</p>
</td>
<td>
<p>DBLRCINVSZ</p>
<p>DBLTSIBL</p>
<p>DBLVLINC</p>
<p>DBMAXNRSUBS</p>
<p>DBMBMINCFRE</p>
</td>
<td>
<p>Last record of block has invalid size.</p>
<p>Keys less than sibling's index key.</p>
<p>Local bitmap block level incorrect.</p>
<p>Maximum number of subscripts exceeded.</p>
<p>Master bit map incorrectly asserts this local map has free space.</p>
</td>
<td>
<p>K5</p>
<p>K2</p>
<p>M1</p>
<p>K1</p>
<p>M1</p>
</td>
</tr>
<tr>
<td>
<p>B</p>
<p>B</p>
<p>B</p>
<p>B</p>
<p>B</p>
</td>
<td>
<p>DBMBPFLDIS</p>
<p>DBMBPFLDLBM</p>
<p>DBMBPFLINT</p>
<p>DBMBPFRDLBM</p>
<p>DBMBPFRINT</p>
</td>
<td>
<p>Master bit map shows this map full, in disagreement with both disk and INTEG result.</p>
<p>Master bit map shows this map full, agreeing with disk local map.</p>
<p>Master bit map shows this map full, agreeing with MUPIP INTEG.</p>
<p>Master bit map shows this map has space, agreeing with disk local map.</p>
<p>Master bit map shows this map has space, agreeing with MUPIP INTEG.</p>
</td>
<td>
<p>M1</p>
<p>M1</p>
<p>M1</p>
<p>M1</p>
<p>M1</p>
</td>
</tr>
<tr>
<td>
<p>B</p>
<p>B</p>
<p>B</p>
<p>T</p>
<p>B</p>
</td>
<td>
<p>DBMBPINCFL</p>
<p>DBMBSIZMN</p>
<p>DBMBSIZMX</p>
<p>DBMBTNSIZMX</p>
<p>DBMRKBUSY</p>
</td>
<td>
<p>Master bit map incorrectly marks this local map full.</p>
<p>Map block too small.</p>
<p>Map block too large.</p>
<p>Map block transaction number too large.</p>
<p>Block incorrectly marked busy.</p>
</td>
<td>
<p>M1</p>
<p>M2</p>
<p>M2</p>
<p>I6</p>
<p>M1</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
<p>B</p>
<p>A</p>
<p>A</p>
<p>A</p>
</td>
<td>
<p>DBMRKFREE</p>
<p>DBNONUMSUBS</p>
<p>DBNOREGION</p>
<p>DBNOTGDS</p>
<p>DBNOTMLTP</p>
</td>
<td>
<p>Block incorrectly marked free.</p>
<p>Key contains a numeric form of subscript in a global defined to collate all subscripts as strings.</p>
<p>None of the database regions accessible.</p>
<p>Unrecognized database file format.</p>
<p>Block size not a multiple of 512 bytes.</p>
</td>
<td>
<p>M1</p>
<p>K1</p>
<p>I6</p>
<p>I3</p>
<p>K1</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
<p>D</p>
<p>D</p>
<p>D</p>
<p>D</p>
</td>
<td>
<p>DBNULCOL</p>
<p>DBPTRMX</p>
<p>DBPTRNOTPOS</p>
<p>DBRBNLBMN</p>
<p>DBRBNNEG</p>
</td>
<td>
<p>NULL collation representation differs from the database file header setting.</p>
<p>Block pointer larger than file maximum.</p>
<p>Block pointer negative.</p>
<p>Root block number is a local bit tmap number.</p>
<p>Root block number negative.</p>
</td>
<td>
<p>K1</p>
<p>K4</p>
<p>K4</p>
<p>K4</p>
<p>K4</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
<p>T</p>
<p>D</p>
<p>D</p>
<p>D</p>
</td>
<td>
<p>DBRBNTOOLRG</p>
<p>DBRDONLY</p>
<p>DBREADBM</p>
<p>DBRLEVLTONE</p>
<p>DBRLEVTOOHI</p>
</td>
<td>
<p>Root block number greater than last block number in file.</p>
<p>Database file ffff read only.</p>
<p>Read error on bit map.</p>
<p>Root level less than one.</p>
<p>Root level higher than maximum.</p>
</td>
<td>
<p>K4</p>
<p>I6</p>
<p>H7</p>
<p>O1</p>
<p>O1</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
<p>I</p>
<p>S</p>
<p>S</p>
<p>D</p>
</td>
<td>
<p>DBRSIZMN</p>
<p>DBRSIZMX</p>
<p>DBSPANCHUNKORD</p>
<p>DBSPANGLOINCMP</p>
<p>DBSTARCMP</p>
</td>
<td>
<p>Physical record too small.</p>
<p>Physical record too large.</p>
<p>Chunk of nnnn blocks is out of order.</p>
<p>Spanning node is missing. Block no nnnn of spanning node is missing.</p>
<p>Last record of block has nonzero compression count.</p>
</td>
<td>
<p>O2</p>
<p>O2</p>
<p>O5</p>
<p>O5</p>
<p>K5</p>
</td>
</tr>
<tr>
<td>
<p>A</p>
<p>A</p>
<p>T</p>
<p>T</p>
<p>T</p>
</td>
<td>
<p>DBSVBNMIN</p>
<p>DBSZGT64K</p>
<p>DBTNLTCTN</p>
<p>DBTNNEQ</p>
<p>DBTNRESET</p>
</td>
<td>
<p>Start VBN smaller than possible.</p>
<p>Block size is greater than 64K.</p>
<p>Current tn and early tn are not equal.</p>
<p>Cannot reset transaction number for this region.</p>
<p>Transaction numbers greater than the current transaction were found.</p>
</td>
<td>
<p>I3</p>
<p>I4</p>
<p>I6</p>
<p>I4</p>
<p>I6</p>
</td>
</tr>
<tr>
<td>
<p>A</p>
<p>T</p>
<p>A</p>
<p>A</p>
<p>A</p>
</td>
<td>
<p>DBTNTOOLG</p>
<p>DBTTLBLK0</p>
<p>DBUNDACCMT</p>
<p>FREEZE</p>
<p>MUSTANDALONE</p>
</td>
<td>
<p>Total blocks equal zero.</p>
<p>Block transaction number too large.</p>
<p>Cannot determine access method; trying with BG.</p>
<p>Database for region rrrr is already frozen, not INTEGing</p>
<p>Could not get exclusive access to rrrr.</p>
</td>
<td>
<p>I6</p>
<p>I6</p>
<p>I6</p>
<p>I6</p>
<p>I6</p>
</td>
</tr>
<tr>
<td>
<p>B</p>
<p>I</p>
<p>A</p>
</td>
<td>
<p>NOGTCMDB</p>
<p>NULSUBSC</p>
<p>REGFILENOTFOUND</p>
</td>
<td>
<p>INTEG does not support operation on GT.CM database region.</p>
<p>Null subscripts are not allowed for database file: rrrr.</p>
<p>Database file ffff corresponding to region rrrr cannot be found.</p>
</td>
<td>
<p>I5</p>
<p>K1</p>
<p>I6</p>
</td>
</tr>
</tbody>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="gtm_version_mismatch_chi2"></a>I2&#8211;GT.M Version Mismatch</h3></div></div></div>
<p>GT.M databases and Global Directories may change with new releases of the
product.</p>
<p>
<span class="italic">IF YOU GET AN ERROR INDICATING A VERSION
MISMATCH,</span> first identify the GT.M version using the M command
WRITE $ZVERSION from Direct Mode.</p>
<p>Then refer to the installation procedures for your new release. If you are
running more than one release of GT.M 
investigate the 
<span>environment variables</span> that define the environments, and take
appropriate action. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i3_file_header_errors"></a>I3&#8211;File Header Errors</h3></div></div></div>
<p>These errors indicate damage to the control or reference information in the
file header.</p>
<p>"Start VBN smaller than possible" indicates that INTEG cannot locate the
database structure. "Header indicates that file creation did not complete"
indicates a MUPIP CREATE problem. In these cases, the database has effectively
been lost. DSE cannot correct these problems. If you determine that the costs of
recovering from a backup, hopefully with journal files, are prohibitive,
consider consulting with FIS.</p>
<p>To correct the other errors of this type use the DSE CHANGE FILEHEADER command
with the BLK_SIZE=, BLOCKS_FREE=, and TOTAL_BLKS qualifiers.</p>
<p>"Free blocks counter ..." indicates that the count of free blocks in the file
header is not correct. This error only affects $VIEW("FREECNT",region), MUPIP DUMPFHEAD and DSE DUMP
-FILEHEADER which return the information.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i4_file_size_errors"></a>I4&#8211;File Size Errors</h3></div></div></div>
<p>File size errors can misdirect MUPIP, but do not cause the GT.M run-time
system to generate further errors. Auto-extend is the exception and may not
function properly if there are file size errors. One possible symptom of an
auto-extend problem would be incorrectly marked busy errors from a partial
bitmap at the "old" end of the database which had previously been incorrectly
initialized.</p>
<p>These errors indicate that the total blocks count does not agree with the file
size. Get the starting VBN and the block size for the file by using DSE DUMP
FILEHEADER. Then calculate the correct total blocks value with the following
formula:</p>
<pre class="programlisting">((file size - starting VBN + 1) / (block size / 512))
</pre>
<p>A decimal number results from this formula. Convert this decimal to a
hexadecimal number, then change the total block count to this hexadecimal value
using DSE CHANGE FILEHEADER TOTAL_BLKS= . You may also need to adjust the free
blocks count with BLOCKS_FREE=. MUPIP INTEG informs you if this is necessary and
gives the correct values. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i5_more_db_access_problems"></a>I5&#8211;More Database Access Problems</h3></div></div></div>
<p>These error messages reflect failures to find, open, or access a database
file. Examine any secondary error messages to obtain additional information
about the problem.</p>
<p>

<span>Use printenv to check gtmgbldir</span> or use the M command
WRITE $ZGBLDIR to verify that the "pointer" identifies the proper Global
Directory. If the pointer is not appropriate, 
<span>reset
gtmgbldir</span> or use the M command SET $ZGBLDIR= to name the proper
file.</p>
<p>Examine the Global Directory using GDE. If the Global Directory is not
appropriate, replace it, correct or recreate it with GDE. For more information on the use of
GDE, refer to the "Global Directory Editor" chapter.</p>
<p>IF THE GLOBAL DIRECTORY IS DAMAGED BUT ACCESSIBLE WITH GDE, investigate who
may have used GDE to perform the modifications. If the Global Directory is
damaged and not accessible with GDE, investigate what program, other than GT.M
and its utilities, might have written to the file. Except for GDE, all GT.M
components treat the Global Directory as static and read-only.</p>
<p>IF THE GLOBAL DIRECTORY APPEARS CORRECT, use printenv to verify that any
environment variables that it uses are properly defined for the process
experiencing the problem. If the process has an environment to which you do not
have access, you may have to carefully read the shell scripts used to establish
that environment.</p>
<p>IF THE ENVIRONMENT VARIABLES APPEAR CORRECT, use the 
<span>ls -l </span> to
examine the file protection. Remember to examine not only the file, but also all
directories accessed in locating the file.</p>
<p>IF THE FILES APPEAR TO BE PROPERLY MAPPED by the Global Directory, properly
placed given all environment variables, and properly protected to permit
appropriate access, use the od or cat utility to verify access to the files,
independent of GT.M.</p>
<p>IF YOU SUSPECT A VERSION MISMATCH PROBLEM, refer to section I2. </p>
<p>IF YOU SUSPECT A DISK HARDWARE PROBLEM, refer to section H7.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i6_transient_errors"></a>I6&#8211;Transient Errors</h3></div></div></div>
<p>GT.M corrects certain errors automatically. If you find that any of these
errors persist, contact your GT.M support channel.</p>
<p>"Block transaction number too large" indicates that the file header has a smaller transaction number than the database block. </p>
<p>If you are not running TP or incremental backup this is a benign error (from the database's point of view; application data consistency should be verified). GT.M automatically self-corrects these errors as soon as it performs sufficient updates to get the current transaction number of the database higher than any block's transaction number. If this error persists, perform the following steps:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Run the MUPIP INTEG command on your database and look for the following output: </p>
<p><code class="code">"Largest transaction number found in database was HHHHHHH"</code></p>
</li>
<li class="listitem">
<p>Run the following command:</p>
<p><code class="code">dse change -fileheader -current_tn=&lt;HHHHHHH+1&gt;</code></p>
<p>Where &lt;HHHHHHH+1&gt; is the largest transaction number + 1. This command sets the current transaction number to one more than the largest transaction number found in the database. Note that HHHHHHH is in hexadecimal form. </p>
</li>
</ul></div>
<p>"Current tn and early tn are not equal" indicates that the critical section has been damaged. "Reference
count is not zero" indicates an improper file close. The first access that
references a questionable database should correct these errors. Generally, these
errors indicate that the file was not closed normally. This problem is typically
caused by an unscheduled shutdown of the system. Review your institution's
startup and shutdown procedures to ensure a controlled shutdown. Startup procedures should use journaling and/or replication to recover from an unscheduled shutdown.</p>
<p>"Cannot determine access method..." indicates that the fileheader has been
damaged. When INTEG detects this error, it forces the access method to BG and
continues. If there is no other damage to the file header, no other action may
be required. </p>
<p>However, if the access method should be MM, use MUPIP SET ACCESS_METHOD=MM to
correct the database.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i7_db_rundown_prblm"></a>I7&#8211;Database Rundown Problem</h3></div></div></div>
<p>A MUPIP INTEG may be performed without write access to the database file. However, in the case where the database file was improperly closed, it must be put in an appropriate state with a MUPIP JOURNAL -ROLLBACK/RECOVER or MUPIP RUNDOWN prior to being INTEGed. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i8_repair_induced_prblm"></a>I8&#8211;Repair-Induced Problems</h3></div></div></div>
<p>These error messages are created by operator actions performed with
DSE.</p>
<p>The DSE commands CRITICAL INITIALIZE RESET, ALL RESET, and ALL RENEW induce
CRITRESET errors in all processes attempting to access the target
database(s).</p>
<p>Any process attempting to access a database that has its "corrupt" flag set to
TRUE receives a DBCRPT error.</p>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution: Caution">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Caution]" src="images/caution.jpg"></td>
<th align="left">Caution</th>
</tr>
<tr><td align="left" valign="top"><p>Using the DSE command CHANGE FILEHEADER CORRUPT=TRUE is very dangerous. If
the DSE session EXITs before issuing a CHANGE FILEHEADER CORRUPT=FALSE, the
database becomes entirely useless.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k1_bad_key"></a>K1&#8211;Bad Key</h3></div></div></div>
<p>This section describes appropriate actions when the error message indicates a
damaged key. GDS transforms subscripted or unsubscripted global variable names
into keys, which are part of the database record used to index the corresponding
global variable data values. The keys are stored in a compressed form which
omits that part of the prefix held in common with the previous key in the block.
The compression count is the number of common characters. Except in the
Directory Tree, all records after the first one have a non-zero count. The first
record in a block always has a compression count of zero (0).</p>
<p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), refer to section
O3.</p>
<p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), examine the record with the
DSE command DUMP BLOCK= OFFSET where the block and offset values are provided by
the INTEG error report. If the record appears to have a valid block pointer,
note the pointer. Otherwise, refer to section O2.</p>
<p>After noting the pointer, SPAWN and use MUPIP INTEG BLOCK=pointer (if you have
time constraints, you may use the FAST qualifier) to check the structure.</p>
<p>IF THE SUB-TREE IS INVALID, according to the MUPIP INTEG, DSE REMOVE the
record containing the reported bad key, INTEG, and refer to section O4.</p>
<p>Otherwise use the DSE command DUMP BLOCK= RECORD=9999 to find the last record
in the block and examine it using the DUMP RECORD= command. Continue using DSE
to follow the pointer(s) down to level 0, always choosing the right-hand branch.
Note the largest key at the data level. REMOVE the record containing the
reported bad key. Determine the proper placement for the noted key using FIND
KEY= and ADD KEY= POINTER where the key and the pointer are those noted in the
preceding actions. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k2_keys_misplaced"></a>K2&#8211;Keys Misplaced</h3></div></div></div>
<p>When the error is a misplaced key, the keys are not in proper collating
sequence.</p>
<p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p>
<p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), you may choose to reposition
the record in its proper place or use the salvage strategy discussed in section
O4. In general, the salvage strategy is less demanding and less dangerous.
However, it may be time consuming if the index block holding the record has a
level much greater than one (1). If you decide against the salvage strategy,
note the contents of the damaged record. In either case, REMOVE the record. If
using salvage, refer to section O4. If not, determine the proper location for
the record using FIND KEY= to display the closest existing path, then follow the
procedure outlined in the last paragraph of K1.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k3_block_doubly_allocated"></a>K3&#8211;Block Doubly Allocated</h3></div></div></div>
<p>A doubly allocated block is dangerous because it causes data to be
inappropriately mingled. As long as no KILLs occur, double allocation might not
cause permanent loss of additional data. However, it may cause the application
programs to generate errors and/or inappropriate results. When a block is doubly
allocated, a KILL may remove data outside its proper scope.</p>
<p>A doubly allocated index block may also cause increasing numbers of blocks to
become corrupted. Use the following process to correct the problem.</p>
<p>First, identify all pointers to the block, using FIND EXHAUSTIVE and/or
information reported by MUPIP INTEG. If the error report identifies the block as
containing inappropriate keys or a bad level, INTEG has identified all paths
that include the block. In that case, INTEG reports all paths after the first
with the doubly allocated error, and the first path with some other, for
example, "Keys out of order" error. </p>
<p>IF THE INTEG REPORT DOES NOT MENTION THE BLOCK PRIOR TO THE DOUBLY ALLOCATED
ERROR, use FIND EXHAUSTIVE to identify all pointers to that block.</p>
<p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p>
<p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), you may sort through the block
and its descendants to disentangle intermixed data. If the block has a level of
more than one (1), this may be worth a try. The salvage strategy (discussed in
section O4) may be time consuming and there may be only one misplaced node.
However, in general, the salvage strategy is less demanding and less
dangerous.</p>
<p>IF YOU CHOOSE THE SALVAGE STRATEGY, REMOVE the records that point to the
block, MAP it FREE, and refer to section O4.</p>
<p>IF YOU DECIDE TO WORK WITH THE BLOCK, choose the path to retain, REMOVE the
other pointer record, and relocate any misplaced descendants with DSE ADD and
REMOVE. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k4_pointer_prbl"></a>K4&#8211;Pointer Problems</h3></div></div></div>
<p>Each index block is made up of records that contain keys and corresponding
pointers. In the case where database damage is a symptom of an incorrect key
paired with a valid pointer, the repair strategy, which may be implemented with
a number of tactics, is to use the pointer to locate the data and reconstruct
the key. </p>
<p>While they occur very infrequently, invalid pointers do not permit the same
strategy. If there is an invalid pointer, always eliminate the record containing
the bad pointer using the DSE REMOVE command. Since no data can be stored under
an invalid pointer, either the pointer error was discovered on the first attempt
to use it and no data has been lost, or the pointer was damaged during use. If
the pointer was damaged during use, the lost data should be located by examining
"Block incorrectly marked busy" errors and generally be recovered as described
in section O4.</p>
<p>IF MUCH DATA IS LOST, it may be worthwhile attempting to reconstruct the bad
record as follows. Before removing the record containing the bad pointer, use
the DUMP command to note the key in the record. Using the error reports and/or
the DSE RANGE command, locate the block to which the key should point. Then use
DSE ADD to replace the previously deleted record with a new record that has the
correct key and pointer in place.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="i5_star_key_prblms"></a>K5&#8211;Star Key Problems</h3></div></div></div>
<p>The last record in every index block must be a star-key record that points to
a block that continues the path to all data not covered by the preceding records
in the block. Star-key records have a unique format with a size of 
eight (8), depending on the platform, and a compression count of zero (0). The
errors discussed in this section indicate a missing or damaged star-key and may
be attacked with two strategies.</p>
<p>In general, you should turn the last existing record into a star-key. This
works well as long as the block holds at least one valid record. If you choose
this strategy, locate the last record using DUMP RECORD=9999. Then DUMP the last
record and note its pointer. Next, REMOVE the last record. Finally, ADD STAR
POINTER= to the key you noted.</p>
<p>If the star-key is the only record in a root block, you should add a new empty
level 0 descendent. If you choose this strategy, add a new star-key using FIND
FREEBLOCK HINT=this-block to locate a nearby block. Next, MAP the new block BUSY
and CHANGE LEVEL= 0 and BSIZ=8. If the new
block has a level of zero (0), return to the damaged block and ADD STAR
POINTER=the-first-new-block.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k6_compression_count_error"></a>K6&#8211;Compression Count Error</h3></div></div></div>
<p>"Compression count not maximal" indicates that the compression count that is
used to save space in key storage is not correct.</p>
<p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), DUMP it GLO, REMOVE the
records that point to it, MAP it FREE, and MUPIP LOAD the output of the DUMP
GLO.</p>
<p>IF THE BLOCK HAS A LEVEL GREATER THAN ZERO (0), REMOVE the record and ADD it
back in the same location with the same KEY=, and POINTER= or STAR.</p>
<p>You may also adjust the compression count using CHANGE CMPC=. Because this
changes the value of all subsequent keys in the block (except the star-key), you
should try this alternative only if those keys also appear incorrect. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="k7_key_warning"></a>K7&#8211;Key Warning</h3></div></div></div>
<p>"Key too large for database maximum" indicates that the database holds a key
that is legal to GT.M but exceeds the KEY_MAX_SIZE for the database. </p>
<p>Use the DSE command CHANGE FILEHEADER KEY_MAX_SIZE= to adjust the file
limitation. Alternatively, you may remove the record, using the M command KILL
on an ancestor node. If any user attempts to modify or replace the record in the
database while the key is over-length, GT.M will reject the SET with an error.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="m1_bitmap_errors"></a>M1&#8211;Bitmap Errors</h3></div></div></div>
<p>Every block in the file has a corresponding bit in a bitmap. All blocks with
valid data are marked busy in their maps; all blocks that are unused or no
longer hold data are marked free. GDS uses bitmaps to locate free blocks
efficiently. The errors discussed in this section indicate problems with
bitmaps.</p>
<p>"Block incorrectly marked free" is the only potentially dangerous bitmap
error. This error means that the block is within the B-tree structure, but that
the bitmap shows it available for use (i.e., it is a "Block doubly allocated"
waiting to happen). Immediately use DSE to MAP such blocks BUSY.</p>
<p>Bitmap information is redundant (i.e., bitmaps can be recreated by scanning
the B-tree); however, the majority of bitmap errors reflect secondary errors
emanating from flaws in the B-tree, which are often reported as key
errors by MUPIP INTEG. </p>
<p>When INTEG encounters an error, it stops processing that leaf of the tree.
When it subsequently compares its generated bitmaps to those in the database, it
reports the blocks belonging in the tree that it could not find as "Block
incorrectly marked busy." This error type can be viewed as a flag, marking the
location of a block of lost data whose index is disrupted.</p>
<p>INTEG reports each block that it concludes is incorrectly marked, and also the
local map that holds the "bad" bits. Furthermore, if the local map "errors"
affect whether the local map should be marked full or not full in the master
map, INTEG also reports the (potential) problem with the master map. Therefore,
a single error in a level one (1) index block will generate, in addition to
itself, one or more "Block incorrectly marked busy", one or more "Local bitmap
incorrect", and possibly one or more "Master bitmap shows..." Errors in higher
level index blocks can induce very large numbers of bitmap error reports.</p>
<p>Because bitmap errors are typically secondary to other errors, correcting the
primary errors usually also cures the bitmap errors. For this reason and, more
importantly, because bitmap errors tend to locate "lost" data, they should
always be corrected at, or close to, the end of a repair session.</p>
<p>The DSE command MAP provides a way to switch bits in local maps with FREE and
BUSY, propagate the status of a local map to the master map with MASTER, and
completely rebuild all maps from the B-tree with RESTORE. Before beginning any MAP -MASTER operation, first ensure that the database has no active updaters and that there are no non-bitmap errors to resolve. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="m2_bitmap_header_problms"></a>M2&#8211;Bitmap Header Problems</h3></div></div></div>
<p>Bitmaps are stored in blocks that have a unique header format with a level of
minus one (-1) and a block size of 87 or 88 depending on the Euclidian ordering
of the platform. The errors discussed in this section indicate a bitmap block
header that violates that format.</p>
<p>Use the DSE command CHANGE with the BSIZ=87 or 88 (depending on platform) and
LEVEL=-1FF qualifiers to correct the problem. If the block size is too small,
the bitmap will have to be reconstructed using MAP RESTORE or manually from
INTEG error reports using MAP FREE. If there are other errors, defer any MAP
RESTORE until after they have been repaired. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="O1_bad_block"></a>O1&#8211;Bad Block</h3></div></div></div>
<p>GDS organizes the B-tree into logical blocks, each of which GT.M handles
discretely. A block consists of a block header and a lexically increasing
sequence of records. Blocks starting with the root block up to the data blocks
are index blocks. The last block in any complete path is a data block. The
errors discussed in this section indicate a damaged block.</p>
<p>Determine if the block has other problems by using the DSE command INTEGRIT.
Examine the contents of the block using the DSE command DUMP. You may also
examine the block preceding this block in the path and/or blocks pointed to by
records in this block. If you can determine an appropriate action, use CHANGE
with the BSIZ= and/or LEVEL= qualifiers. If you cannot quickly repair the block,
examine its level with DUMP HEADER. If the block is a data block, that is, level
zero (0), refer to section O3. If the block has a level greater than zero (0),
REMOVE the record that points to the block and refer to section O4.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="o2_record_errors"></a>O2&#8211;Record Errors</h3></div></div></div>
<p>GDS organizes keys with pointers or data to form records. A record has a
header, which holds the record size, and a compression count, which identifies
how much of the preceding key is held in common by this record. Records in the
block are ordered by the values of their keys. The errors discussed in this
section indicate damage to a record. Record errors present an added challenge,
in that they potentially prevent GT.M from correctly interpreting subsequent
records in the same block.</p>
<p>IF THE BLOCK IS A DATA BLOCK, that is, level zero (0), refer to section
O3.</p>
<p>IF THE BLOCK IS AN INDEX BLOCK, that is, has a level greater than zero (0),
the best option is generally to use the salvage strategy discussed in section
O4. REMOVE the damaged record and INTEG the block. If the block is still
corrupt, repeat the last step, REMOVE the pointer to it, and MAP it FREE. In any
case, refer to section O4. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="o3_data_block_errors"></a>O3&#8211;Data Block Errors</h3></div></div></div>
<p>The errors described in this section include damage to the header, the
records, or the keys.</p>
<p>IF THE BLOCK IS LEVEL ZERO (0), use DSE DUMP to examine the contents of the
block. Note any information that might allow you to correct the problem or might
help to identify and recreate the endangered data. If you are familiar with GDS
and hexadecimal representations, you may be able to recognize data that DSE
cannot recognize because of misalignment.</p>
<p>IF THE BEGINNING OF THE BLOCK IS VALID, DUMP GLO may be able to capture its
contents up to the point where it is damaged. In the worst case, REMOVE the
record that points to the block, MAP it FREE, and lose its entire contents. The
extent and importance of the damage depends on the size of the block and what it
should be holding. In a similar but not quite as drastic case, REMOVE the record
with the problem and lose the contents of that record. Use application and business process knowledge to research an if appropriate reconstruct lost data; remember, if recently processed, it may exist in journal files.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="o4_salvage"></a>O4&#8211;Salvage of Data Blocks with Lost Indices</h3></div></div></div>
<p>This strategy uses bitmap errors to locate data blocks containing information
that belongs in the B-tree, but are no longer indexed because of errors and/or
repairs to defective indices.</p>
<p>The algorithm is based on the fact that most bitmap errors are secondary to
index errors. Therefore, it is optimistic about bitmaps and pessimistic about
indices, and tends to error on the side of restoring more rather than less data
to the B-tree. After using this technique, you should always check to see if
obsolete, deleted data was restored. If data was restored, and GDS integrity has
been restored, you can safely KILL the "extra" data.</p>
<p>IF THE INDICES HAVE BEEN DAMAGED FOR SOME TIME AND THE DAMAGE CAUSED DUPLICATE
KEYS TO BE CREATED, this strategy raises the issue of which value is the
"correct" value. Because most applications either form new nodes or update
existing nodes rather than simply overlaying them, this issue seldom arises.
Usually the application will fail in an attempt to update any "misplaced" node.
If the problem does arise, the issue may not be determining the "correct" value,
but the best available value. </p>
<p>IF YOU HAVE A DUPLICATE NODE PROBLEM, you can load the
sequential file produced in DSE with an M program that detects and reports
duplicate nodes. You can also use the block transaction numbers as clues to the
order in which blocks were updated. However, remember that you generally cannot
know which record was modified on the last update, and that DSE repair actions
modify the block transaction number. </p>
<p>If the duplicate node problem poses a significant problem, you should probably
not use DSE to repair the database, but instead, use journals to recover or
restore from backups.</p>
<p>This strategy works well when the missing indices are level one (1). However,
the time required increases dramatically as the level of the missing index
increases. If you have a problem with a level four (4) or level five (5) index,
and you have developed skill with DSE, you may wish to try the more technically
demanding approach of repairing the indices.</p>
<p>Once you have corrected all errors except bitmap errors, SPAWN and use MUPIP
INTEG FAST REGION NOMAP to get a list of all remaining bitmap errors. If the
report includes any "Blocks incorrectly marked free", MAP them BUSY. Then use
DUMP HEADER BLOCK= to examine each "Block incorrectly marked busy." If the level
is one (1), DUMP the block ZWR. In any case, MAP it FREE. Once all blocks have
been collected in a sequential file in this fashion, use MUPIP LOAD to reclaim
the data from the sequential file.</p>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="downloadsalvage"></a>Download salvage.m</h4></div></div></div>
<p>salvage.m is a utility that removes all incorrectly marked busy blocks from the specified region. During execution it displays the DSE commands that it will execute and aborts execution when it encounters an error. It dumps the zwrite formatted content of blocks incorrectly marked busy to a file called &lt;region&gt;_db.zwr. Upon completion, it sets the abandoned_kills and kill_in_prog flags in the database fileheader to false. Click on <a class="ulink" href="downloadables/salvage.m.html" target="_top"><span class="inlinemediaobject"><img src="images/download.png" alt="Download salvage.m"></span></a> to download salvage.m program. You can also download <span class="bold"><strong>salvage.m</strong></span> from http://tinco.pair.com/bhaskar/gtm/doc/books/ao/UNIX_manual/downloadables/salvage.m. </p>
<p>Steps to run the salvage utility are as follows:</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>Perform an argumentless MUPIP RUNDOWN before running this utility.</p></li>
<li class="listitem"><p>Ensure that there are no INTEG errors other than the incorrectly marked busy block errors.</p></li>
<li class="listitem"><p>Run <code class="code"> $gtm_dist/mumps -r ^salvage</code>.</p></li>
<li class="listitem"><p>Specify the region name. If no region is specified, the utility assumes DEFAULT.</p></li>
<li class="listitem"><p>If the utility reports a DSE error, fix that error and run the salvage utility again.</p></li>
</ol></div>
<p>After completing repairs with the salvage utility, open the &lt;REGION&gt;_db.zwr file and examine its contents. If there is a need to recover the data from the incorrectly marked    busy blocks, perform a MUPIP LOAD &lt;REGION&gt;_db.zwr to load that data back to the database.</p>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="sal_dam_spa"></a>O5&#8211;Salvage of a damaged spanning node<a class="indexterm" name="idm45451835045200"></a>
</h3></div></div></div>
<p>The following example shows how to salvage a damaged spanning node in ^mypoem. </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<p>Run MUPIP INTEG to find the location of the damaged spanning node. A MUPIP INTEG report of a region that has damaged spanning nodes might look something like the following: </p>
<pre class="programlisting">Integ of region DEFAULT
Block:Offset Level
%GTM-E-DBSPANGLOINCMP, 
       7:10     0  Spanning node is missing. Block no 3 of spanning node is missing
                   Directory Path:  1:10, 2:10
                   Path:  4:31, 7:10
Spanning Node ^mypoem(#SPAN1) is suspect.
%GTM-E-DBKEYGTIND, 
       7:10     0  Key greater than index key
                   Directory Path:  1:10, 2:10
                   Path:  4:31, 7:10
Keys from ^mypoem(#SPAN48) to ^mypoem(#SPAN3*) are suspect.
%GTM-E-DBSPANCHUNKORD, 
       3:10     0  Chunk of 1 blocks is out of order
                   Directory Path:  1:10, 2:10
                   Path:  4:3D, 3:10
Spanning Node Chunk ^mypoem(#SPAN4) is suspect.
Total error count from integ:        3
Type           Blocks         Records          % Used      Adjacent
Directory           2               2           5.468            NA
Index               1               4          13.476             1
Data                4               5          76.562             4
Free               93              NA              NA            NA
Total             100              11              NA             5
[Spanning Nodes:2 ; Blocks:3]
%GTM-E-INTEGERRS, Database integrity errors</pre>
<p>Notice the lines that contain: "Block no 3 of spanning node is missing", "Key greater than index key", and ^mypoem(#SPAN48)  and there is an extra chunk that is not connected to ^mypoem(#SPAN4). </p>
</li>
<li class="listitem">
<p>Confirm whether you have determined the spanning range of the node: </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Is ^mypoem(#SPAN48) the last node (block number 3)? </p></li>
<li class="listitem"><p>Is ^mypoem(#SPAN4) the last node?</p></li>
</ul></div>
<p>Clearly, GT.M did not find block 3 and ^mypoem(#SPAN4) terminated the spanning node, so ^mypoem(#SPAN4) might be the last node. So, the parts of a spanning node that contain the value are ^mypoem(#SPAN2) through ^mypoem(#SPAN4). </p>
</li>
<li class="listitem">
<p>Use DSE to find the spanned nodes:</p>
<pre class="programlisting">DSE&gt; find -key=^mypoem(#SPAN2)
Key found in block  6.
    Directory path
    Path--blk:off
    1:10,    2:10,
    Global tree path
    Path--blk:off
    4:25,    6:10,
DSE&gt; find -key=^mypoem(#SPAN3)
Key not found, would be in block  7.
    Directory path
    Path--blk:off
    1:10,    2:10,
    Global tree path
    Path--blk:off
    4:31,    7:10,
DSE&gt; find -key=^mypoem(#SPAN4) 
Key found in block  3.
    Directory path
    Path--blk:off
    1:10,    2:10,
    Global tree path
    Path--blk:off
    4:3D,    3:10,
DSE&gt; f -k=^mypoem(#SPAN5)
Key not found, would be in block  3.
    Directory path
    Path--blk:off
    1:10,    2:10,
    Global tree path
    Path--blk:off
    4:3D,    3:10,</pre>
<p>Notice that there is #SPAN2 and #SPAN4 but no #SPAN5. Therefore, #SPAN4 is the last piece. #SPAN3 was not found and is most likely the damaged node.</p>
</li>
<li class="listitem">
<p>Dump all the blocks in ZWRITE format to see what can be salvaged.</p>
<pre class="programlisting">DSE&gt; open -file=mypoem.txt
DSE&gt; dump -block=6 -zwr
1 ZWR records written.
DSE&gt; dump -block=7 -zwr
1 ZWR records written.
DSE&gt; dump -block=3 -zwr
1 ZWR records written.
DSE&gt; close
Closing output file:  mypoem.txt
$ cat mypoem.txt
; DSE EXTRACT
; ZWR
$ze(^mypoem,0,480)="Half a league, half a league,Half a league onward,All in the valley of Death Rode the six hundred.  Forward, the Light Brigade!  Charge for the guns he said: Into the valley of Death Rode the six hundred.  Forward, the Light Brigade! Was there a man dismayed?  Not tho the soldiers knew Some one had blundered: Theirs not to make reply, Theirs not to reason why, Theirs but to do and die: Into the valley of Death Rode the six hundred.  Cannon to right of them, Cannon to left of "
$ze(^mypoem,22080,480)="them, Cannon in front of them Volleyed and thundered; Stormed at with shot and shell, Boldly they rode and well, Into the jaws of Death, Into the mouth of Hell Rode the six hundred.  Flashed all their sabres bare, Flashed as they turned in air Sabring the gunners there, Charging an army while All the world wondered: Plunged in the battery-smoke Right thro the line they broke; Cossack and Russian Reeled from the sabre-stroke Shattered and sundered.  Then they rode back, but no"
$ze(^mypoem,960,468)="t Not the six hundred.  Cannon to right of them, Cannon to left of them, Cannon behind them Volleyed and thundered; Stormed at with shot and shell, While horse and hero fell, They that had fought so well Came thro the jaws of Death, Back from the mouth of Hell, All that was left of them, Left of six hundred.  When can their glory fade?  O the wild charge they made!  All the world wondered.  Honour the charge they made!  Honour the Light Brigade, Noble six hundred!"</pre>
<p>Notice that block 3 (which is the second block above (because you started with block 2)) has the correct value but its internal subscript must have been damaged. </p>
</li>
<li class="listitem">
<p>Fix the starting position in the $ZEXTRACT statement:</p>
<pre class="programlisting">
$ze(^mypoem,480,480)="them, Cannon in front of them Volleyed and thundered; Stormed at with shot and shell, Boldly they rode and well, Into the jaws of Death, Into the mouth of Hell Rode the six hundred.  Flashed all their sabres bare, Flashed as they turned in air Sabring the gunners there, Charging an army while All the world wondered: Plunged in the battery-smoke Right thro the line they broke; Cossack and Russian Reeled from the sabre-stroke Shattered and sundered.  Then they rode back, but no"</pre>
<p>Verify the value for correctness if you have the knowledge of the type of data in this global. This completes data recovery (whatever was possible). </p>
</li>
<li class="listitem">
<p>Kill the existing global:</p>
<pre class="programlisting">GTM&gt;kill ^mypoem
GTM&gt;write ^mypoem
%GTM-E-GVUNDEF, Global variable undefined: ^mypoem</pre>
</li>
<li class="listitem">
<p>Load the salvaged global:</p>
<pre class="programlisting">$ mupip load -format=zwr mypoem.txt
; DSE EXTRACT
; ZWR
Beginning LOAD at record number: 3
LOAD TOTAL        Key Cnt: 3  Max Subsc Len: 8  Max Data Len: 480
Last LOAD record number: 5
$ gtm
GTM&gt;w ^mypoem
Half a league, half a league,Half a league onward,All in the valley of Death Rode the six hundred.  Forward, the Light Brigade!  Charge for the guns he said: Into the valley of Death Rode the six hundred.  Forward, the Light Brigade! Was there a man dismayed?  Not tho the soldiers knew Some one had blundered: Theirs not to make reply, Theirs not to reason why, Theirs but to do and die: Into the valley of Death Rode the six hundred.  Cannon to right of them, Cannon to left of them, Cannon in front of them Volleyed and thundered; Stormed at with shot and shell, Boldly they rode and well, Into the jaws of Death, Into the mouth of Hell Rode the six hundred.  Flashed all their sabres bare, Flashed as they turned in air Sabring the gunners there, Charging an army while All the world wondered: Plunged in the battery-smoke Right thro the line they broke; Cossack and Russian Reeled from the sabre-stroke Shattered and sundered.  Then they rode back, but not Not the six hundred.  Cannon to right of them, Cannon to left of them, Cannon behind them Volleyed and thundered; Stormed at with shot and shell, While horse and hero fell, They that had fought so well Came thro the jaws of Death, Back from the mouth of Hell, All that was left of them, Left of six hundred.  When can their glory fade?  O the wild charge they made!  All the world wondered.  Honour the charge they made!  Honour the Light Brigade, Noble six hundred!</pre>
</li>
</ol></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="p1_process_damage"></a>P1&#8211;Process Damage</h3></div></div></div>
<p>A damaged process is one that has become internally "confused" and is
executing in a pathological way not caused by circumstances in the external
environment.</p>
<p> If multiple processes exhibit the same symptoms, the problem is likely embedded in the application code and/or the database.</p>
<p>IF YOU HAVE DISCOVERED THAT A PROCESS WAS DAMAGED, carefully review all events
related to that process leading to the discovery of the problem. It may be
possible that the process had an elevated priority and was not hanging, but
rather was "hogging" system resources. It is also possible that the problem is
an application loop problem, missed by not performing the steps in section H3
with enough rigor. </p>
<p>

<span>Check
</span>for evidence of any hardware problem that might damage a process.
</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="q1_restict_db_access"></a>Q1&#8211;Restricting Database Access</h3></div></div></div>
<p>Prevent new users from attempting to access the database by taking
steps such as bringing the system to the single-user state or removing execute
access to GT.M components for an appropriate class or users. Also, terminate or
suspend all processes accessing the database in question, using the UNIX ps -af
utility to find such processes. Because the DSE command CRITICAL -INITIALIZE
-RESET generates errors for all processes accessing a database file, it provides
a quick way to stop such processes.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r1_gtm_run_time_errors"></a>R1&#8211;GT.M Run-Time Errors</h3></div></div></div>
<p>GT.M processes may detect errors at run-time. These errors trigger the GT.M
error handling mechanism, which generally places the process in direct mode, or
triggers the application programs to transcribe an error context to a sequential
file or to a global. For more information on error handling, refer to the "Error
Processing" chapter of the </p>
<p><a class="ulink" href="../../pg/UNIX_manual/index.html" target="_top">GT.M Programmer's Guide</a></p>
<p>.</p>
<p>Most run-time errors are related to the application and its environment.
However, some errors reflect the inability of a process to properly deal with a
database. Some errors of this type are also, or only, generated by the GT.M
utility programs.</p>
<p>For descriptions of individual errors, refer to the GT.M Message and Recovery
Procedure Reference Manual.</p>
<p>IF YOU CANNOT REPRODUCE SUCH ERRORS WITH ANOTHER PROCESS PERFORMING THE SAME
TASK, or with an appropriately directed MUPIP INTEG, they were most likely
reported by a damaged process. In this case, refer to section P1.</p>
<p>The following table lists run-time errors, alphabetically by mnemonic, each
with a section reference for further information.</p>
<div class="informaltable"><table width="100%" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="3">
<p>Run-Time Error Messages Identifying Potential System
Problems</p>
</th></tr>
<tr>
<th>
<p>ERROR MNEMONIC</p>
</th>
<th>
<p>ERROR MESSAGE TEXT</p>
</th>
<th>
<p>SECTION</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>BADDVER</p>
<p>BITMAPSBAD</p>
<p>BTFAIL</p>
<p>CCPINTQUE</p>
<p>CRITRESET</p>
</td>
<td>
<p>Incorrect database version vvv</p>
<p>Database bitmaps are incorrect</p>
<p>The database block table is corrupt</p>
<p>Interlock failure accessing Cluster Control Program
queue</p>
<p>The critical section crash count for rrr region has been
incremented</p>
</td>
<td>
<p>I2</p>
<p>M1</p>
<p>R3</p>
<p>R7</p>
<p>I8</p>
</td>
</tr>
<tr>
<td>
<p>DBCCERR</p>
<p>DBCRPT</p>
<p>DBFILERR</p>
<p>DBNOFILEP</p>
<p>DBNOTGDS</p>
</td>
<td>
<p>Interlock instruction failure in critical mechanism for
region rrr</p>
<p>Database is flagged corrupt </p>
<p>Error with database file</p>
<p>No database file has been successfully opened</p>
<p>Unrecognized database file format</p>
</td>
<td>
<p>R7</p>
<p>I8</p>
<p>I5</p>
<p>I5</p>
<p>I5</p>
</td>
</tr>
<tr>
<td>
<p>DBOPNERR</p>
<p>DBRDERR</p>
<p>FORCEDHALT</p>
<p>GBLDIRACC</p>
<p>GBLOFLOW</p>
</td>
<td>
<p>Error opening database file</p>
<p>Cannot read database file after opening</p>
<p>Image HALTed by MUPIP STOP</p>
<p>Global Directory access failed, cannot perform database
functions</p>
<p>Database segment is full</p>
</td>
<td>
<p>I5</p>
<p>I5</p>
<p>R4</p>
<p>I5</p>
<p>R5</p>
</td>
</tr>
<tr>
<td>
<p>GVKILLFAIL</p>
<p>GVORDERFAIL</p>
<p>GVPUTFAIL</p>
<p>GVQUERYFAIL</p>
<p>GVRUNDOWN</p>
</td>
<td>
<p>Global variable KILL failed. Failure code: cccc</p>
<p>Global variable $ORDER or $NEXT function failed. Failure
code: cccc </p>
<p>Global variable put failed. Failure code: cccc</p>
<p>Global variable $QUERY function failed. Failure code:
cccc</p>
<p>Error during global database rundown</p>
</td>
<td>
<p>R2</p>
<p>R2</p>
<p>R2</p>
<p>R2</p>
<p>I5</p>
</td>
</tr>
<tr>
<td>
<p>GDINVALID</p>
<p>GTMCHECK</p>
<p>GVDATAFAIL</p>
<p>GVDIRECT</p>
<p>GVGETFAIL</p>
</td>
<td>
<p>Unrecognized Global Directory format: fff</p>
<p>Internal GT.M error&#8211;report to FIS</p>
<p>Global variable $DATA function failed. Failure code:
cccc</p>
<p>Global variable name could not be found in global
directory</p>
<p>Global variable retrieval failed. Failure code:
cccc</p>
</td>
<td>
<p>I5</p>
<p>R6</p>
<p>R2</p>
<p>I5</p>
<p>R2</p>
</td>
</tr>
<tr>
<td>
<p>GVZPREVFAIL</p>
<p>MUFILRNDWNFL</p>
<p>UNKNOWNFOREX</p>
<p>TOTALBLKMAX</p>
<p>WCFAIL</p>
</td>
<td>
<p>Global variable $ZPREVIOUS function failed. Failure code:
cccc</p>
<p>File rundown failed</p>
<p>Process halted by a forced exit from a source other than
MUPIP</p>
<p>Extension exceeds maximum total blocks, not
extending</p>
<p>The database cache is corrupt</p>
</td>
<td>
<p>R2</p>
<p>I5</p>
<p>R4</p>
<p>R5</p>
<p>R3</p>
</td>
</tr>
</tbody>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r2_structure_db_integ"></a>R2&#8211;Structural Database Integrity Errors<a class="indexterm" name="idm45451835002288"></a>
</h3></div></div></div>
<p>These run-time errors indicate that the process detected an integrity error within the body of the database.</p>
<p>Verify the error using the MUPIP command INTEG SUBSCRIPT=, specifying an
immediate ancestor node of the global variable displayed in the error message.
Alternatively, you may try the access by running the same routine in another
process or by using Direct Mode to perform the same actions as those performed
by the M line that triggered the error. If you cannot reproduce the error, refer
to section P1.</p>
<p>Most of these errors terminate with a four-character failure code. Each
character in the code represents the failure type for an attempt to perform the
database access. In cases where the letters are not all the same, the last code
is the most critical, because it reflects what happened when the process made
its last retry. Earlier tries show error codes that are important to
establishing the context of the last error.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="Run-Time_Database_Restart_Code_Table"></a>Run-Time Database Restart Codes<a class="indexterm" name="idm45451835027360"></a>
</h3></div></div></div>
<p>
The following table lists the failure codes, whether or not they require a
MUPIP INTEG, a brief description of the code's meaning, and a section reference
for locating more information.</p>
<div class="informaltable"><table width="100%" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="4">
<p>Run-Time Database Restart Codes</p>
</th></tr>
<tr>
<th>
<p>FAIL CODE</p>
</th>
<th>
<p>RUN INTEG</p>
</th>
<th>
<p>DESCRIPTION</p>
</th>
<th>
<p>SECTION</p>
</th>
</tr>
</thead>
<tfoot><tr><th colspan="4">
<p>* In the last retry may indicate a process problem</p>
</th></tr></tfoot>
<tbody>
<tr>
<td>
<p>A</p>
<p>B</p>
<p>C</p>
<p>D</p>
<p>E</p>
</td>
<td>
<p>x</p>
<p>x</p>
<p>x</p>
<p>x</p>
<p>-</p>
</td>
<td>
<p>Special case of code C.</p>
<p>Key too large to be correct.</p>
<p>Record unaligned: properly formatted record header did not
appear where expected.</p>
<p>Record too small to be correct.</p>
<p>History overrun prevents validation of a block.</p>
</td>
<td>
<p>O2</p>
<p>K1</p>
<p>O2</p>
<p>O2</p>
<p>R3</p>
</td>
</tr>
<tr>
<td>
<p>F</p>
<p>G</p>
<p>H</p>
<p>I</p>
<p>J</p>
</td>
<td>
<p>-</p>
<p>x</p>
<p>x</p>
<p>x</p>
<p>x</p>
</td>
<td>
<p>Not currently used.</p>
<p>Cache record modified while in use by the transaction.</p>
<p>Development of a new version of a block encountered a likely concurrency conflict.</p>
<p>Level on a child does not show it to be a direct descendent of its parent.</p>
<p>Block requested outside of file.</p>
</td>
<td>
<p>-</p>
<p>R3</p>
<p>R3</p>
<p>O2</p>
<p>O2</p>
</td>
</tr>
<tr>
<td>
<p>K</p>
<p>L</p>
<p>M</p>
<p>N</p>
<p>O</p>
</td>
<td>
<p>-</p>
<p>-</p>
<p>x</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Cache control problem encountered or suspected.</p>
<p>Conflicting update of a block took priority.</p>
<p>Error during commit that the database logic does not
handle.</p>
<p>Not currently used.</p>
<p>Before image was lost prior to its transfer to the journal
buffer.</p>
</td>
<td>
<p>R3</p>
<p>R3</p>
<p>P1</p>
<p>-</p>
<p>R3</p>
</td>
</tr>
<tr>
<td>
<p>P</p>
<p>Q</p>
<p>R</p>
<p>S</p>
<p>T</p>
</td>
<td>
<p>-</p>
<p>x</p>
<p>x</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Not currently used.</p>
<p>Shared memory interlock failed.</p>
<p>Critical section reset (probably by DSE).</p>
<p>Attempt to increase the level beyond current maximum.</p>
<p>Commit blocked by flush.</p>
</td>
<td>
<p>-</p>
<p>R7</p>
<p>R5</p>
<p>R8</p>
<p>R3</p>
</td>
</tr>
<tr>
<td>
<p>U</p>
<p>V</p>
<p>W</p>
<p>X</p>
<p>Y</p>
</td>
<td>
<p>x</p>
<p>-</p>
<p>-</p>
<p>x</p>
<p>x</p>
</td>
<td>
<p>Cache record unstable while in use by the transaction.</p>
<p>Read-only process could not find room to work.</p>
<p>Not currently used.</p>
<p>Bitmap block header invalid.</p>
<p>Record offset outside of block bounds.</p>
</td>
<td>
<p>R3</p>
<p>R9</p>
<p>-</p>
<p>M2</p>
<p>O2</p>
</td>
</tr>
<tr>
<td>
<p>Z</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>d</p>
</td>
<td>
<p>x</p>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Block did not contain record predicted by the index.</p>
<p>Predicted bitmap preempted by another update.</p>
<p>History overrun prevents validation of a bitmap.</p>
<p>Bitmap cache record modified while in use by the transaction.</p>
<p>Not currently used.</p>
</td>
<td>
<p></p>
<p>O2</p>
<p>R3</p>
<p>R3</p>
<p>R3</p>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p>e</p>
<p>f</p>
<p>g</p>
<p>h</p>
<p>i</p>
</td>
<td>
<p>x</p>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Attempt to read a block outside the bounds of the database.</p>
<p>Conflicting update took priority on a non-isolated global and a block split requires a TP_RESTART.</p>
<p>The number of conflicting updates on non-isolated global nodes exceed an acceptable level and requires a TP_RESTART.</p>
<p>Journal state or before image changed.</p>
<p>Not currently used.</p>
</td>
<td>
<p></p>
<p>R3</p>
<p>R3</p>
<p>R3</p>
<p>R3</p>
<p>-</p>
</td>
</tr>
<tr>
<td>
<p>j</p>
<p>k</p>
<p>l</p>
<p>m</p>
<p>n</p>
</td>
<td>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Backup or integ lost before image block.</p>
<p>Cache control state mismatch.</p>
<p>Phase two commit held off block acquisition.</p>
<p>Inhibit KILLs held off commit.</p>
<p>Trigger definition changed during trigger processing.</p>
</td>
<td>
<p>R3</p>
<p>R3</p>
<p>P1</p>
<p>P1</p>
<p>P1</p>
</td>
</tr>
<tr>
<td>
<p>o</p>
<p>p</p>
<p>q</p>
<p>r</p>
<p>s</p>
</td>
<td>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
<p>-</p>
</td>
<td>
<p>Online rollback requires a restart.</p>
<p>Online rollback requires a restart.</p>
<p>Tentative block removed by MUPIP REORG -TRUNCATE.</p>
<p>Root block moved by MUPIP REORG.</p>
<p>Instance freeze blocked commit.</p>
</td>
<td>
<p>R3</p>
<p>R3</p>
<p>R3</p>
<p>R3</p>
<p>H3</p>
</td>
</tr>
<tr>
<td>
<p>y</p>
<p>z</p>
</td>
<td>
<p>x</p>
<p>-</p>
</td>
<td>
<p>Root block unreliable.</p>
<p>Currently not used.</p>
</td>
<td>
<p>K4</p>
<p>-</p>
</td>
</tr>
</tbody>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r2_run_time_db_cache"></a>R3&#8211;Run-time Database Cache Problems</h3></div></div></div>
<p>These messages indicate probable process damage or database cache corruption.
Retry the action with another process. If the second process also fails, refer
to section H4; otherwise, refer to section P1.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r4_stopped_processes"></a>R4&#8211;Stopped Processes</h3></div></div></div>
<p>These errors indicate the process received a message from a 
<span>kill </span>system service
requesting that the image terminate.</p>
<p>The MUPIP STOP command uses 
<span>kill</span> with a distinguished code. The code provided by
MUPIP STOP allows the process to include the source of the stop directive in the
error message. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r5_no_more_room"></a>R5&#8211;No More Room in the File</h3></div></div></div>
<p>IF THE DATABASE FILLS UP AND CANNOT EXPAND, processes that try to add new
information to the database experience run-time errors. The following conditions
prevent automatic database expansion.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Using the MM access method</p></li>
<li class="listitem"><p>Using a file extension of zero (0)</p></li>
<li class="listitem"><p>Inadequate free blocks available on the volume to handle the specified
extension</p></li>
</ul></div>
<p>You can handle the first two cases by using the MUPIP EXTEND command. MUPIP
EXTEND may also help in dealing with the third case by permitting an extension
smaller than that specified in the file header. Note that the extension size in
the file header, or /BLOCKS= qualifier to MUPIP EXTEND, is in GDS blocks and
does not include overhead for bitmaps.</p>
<p>IF THERE IS NO MORE SPACE ON A VOLUME, you may use the M command KILL to
delete data from the database. To KILL an entire global, the database file must
contain one free GDS block. You may acquire these by KILLing a series of
subscripted nodes or by doing a small extension.</p>
<p>You may also use UNIX utilities such as tar, cp, and lprm to remove
files from the volume and place them on another volume.</p>
<p>Finally, you may create or add to a bound volume set with the MOUNT utility
invoked by the DCL command MOUNT. If you change the RMS placement of the files,
be sure to adjust the Global Directory and/or the logical names to match the new
environment.</p>
<p>You can also add a new disk. If you change the placement of the files, be sure
to also adjust the Global Directory and/or the environment variables to match
the new environment.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r6_gtmassert_and_gtmcheck_errors"></a>R6&#8211;GTMASSERT and GTMCHECK Errors</h3></div></div></div>
<p>GTMASSERT and GTMCHECK errors indicate that a process has detected
some sort of logical inconsistency. Consult with FIS
after gathering all information about the circumstances surrounding the error. </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r7_interlock_q"></a>R7&#8211;Interlocked Queue Hardware Problems</h3></div></div></div>
<p>These messages indicate possible problems with multiple processor
synchronization. Initiate running of hardware diagnostics. If the diagnostics do
not locate a problem, consider consulting with FIS 
after gathering all information about the circumstances of the error.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r8_db_tree"></a>R8&#8211;Database Tree Maximum Level Exceeded</h3></div></div></div>
<p>An attempt has been made to create a tree in the database that contains seven
or more levels. The legal levels for a tree are zero to seven. You can add new
levels to the global either by killing some of the existing subscripts, or by
extracting the global and reloading it into a database with a larger block size,
so it does not require as large a tree.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="r9_read"></a>R9&#8211;Read-only Process Blocked</h3></div></div></div>
<p>While it is unlikely in normal operation, there is a possibility that a
process that has read-only access to a database file may fail because it cannot
acquire enough cache space to do its work. Because it does not have authority to
write to the database, such a process cannot flush modified cache records to
disk: it must rely on updating processes to keep the number of modified records
down to a point that permits read-only access to the database to proceed
successfully. However, if updating processes exit in a fashion that does not
permit them to flush out modified records, the read-only process (particularly
one doing a large transaction) may fail because the cache cannot supply enough
blocks. This condition can be cleared by a DSE BUFFER command in the affected
region(s).</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch11s03.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch11.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="ch12.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Repairing the Database with DSE </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 12. Database Encryption</td>
</tr>
</table>
</div>
</body>
</html>
