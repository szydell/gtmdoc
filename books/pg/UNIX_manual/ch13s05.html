<html>

<!-- Mirrored [from host tinco.pair.com [file /bhaskar/gtm/doc/books/pg/UNIX_manual/ch13s05.html]] -->
<HEAD><META HTTP-EQUIV="Pragma" CONTENT="no-cache"><META HTTP-EQUIV="Expires" CONTENT="-1">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Program Handling of Errors</title>
<link rel="stylesheet" href="gtm.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="GT.M Programmer's Guide">
<link rel="up" href="ch13.html" title="Chapter 13. Error Processing">
<link rel="prev" href="ch13s04.html" title="Processing Run-time Errors">
<link rel="next" href="ch13s06.html" title="Error Actions">
<link rel="copyright" href="ln-idp184098304.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Program Handling of Errors</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch13s04.html">Prev</a> </td>
<th width="60%" align="center">Chapter 13. Err<span>or</span> Processing</th>
<td width="20%" align="right"> <a accesskey="n" href="ch13s06.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">GT.M Programmer's Guide</a></span> &gt; <span class="breadcrumb-link"><a href="ch13.html">Err<span>or</span> Processing</a></span> &gt; <span class="breadcrumb-node">Program Handling of Errors</span>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="prgrm_handling_of_error"></a>Program Handling of Errors<a class="indexterm" name="idp193419184"></a>
</h2></div></div></div>
<p>GT.M provides the error handling facilities described in the M standard. In addition, GT.M provides a number of extensions for error handling. Both are discussed in the following sections. The following table summarizes some of the tools, which are then described in more detail within the context of various techniques and examples. </p>
<div class="informaltable">
<a name="tblerrext"></a><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr><th colspan="2">
<p>Summary of GT.M Error-Handling Facilities</p>
</th></tr>
<tr>
<th>
<p>EXTENSION</p>
</th>
<th>
<p>EXPLANATION</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>OPEN/USE/CLOSE EXCEPTION</p>
</td>
<td>
<p>Provides a deviceparameter specifying an XECUTE string or entryref that GT.M invokes upon encountering a device-related exception condition.</p>
</td>
</tr>
<tr>
<td>
<p>MUMPS <span>-list</span> ZLINK :"<span>-list</span>"</p>
</td>
<td>
<p>Creates a listing file of all the errors detected by the compiler and detects syntax errors. Useful in the process of re-editing program to correct errors.</p>
</td>
</tr>
<tr>
<td>
<p>ZGoto</p>
</td>
<td>
<p>Provides for removing multiple levels from the M invocation stack.</p>
</td>
</tr>
<tr>
<td>
<p>ZMESSAGE</p>
</td>
<td>
<p>Creates or emulates arbitrary errors.</p>
</td>
</tr>
<tr>
<td>
<p>$STACK</p>
</td>
<td>
<p>Contains the current level of M execution stack depth.</p>
</td>
</tr>
<tr>
<td>
<p>$STACK()</p>
</td>
<td>
<p>Returns values describing aspects of the execution environment.</p>
</td>
</tr>
<tr>
<td>
<p>$ECODE</p>
</td>
<td>
<p>Contains a list of error codes for "active" errors; these are the errors that have occurred, but have not yet been cleared.</p>
</td>
</tr>
<tr>
<td>
<p>$ESTACK</p>
</td>
<td>
<p>Contains an integer count of M virtual machine stack levels that have been activated and not removed, since the last time $ESTACK was NEW'd.</p>
</td>
</tr>
<tr>
<td>
<p>$ETRAP</p>
</td>
<td>
<p>Contains a string value that GT.M invokes when an error occurs during routine execution.</p>
</td>
</tr>
<tr>
<td>
<p>$QUIT</p>
</td>
<td>
<p>Indicates whether the current block of code was called as an extrinsic function or a subroutine.</p>
</td>
</tr>
<tr>
<td>
<p>$ZCSTATUS</p>
</td>
<td>
<p>Holds the value of the status code for the last compilation performed by a ZCOMPILE command.</p>
</td>
</tr>
<tr>
<td>
<p>$ZEDIT</p>
</td>
<td>
<p>Holds the value of the status code for the last edit session invoked by a ZEDIT command.</p>
</td>
</tr>
<tr>
<td>
<p>$ZEOF</p>
</td>
<td>
<p>Holds the value '1' (TRUE) if the last READ on the current device reached end-of-file, otherwise holds a '0' (FALSE).</p>
</td>
</tr>
<tr>
<td>
<p>$ZERROR</p>
</td>
<td>
<p>Contains a string supplied by the application, typically one generated by the code specified in $ZYERROR.</p>
</td>
</tr>
<tr>
<td>
<p>$ZLEVEL</p>
</td>
<td>
<p>Contains current level of DO/EXECUTE nesting ($STACK+1).</p>
</td>
</tr>
<tr>
<td>
<p>$ZMESSAGE()</p>
</td>
<td>
<p>Translates a <span>UNIX</span>/GT.M condition code into text form.</p>
</td>
</tr>
<tr>
<td>
<p>$ZSTATUS</p>
</td>
<td>
<p>Contains the error condition code and location of last exception condition occurring during routine execution.</p>
</td>
</tr>
<tr>
<td>
<p>$ZTRAP</p>
</td>
<td>
<p>Contains an XECUTE string or entryref that GT.M invokes upon encountering an exception condition.</p>
</td>
</tr>
<tr>
<td>
<p>$ZYERROR</p>
</td>
<td>
<p>Contains an entryref to invoke when an error occurs; typically used to maintain $ZERROR.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p></p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ecode_ch14"></a>$ECODE<a class="indexterm" name="idp193450976"></a>
</h3></div></div></div>
<p>The value of $ECODE is a string that may reflect multiple error conditions. As long as no error has occured, the value of $ECODE is equal to the empty string. </p>
<p>$ECODE contains a list of errors codes for "active" errors - the error conditions which are not yet resolved. If there are no active errors, $ECODE contains the empty string. The value of $ECODE can be SET. </p>
<p>The most recent error in $ECODE appears first, the oldest last. If the error is defined by the M standard, the code starts with an "M", GT.M error codes including those provided by OS services start with "Z", and application defined codes must start with "U". Every code is separated by a coma (,) and there is always a coma at the beginning and at the end of a list. GT.M provided codes are those reported in $ZSTATUS, interpreted by $ZMESSAGE() and recognized as arguments to ZMESSAGE command. When GT.M supplies a standard error code in $ECODE, it also supplies a corresponding 'Z' code.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>See <a class="xref" href="ch08s02.html" title="$ECode">&#8220;$ECode&#8221;</a> for a detailed description of $ECODE.</p></td></tr>
</table></div>
<p>Example (setting $ECODE):</p>
<pre class="programlisting">SET $ECODE="" ;sets $ECODE to the empty string
SET $ECODE=",M20," ;an ANSI M standardized error code
SET $ECODE=",U14," ;user defined error code
SET $PIECE($ECODE,",",2)="Z3," ;insert a non-ANSI error code
SET $PIECE($ECODE,",",$LENGTH($ECODE,",")+1)="An..," ;append        </pre>
<p>Standard Error processing affects the flow of control in the following manner. Detection of an error causes GOTO implicit sub-routine. When $ECODE="", the implicit subroutine is $ETRAP and QUIT:$QUIT "" QUIT. Otherwise the implicit subroutine is $ETRAP followed by TROLLBACK:$TLEVEL and then QUIT:$QUIT "" QUIT.</p>
<p>The QUIT command behaves in a special fashion while the value of $ECODE is non-empty. If a QUIT command is executed that returns control to a less nested level than the one where the error occurred, and the value of $ECODE is still non-empty, first all normal activity related to the QUIT command occurs (especially the unstacking of NEWed variables) and then the current value of $ETRAP is executed. Note that, if $ETRAP had been NEWed at the current or intervening level, the unstacked value of $ETRAP is executed.</p>
<p>SETting $ECODE to an invalid value is an error. SETting $ECODE to a valid error behaves like detection of error. SETting $ECODE="" does not cause a change in the flow, but effects $STACK(), subsequent $QUITs and errors.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>To force execution of an error trap or to flag a user-defined error ("U" errors), make the value of $ECODE non-empty:</p>
<pre class="programlisting">SET $ECODE=",U13-User defined error trap,"</pre>
</td></tr>
</table></div>
<p></p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>The value of $ECODE provides information about errors that have occurred since the last time it was reset to an empty string. In addition to the information in this variable, more detailed information can be obtained from the intrinsic function $STACK. <span>For more information, see the section on <a class="xref" href="ch07s21.html" title="$STack()">&#8220;$STack()&#8221;</a></span>.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zstatus_content"></a>$ZSTATUS Content<a class="indexterm" name="idp193503456"></a>
</h3></div></div></div>
<p>$ZSTATUS contains a string value specifying the error condition code and location of the last exception condition that occurred during routine execution.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>For further details, see <a class="xref" href="ch08s55.html" title="$ZStatus">&#8220;$ZStatus&#8221;</a>.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="zerror_and_zyerror"></a>$ZERROR and $ZYERROR<a class="indexterm" name="idp193099568"></a>
</h3></div></div></div>
<p>After an error occurs, if $ZYERROR is set to a valid entryref that exists in the current environment, GT.M invokes the routine at that entryref with an implicit DO before returning control to M code specified by a device EXCEPTION, $ETRAP or $ZTRAP. It is intended that the code invoked by $ZYERROR use the value of $ZSTATUS to select or construct a value to which it SETs $ZERROR.</p>
<p>If $ZYERROR is empty, $ZYERROR="unprocessed $ZERROR, see $ZSTATUS".</p>
<p>If there is a problem with the content of $ZYERROR or if the execution of the code it invokes, GT.M sets $ZERROR=$ZSTATUS for the secondary error and terminates the attempt to use $ZYERROR. During code evoked by $ZYERROR, the value of $ZERROR is the empty string.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="etrap_behavior"></a>$ETRAP Behavior<a class="indexterm" name="idp193470544"></a>
</h3></div></div></div>
<p>If, at the time of any error, the value of $ETRAP is non-empty, GT.M proceeds as if the next instruction to be excuted were the first one on "the next line" and the code on that next line would be the same as the text in the value of $ETRAP. Furthermore, GT.M behaves as if the line following "the next line" looks like:</p>
<pre class="programlisting">QUIT:$QUIT "" QUIT</pre>
<p>When SET assigns a value to $ETRAP, the new value replaces the previous value, and if $ZTRAP was not empty (in control), the value of $ZTRAP becomes equal to the empty string without being stacked.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="nesting_etrap_and_using_estack"></a>Nesting $ETRAP and using $ESTACK<a class="indexterm" name="idp193481568"></a>
</h3></div></div></div>
<p>When you need to set up a stratified scheme where one level of subroutines use one error trap setting and another more nested subroutine uses a different one; the more nested subroutine must NEW $ETRAP. When $ETRAP is NEWed, its old value is saved and copied to the current value. A subsequent SET $ETRAP=&lt;new-value&gt; then establishes the error trapping code for the current execution level.</p>
<p>The QUIT command that reverts to the calling routine causes the NEWed values to be unstacked, including the one for $ETRAP.</p>
<p>If an error occurs while executing at the current execution level (or at an execution level farther from the initial base stack frame), GT.M executes the code from the current $ETRAP. Unless a GOTO or ZGOTO in $ETRAP or any code it invokes redirects the flow of execution, when the execution of the $ETRAP code completes, control reverts to the implicit QUIT command, which returns to the routine that invoked the code that encountered the error. At this time, the QUIT reinstates any prior value of $ETRAP.</p>
<p>While at the more nested execution level(s), if an error occurs, GT.M executes the code from the current $ETRAP. After the QUIT to a less nested level, GT.M invokes the code from the now current $ETRAP. The current $ETRAP may be different from the $ETRAP at the time of the error due to unstacking. This behavior continues until one of the following possible situations occur:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>$ECODE is empty. When the value of $ECODE is equal to the empty string, error processing is no longer active, and normal processing resumes.</p></li>
<li class="listitem" style="list-style-type: circle"><p>A QUIT reaches an execution level where the value of $ETRAP is empty ($ZTRAP might be non-empty at that level). When the values of both $ZTRAP and $ETRAP are equal to the empty string, no error trapping is active and the QUIT repeats until it unstacks a $ETRAP or $ZTRAP.</p></li>
<li class="listitem" style="list-style-type: circle"><p>The stack is reduced to an empty state. When there is no previous level left to QUIT into, GT.M returns to the operating system level shell. A frame that is in direct mode stops the process by putting the user back into the Direct Mode shell.</p></li>
</ul></div>
<p>When dealing with stratified error trapping, it is important to be aware of two additional intrinsic variables: $STACK and $ESTACK. The values of both of these variables indicate the current execution level. The value of $STACK is an "absolute" value that counts from the start of the GT.M process, whereas the value of $ESTACK restarts at zero (0) each time $ESTACK is NEWed.</p>
<p>It is often beneficial to NEW both $ETRAP and $ESTACK a the same time.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ztrap_behavior"></a><span>$ZTRAP </span>Behavior<a class="indexterm" name="idp193450688"></a>
</h3></div></div></div>
<p>If, at the time of any error, the value of $ZTRAP is non-empty, GT.M uses the $ZTRAP contents to direct execution of the next action.<span>Refer to the $ZTRAP section in <a class="xref" href="ch08.html" title="Chapter 8. Intrinsic Special Variables">Chapter 8: &#8220;<i><span>Intrinsic Special Variables</span></i>&#8221;</a>.</span> </p>
<p>By default, execution proceeds as if the next instruction to be executed were the first one on "the next line", and the code on that next line would be the same as the text in the value of $ZTRAP. Unless $ZTRAP or any code it invokes issues a GOTO or ZGOTO, after GT.M has executed the code in $ZTRAP, GT.M attempts to execute the line with the error again. When a value is assigned to $ZTRAP, the new value replaces the previous value. If the value of $ETRAP is a non-empty one, $ETRAP is implicitly NEWed, and the value of $ETRAP becomes equal to the empty string; this ensures that at most one of $ETRAP and $ZTRAP is not the empty string. If the <span>environment variable</span> gtm_ztrap_new evaluates to Boolean TRUE (case insensitive string "TRUE", or case insensitive string "YES", or a non-zero number), $ZTRAP is NEWed when $ZTRAP is SET; otherwise $ZTRAP is not stacked when it is SET.</p>
<p>Other than the default behavior, $ZTRAP settings are controlled by the <span>environment variable</span> gtm_ztrap_form as described in the following table.</p>
<div class="informaltable">
<a name="tblztrapset"></a><table border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
<p>gtm_ztrap_form</p>
</th>
<th>
<p>$ZTRAP and EXCEPTION Behavior</p>
</th>
</tr></thead>
<tbody>
<tr>
<td>
<p>code</p>
</td>
<td>
<p>Content is code executed after the error; in the absence of GOTO, ZGOTO, or QUIT, execution resumes at the beginning of the line containing the error - note that the default behavior tends to create an indefinite loop.</p>
</td>
</tr>
<tr>
<td>
<p>entryref</p>
</td>
<td>
<p>Content is an entryref to which control is transferred by an implicit GOTO</p>
</td>
</tr>
<tr>
<td>
<p>adaptive</p>
</td>
<td>
<p>If content is valid code treat it as described for "code", otherwise attempt to treat it as an entryref</p>
</td>
</tr>
<tr>
<td>
<p>popentryref</p>
</td>
<td>
<p>Content is entryref - remove M virtual stack levels until the level at which $ZTRAP was SET, then GOTO the entryref; the stack manipulation occurs only for $ZTRAP and not for EXCEPTION</p>
</td>
</tr>
<tr>
<td>
<p>popadaptive</p>
</td>
<td>
<p>If content is valid code treat it as described for code, otherwise attempt to treat it as an entryref used as described for popentryref</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>Although the "adaptive" and "popadaptive" behaviors permit mixing of two behaviors based on the current value of $ZTRAP, the $ZTRAP behavior type is selected at process startup from gtm_ztrap_form and cannot be modified during the life of the process.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left"></th>
</tr>
<tr><td align="left" valign="top"><p>Like $ZTRAP values, invocation of device EXCEPTION values, with the exception noted, follow the pattern specified by the current gtm_ztrap_form setting.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="diff_btw_etrap_and_ztrap"></a><span>Differences between </span>$ETRAP and $ZTRAP<a class="indexterm" name="idp193532352"></a>
</h3></div></div></div>
<p>The activation of $ETRAP and $ZTRAP are the same, however there are a number of differences in their subsequent behavior.</p>
<p>For subsequent errors the then current $ZTRAP is invoked, while with $ETRAP, behavior is controlled by the state of $ECODE. This means that when using $ZTRAP, it is important to change $ZTRAP, possibly to the empty string, at the beginning of the action in order to protect against recursion caused by any errors in $ZTRAP itself or in the code it invokes.</p>
<p>If there is no explicit or implicit GOTO or ZGOTO in the action, once a $ZTRAP action completes, execution resumes at the beginning of the line where the error occurred, while once a $ETRAP action completes, there is an implicit QUIT. This means that $ZTRAP actions that are not intended to permit a successful retry of the failing code should contain a GOTO, or more typically a ZGOTO. In contrast, $ETRAP actions that are intended to cause a retry must explicitly reinvoke the code where the error occurred.</p>
<p>For QUITs from the level at which an error occurred, $ZTRAP has no effect, where $ETRAP behavior is controlled by the state of $ECODE. This means that to invoke an error handler nested at the lower level, $ZTRAP actions need to use an explicit ZMESSAGE command, while $ETRAP does such invocations implicitly unless $ECODE is SET to the empty string.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="ztrap_idnt_with_etrap"></a>$ZTRAP <span>Interaction </span>With $ETRAP<a class="indexterm" name="idp193458688"></a>
</h3></div></div></div>
<p>It is important to be aware of which of the trap mechanisms is in place to avoid unintended interactions, and aware of which conditions may cause a switch-over from one mode of error handling to the other.</p>
<p>When a SET command assigns a value to either $ZTRAP or $ETRAP, GT.M examines the value of the other error handling variable. If the other value is non-empty, GT.M executes an implicit NEW command that saves the current value of that variable, and then assigns that variable to the empty string, then makes the requested assignment effective. </p>
<p>For example, re-setting $ETRAP is internally processed as:</p>
<pre class="programlisting">NEW:$LENGTH($ZTRAP) $ZTRAP $ETRAP SET $ETRAP=code        </pre>
<p>Whereas, SET $ZTRAP=value is internally processed as:</p>
<pre class="programlisting">NEW:$LENGTH($ETRAP) $ETRAP SET:$LENGTH($ETRAP)="" SET $ZTRAP=value</pre>
<p>Note that, after saving the prior value, GT.M ensures the superseded $ETRAP or $ZTRAP implicitly gets the value of the empty string. As a result, at most one of the two error handling mechanisms can be effective at any given point in time. </p>
<p>If an error handling procedure was invoked through the $ETRAP method, and the value of $ECODE is non-empty when QUITing from the level of which the error occurred, the behavior is to transfer control to the error handler associated with the newly unstacked level. However, if the QUIT command at the end of error level happens to unstack a saved value of $ZTRAP (and thus cause the value of $ETRAP to become empty), the error handling mechanism switches from $ETRAP-based to $ZTRAP-based.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>At the end of an error handling procedure invoked through $ZTRAP, the value of $ECODE is not examined, and this value (if any) does not cause any transfer to another error handling procedure. However, if not cleared it may later trigger a $ETRAP unstacked by a QUIT.</p></td></tr>
</table></div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="choosing_etrap_and_ztrap"></a><span>Choosing </span>$ETRAP or $ZTRAP<a class="indexterm" name="idp193542208"></a>
</h3></div></div></div>
<p>Making a choice between the two mechanisms for error handling is mostly a matter of compatibility. If compatibility with existing GT.M code is important, and that code happens to use $ZTRAP, then $ZTRAP is the best effort choice. If compatibility with code written in MUMPS dialects from other vendors is important, then $ETRAP or a non-default form of $ZTRAP probably is the better choice.</p>
<p>When no pre-existing code exists that favors one mechanism, the features of the mechanisms themselves should be examined. </p>
<p>Almost any effect that can be achieved using one mechanism can also be achieved using the other. However, some effects are easier to achieve using one method, and some are easier using with the other. </p>
<p>If the mechanisms are mixed, or there is a desire to refer to $ECODE in an environment using $ZTRAP, it is recommended to have $ZTRAP error code SET $ECODE="" at some appropriate time, so that $ECODE does not become cluttered with errors that have been successfully handled.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>A device EXCEPTION gets control after a non-fatal device error and $ETRAP/$ZTRAP get control after other non-fatal errors.</p></td></tr>
</table></div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="example1_return_cntrl"></a>Example 1: Returning control to a specific execution level<a class="indexterm" name="idp193536608"></a>
</h4></div></div></div>
<p>The following example returns control to the execution level "level" and then to an error processing routine "proc^prog".</p>
<p>With $ZTRAP: Set $ZTRAP="ZGOTO "_level_":proc^prog"</p>
<p>With $ETRAP: Set $ETRAP="Quit:$STACK&gt;"_level_" Do proc^prog"</p>
<p>Note that, ZGOTO can be used with $ETRAP and $STACK with $ZTRAP. Alternatively if $ESTACK were NEWed at LEVEL:</p>
<pre class="programlisting">Set $ETRAP="Quit:$ESTACK&gt;0 Do proc^prog"</pre>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="example2_ignoring"></a>Example 2: Ignoring an Error<a class="indexterm" name="idp193526112"></a>
</h4></div></div></div>
<p>With $ZTRAP: Set $ZTRAP="Quit"</p>
<p>With $ETRAP: Set $ETRAP="Set $ECODE="""" Quit"</p>
<p>Note that, while it is not necessary to SET $ECODE="" when using $ZTRAP it is advisable to do it in order to permit mixing of the two mechanisms.</p>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="nested_err_hndl"></a>Example 3: Nested Error Handlers<a class="indexterm" name="idp193564496"></a>
</h4></div></div></div>
<p>With $ZTRAP: New $ZTRAP Set $ZTRAP=...</p>
<p>With $ETRAP: New $ETRAP Set $ETRAP=...</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>In both cases, QUITting to a lower level may effectively make the other mechanism active.</p></td></tr>
</table></div>
</div>
<div class="sect3">
<div class="titlepage"><div><div><h4 class="title">
<a name="example4_access_to_cause_of_error"></a>Example 4: Access to "cause of error"<a class="indexterm" name="idp193570272"></a>
</h4></div></div></div>
<p>With $ZTRAP: If $ZSTATUS[...</p>
<p>With $ETRAP: If $ECODE[...</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>The value of $ZSTATUS reflects only the most recent error, while the value of $ECODE is the cumulative list of all errors since its value was explicitly set to empty. Both values are always maintained and can be used with either mechanism.</p></td></tr>
</table></div>
</div>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="err_proc_caution"></a>Error Processing Cautions<a class="indexterm" name="idp193431872"></a>
</h3></div></div></div>
<p>$ETRAP and $ZTRAP offer many features for catching, recognizing, and recovering from errors. Code within an error processing subroutines may cause its own errors and these need to be processed without causing an infinite loop (where an error is caught, which, while being processed causes another error, which is caught, and so on).</p>
<p>During the debugging phase, such loops are typically the result of typographical errors in code. Once these typographical errors are corrected, the risk remains that an error trapping subroutine was designed specifically to deal with an expected condition; such as the loss of a network connection. This then creates an unexpected error of its own, such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>a device that had not yet been opened because the loss of network connectivity occured sooner than expected</p></li>
<li class="listitem" style="list-style-type: circle"><p>an unexpected data configuration caused by the fact that an earlier instance of the same program did not complete its task for the same reason</p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Note">
<tr>
<td rowspan="2" align="center" valign="top" width="12pt"><img alt="[Note]" src="images/note.html"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>It is important to remain aware of any issues that may arise within an error trapping procedure, and also of the conditions that might cause the code in question to be invoked.</p></td></tr>
</table></div>
<p>$ETRAP is recursively invoked if it invokes a GOTO or a ZGOTO and the error condition persists in the code path and the code SETs $ECODE="". $ZTRAP is recursively invoked if the error condition persists in the code path.</p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="input_output_errors"></a><span>Input/Output </span>Errors<a class="indexterm" name="idp193571888"></a>
</h3></div></div></div>
<p>When GT.M encounters an error in the operation of an I/O device, GT.M executes the EXCEPTION deviceparameter for the OPEN/USE/CLOSE commands. An EXCEPTION deviceparameter specifies an action to take when an error occurs in the operation of an I/O device. The form of the EXCEPTION action is subject to the gtm_ztrap_form setting described for $ZTRAP, except that there is never any implicit popping with EXCEPTION actions. If a device has no current EXCEPTION, GT.M uses $ETRAP or $ZTRAP to handle an error from that device. </p>
<p>GT.M provides the option to:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="opencircle">
<li class="listitem" style="list-style-type: circle"><p>Trap or process an exception based on device error.</p></li>
<li class="listitem" style="list-style-type: circle"><p>Trap or process an exception based on terminal input.</p></li>
</ul></div>
<p>An EXCEPTION based on an error for the device applies only to that device, and provides a specific error handler for a specific I/O device.</p>
<p>The CTRAP deviceparameter for USE establishes a set of trap characters for terminal input. When GT.M encounters an input character in that set, GT.M executes the EXCEPTION deviceparamenter, or, $ETRAP or $ZTRAP if the device has no current EXCEPTION.</p>
<p>Example:</p>
<pre class="programlisting">GTM&gt;ZPRINT ^EP12
EP12    WRITE !,"THIS IS ",$TEXT(+0)
        SET $ECODE="";this only affects $ETRAP
        SET $ETRAP="GOTO ET"
        ;N $ZT S $ZT="W !,"CAN'T TAKE RECIPROCAL OF 0"",*7"
        USE $P:(EXCEPTION="D BYE":CTRAP=$C(3))
        WRITE !,"TYPE &lt;CTRL-C&gt; TO STOP"
LOOP    FOR DO
        . READ !,"TYPE A NUMBER: ",X
        . WRITE ?20,"HAS RECIPROCAL OF: ",1/X
        . QUIT
ET      . WRITE !,"CAN'T TAKE RECIRPOCAL OF 0",*7
        . SET $ECODE=""
        QUIT
BYE     WRITE !,"YOU TYPED &lt;CTRL-C&gt; YOU MUST BE DONE!"
        USE $P:(EXCEPTION="":CTRAP="")
        WRITE !,"$ZSTATUS=",$ZSTATUS
        ZGOTO 1
GTM&gt;DO ^EP12
THIS IS EP12
TYPE &lt;CTRL-C&gt; TO STOP
TYPE A NUMBER: 1 HAS RECIPROCAL OF: 1
TYPE A NUMBER: 2 HAS RECIRPOCAL OF: .5
TYPE A NUMBER: 3 HAS RECIPROCAL OF: .33333333333333
TYPE A NUMBER: 4 HAS RECIPROCAL OF: .25
TYPE A NUMBER: HAS RECIPROCAL OF:
CAN'T TAKE RECIPROCAL OF 0
TYPE A NUMBER:
YOU TYPED &lt;CTRL-C&gt; YOU MUST BE DONE!
$ZSTATUS=150372498,LOOP+1^EP12,%GTM-E-CTRAP,Character trap $C(3) encountered
GTM&gt;</pre>
<p>This routine prompts the user to enter a number at the terminal. If the user enters a zero, GT.M encounters an error and executes $ETRAP (or $ZTRAP). The action specified reports the error and returns to prompt the user to enter a number. With $ZTRAP, this is very straightforward. With $ETRAP, some care is required to get the code to resume at the proper place. The CTRAP deviceparameter establishes &lt;CTRL-C&gt; as a trap character. When GT.M encounters a &lt;CTRL-C&gt;, GT.M executes the EXCEPTION string whcih transfers control to the label BYE. At the label BYE, the routine terminates execution with an error message. Using the EXCEPTION deviceparameter with CTRAP generally simplifies $ETRAP or $ZTRAP handling.</p>
<p>$ZSTATUS allows the routine to find out which trap character GT.M encountered. When a routine has several character traps set, $ZSTATUS provides useful information for identifying which character triggered the trap, and thereby allows a custom response to a specific input.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch13s04.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ch13.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="ch13s06.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Processing Run-time<span> Errors</span> </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Error Actions</td>
</tr>
</table>
</div>
</body>

<!-- Mirrored [from host tinco.pair.com [file /bhaskar/gtm/doc/books/pg/UNIX_manual/ch13s05.html]] -->
</html>
