<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>GT.M Security Philosophy and Implementation</title><link rel="stylesheet" href="e-novative_article.css" type="text/css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"></meta><meta name="description" content="
				
									
										
					                        GT.M Group
					                        Fidelity National Information Services, Inc.
					                        2 West Liberty Boulevard, Suite 300
					                        Malvern, PA 19355
					                        United States of America
					                     
									
								
									
										
											GT.M Support: +1 (610) 578-4226
											Switchboard: +1 (610) 296-8877
											Fax: +1 (484) 595-5101
											Website: http://fis-gtm.com
											Email: gtmsupport@fnis.com 
																					
										
									
								
			"></meta></head><body><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="id2292777"></a><a id="return_to_top"></a>GT.M Security Philosophy and Implementation</h1></div><div><h3 class="subtitle"><i>Technical Bulletin</i></h3></div><div><p class="copyright">Copyright (C) 2010 Fidelity National Information Services, Inc.</p></div><div><div xmlns="" align="center"><a href="legalnotice.html" target="_blank">Legal Notice</a></div></div><div><p class="pubdate">February 02, 2010</p></div><div><div xmlns="" class="revhistory"><table border="1" align="center" width="70%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.1</td><td align="left">February 02, 2010</td></tr><tr><td align="left" colspan="2">
  <p xmlns="http://www.w3.org/1999/xhtml">Updated to reflect changes through V5.4-000, specifically security enhancements around shared resources and GT.M triggers.  Other minor changes to clean up language and improve presentation.</p>
</td></tr><tr><td align="left">Revision 1.0</td><td align="left">Dec 31, 2008</td></tr><tr><td align="left" colspan="2">
  <p xmlns="http://www.w3.org/1999/xhtml">Original version, reflecting V5.3-003</p>
</td></tr></table></div></div><div><div class="abstract"><p class="title"><b></b></p><p>
				<div class="informaltable"><table border="0" width="100%"><colgroup><col></col><col></col></colgroup><tbody><tr><td align="left" valign="top">
									<p>
										<div class="address"><p><br></br>
					                        GT.M Group<br></br>
					                        Fidelity National Information Services, Inc.<br></br>
					                        <span class="street">2 West Liberty Boulevard, Suite 300</span><br></br>
					                        <span class="city">Malvern, </span><span class="state">PA </span><span class="postcode">19355</span><br></br>
					                        <span class="country">United States of America</span><br></br>
					                     </p></div>
									</p>
								</td><td align="left" valign="top">
									<p>
										<div class="address"><p><br></br>
											<span class="phone">GT.M Support: +1 (610) 578-4226</span><br></br>
											<span class="phone">Switchboard: +1 (610) 296-8877</span><br></br>
											<span class="fax">Fax: +1 (484) 595-5101</span><br></br>
											Website: <a href="http://www.fis-gtm.com" target="_top">http://fis-gtm.com</a><br></br>
											Email: <a href="mailto:gtmsupport@fnis.com" target="_top">gtmsupport@fnis.com</a> <br></br>
																					<br></br>
										</p></div>
									</p>
								</td></tr></tbody></table><a id="toc"></a></div>
			</p></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="GTM_Security_Philosophy.html#id2293238">Philosophy</a></span></dt><dt><span class="sect1"><a href="GTM_Security_Philosophy.html#id2293734">Normal User and Group Id Rule</a></span></dt><dd><dl><dt><span class="sect2"><a href="GTM_Security_Philosophy.html#id2293751">Exceptions</a></span></dt><dd><dl><dt><span class="sect3"><a href="GTM_Security_Philosophy.html#id2293638">Shared Memory Exception for BG</a></span></dt><dt><span class="sect3"><a href="GTM_Security_Philosophy.html#id2294042">gtmsecshr Exception</a></span></dt></dl></dd><dt><span class="sect2"><a href="GTM_Security_Philosophy.html#id2294173">Triggers</a></span></dt></dl></dd><dt><span class="sect1"><a href="GTM_Security_Philosophy.html#id2293917">Recommendations</a></span></dt><dt><span class="appendix"><a href="GTM_Security_Philosophy.html#id2294424">A. gtmsecshr commands</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><p xmlns="" class="returntotop"><a xmlns="http://www.w3.org/1999/xhtml" href="GTM_Security_Philosophy.html#id2292777">Return to top</a></p><div><h2 class="title"><a id="id2293238"></a>Philosophy</h2></div></div></div><p><span class="underline">The general GT.M philosophy is to use the security of the underlying operating system,</span> and to neither subvert it nor extend it.  The purpose of this document is to discuss the implications of, exceptions to, and limitations of this philosophy (the "security model").  This document reflects GT.M as of V5.4-000.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></img></td><th align="left"></th></tr><tr><td align="left" valign="top"> GT.M is not intended to operate robustly on a machine that is potentially subject to direct attack, such as a firewall, or a machine operating in a "DMZ."</td></tr></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><p xmlns="" class="returntotop"><a xmlns="http://www.w3.org/1999/xhtml" href="GTM_Security_Philosophy.html#id2292777">Return to top</a></p><div><h2 class="title"><a id="id2293734"></a>Normal User and Group Id Rule</h2></div></div></div><p>GT.M processes run with normal UNIX<sup>[<a id="id2294150" href="GTM_Security_Philosophy.html#ftn.id2294150">1</a>]</sup> user and group ids.  GT.M has no database daemon that needs to run with elevated privileges.  Process code written in M will be able to read a database file if and only if the process has read permission for that database file, and to update that database file if and only if the process has read/write permission for that database file.<sup>[<a id="id2293733" href="GTM_Security_Philosophy.html#ftn.id2293733">2</a>]</sup></p><p>There are two exceptions to this rule.  Also, special mention is made of GT.M triggers, which require awareness of their behavior even though they comply with the Normal User and Group Id Rule.</p><div class="sect2" lang="en"><div class="titlepage"><div><p xmlns="" class="returntotop"><a xmlns="http://www.w3.org/1999/xhtml" href="GTM_Security_Philosophy.html#id2292777">Return to top</a></p><div><h3 class="title"><a id="id2293751"></a>Exceptions</h3></div></div></div><p>Exceptions to the Normal User and Group Ids Rule exist for:</p><div class="itemizedlist"><ul><li><p>Shared Memory when the Buffered Global (BG) access method is used, and</p></li><li><p>gtmsecshr.</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2293638"></a>Shared Memory Exception for BG</h4></div></div></div><p>With the BG access method, each open database file has a shared memory segment associated with it.  This shared memory contains a pool of disk blocks (the global buffers) as well as associated control structures (for example, for concurrency control).  Even a process that has read-only permission to the database file requires read-write access to the associated shared memory in order to use the control structures.  It is therefore possible for a cached disk block in shared memory to be modified by one process and for the actual write of that dirty block to disk to be performed by another.  Thus, a "rogue" process with read-only access to the database file but read-write access to shared memory can modify the cached copy of a disk block and effect a permanent change to the database when that block is written to disk by another process that has read-write access to the database file.</p><p>Comments on the Shared Memory Exception for BG:</p><div class="itemizedlist"><ul><li><p>This only applies if a mumps process contains non-M code.  If a mumps processes has only M code, the GT.M run-time environment will not allow a process to modify a database for which it lacks write permission.</p></li><li><p>This only applies if a database file has mixed read-only and read-write access, that is, some mumps processes have read-only access and others have read-write access.  If all processes have read-only access, although the database may appear to be temporarily modified when copies of blocks in shared memory are modified, the database file on disk cannot be permanently modified because no process will have the required permission to flush dirty blocks to disk.</p></li><li><p>Where processes that contain C code and have read-only database access must co-exist with processes that have read-write access, GT.M will only "keep honest processes honest."  [See below for recommendations where read-only access is required by processes that cannot be considered trustworthy.]</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2294042"></a>gtmsecshr Exception</h4></div></div></div><p>Processes with normal user and group ids do not have adequate permissions to effect necessary GT.M interprocess communication and cleanup after abnormal process termination.  A process called gtmsecshr runs as root in order to effect the following functionality:</p><div class="itemizedlist"><ul><li><p>Interprocess communication, including sending <code class="code">SIGALARM</code> and <code class="code">SIGCONT </code> between processes where normal UNIX permissions do not permit such signals to be sent.</p></li><li><p>Cleanup after processes that terminate abnormally, including removing semaphores, shared memory segments, and flushing database file headers (but not database blocks) from shared memory segments to disk.</p></li></ul></div><p>Whenever a GT.M process lacks adequate permissions to effect any of the above operations, it automatically invokes <code class="code">gtmsecshr </code>if it is not already running. A complete list of <code class="code">gtmsecshr </code> functionality appears in the appendix.</p><p>In order to run as root, and to be invoked by a process that has normal user and group ids, the invocation chain for <code class="code">gtmsecshr</code> requires an executable image that is owned by root and which has the <code class="code">setuid</code> bit turned on in its file permissions.</p><p>Once started and running, <code class="code">gtmsecshr </code> records information in a log file <code class="code">gtm_secshr_log </code>(in a directory specified by <code class="code">$gtm_log</code>), creating it if it does not exist.  <code class="code">$gtm_log</code> is inherited from the environment of the GT.M process (<code class="code">mumps</code>, <code class="code">mupip</code> or <code class="code">dse</code>) that first invokes the <code class="code">gtmsecshr</code> process.  If the environment variable <code class="code">$gtm_log</code> is undefined, if its value is longer than GT.M can handle, or if it is defined to a value that is not an absolute pathname (starting with a /), <code class="code">$gtm_log</code> is assumed to be the directory /tmp (AIX, GNU/Linux, Tru64 UNIX) or /var/tmp (HP-UX, Solaris).</p><p>Communication between GT.M processes and <code class="code">gtmsecshr</code> uses socket files in <code class="code">$gtm_tmp</code>, which is also inherited from the GT.M process that first invokes <code class="code">gtmsecshr</code>. If the environment variable <code class="code">$gtm_tmp</code> is undefined, if its value is longer than GT.M can handle, or if it is defined to a value that is not an absolute pathname (starting with a /), <code class="code">$gtm_tmp</code> is assumed to be the directory <code class="code">/tmp</code> (AIX, GNU/Linux, Tru64 UNIX) or /var/tmp (HP-UX, Solaris).</p><p>The<code class="code"> gtmsecshr </code>process receives messages via a socket file owned by root with a name of the form <code class="code">gtm_secshrnnnnnnnn</code>, the <code class="code">nnnnnnnn</code> being replaced by the hexadecimal <code class="code">ftok</code> value of the <code class="code">gtmsecshr</code> executable file.  This value is reported by the GT.M ftok utility on the <code class="code">gtmsecshr</code> file, for example, <code class="code">$gtm_dist/ftok $gtm_dist/gtmsecshr</code></p><p>GT.M processes receive responses from <code class="code">gtmsecshr </code>via socket files owned by the <code class="code">userid</code> of the process with names of the form <code class="code">gtm_secshrnnnnnnnn</code>, where <code class="code">nnnnnnnn</code> is a hexadecimal version of the client's process id, padded with leading zeroes.  When a client process terminates abnormally, or is killed before it cleans up its socket file, it is possible for a subsequent client with the same process id but a different userid to be unable to delete the leftover socket file.  In this case, it tries to send a message to <code class="code">gtmsecshr</code> using a slightly modified client socket file of the form <code class="code">gtm_secshrnnnnnnnnx</code> where x starts with "a" whose corresponding socket file does not already exist or is removable by the current client process (if all suffixes "a" through "z" are unavailable, the client process errors out with a <code class="code">"Too many leftover client socket files"</code> message). <code class="code">gtmsecshr </code>recognizes this special modified socket file name, and as part of servicing the client's request deletes the <code class="code">gtm_secshrnnnnnnnn</code> socket file and all <code class="code">gtm_secshrnnnnnnnnx</code> files that exist.  The client process expects this file removal  and creates a new <code class="code">gtm_secshrnnnnnnnn</code> file for subsequent communications with <code class="code">gtmsecshr</code>.</p><div class="itemizedlist"><ul><li><p>When there is no <code class="code">gtmsecshr</code> process running, by starting one up with incorrect values of <code class="code">$gtm_log</code> and <code class="code">$gtm_tmp</code>, a <code class="code">gtmsecshr</code> process can be made to create a file called gtm_secshr_log in any directory.  Having incorrect values can also interfere with normal GT.M operations until the incorrect <code class="code">gtmsecshr</code> process times out and terminates, because GT.M processes and gtmsecshr will be unable to communicate with one another.</p></li><li><p>gtmsecshr can be made to delete client socket files by a rogue process. If a socket file is deleted under a running GT.M process, <code class="code">gtmsecshr</code> will be unable to reply to the process. It will timeout, create another and proceed.  Thus, while GT.M performance of a single process may temporarily be slowed, system operation will not be disrupted.</p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><p xmlns="" class="returntotop"><a xmlns="http://www.w3.org/1999/xhtml" href="GTM_Security_Philosophy.html#id2292777">Return to top</a></p><div><h3 class="title"><a id="id2294173"></a>Triggers</h3></div></div></div><p>A GT.M trigger is a code fragment stored in the database file that all processes performing a matching update to a global variable in that file execute automatically, for example, to maintain cross-reference indexes and referential integrity.  Any process that has read-write permission for a database file can change the triggers in that database file, which can in turn force other processes updating that database to execute the changed triggers.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><p xmlns="" class="returntotop"><a xmlns="http://www.w3.org/1999/xhtml" href="GTM_Security_Philosophy.html#id2292777">Return to top</a></p><div><h2 class="title"><a id="id2293917"></a>Recommendations</h2></div></div></div><p>Based on the security model, the following are recommended best practices for securing GT.M.</p><div class="orderedlist"><ol type="1"><li><p>Secure the machine on which GT.M operates behind layers of defenses that permit only legitimate accesses.</p></li><li><p>Restrict access to a system on which GT.M runs to those who legitimately need it.</p></li><li><p>If not all users who have access to a system require the ability to run GT.M, limit access to GT.M to a group to which all users who need access belong, and remove world access to GT.M.<sup>[<a id="id2293738" href="GTM_Security_Philosophy.html#ftn.id2293738">3</a>]</sup>.  If such a group is called <code class="code">gtmusers</code>, the following command executed as root will accomplish this, if access was not restricted when GT.M was installed: <code class="code">chgrp -R gtmusers $gtm_dist ; chmod -R o-rwx $gtm_dist</code></p></li><li><p>Ensure that database file ownership (user and group), UNIX user and group ids, and permissions at the UNIX level match the intended access.  If finer grained access controls than those provided by user and group ids and permissions are needed, consider using Access Control Lists (ACLs) where they are available.</p></li><li><p>Under typical conditions, GT.M shared resources - journal files, shared memory, and semaphores - have the same group ids and access permissions as their database files, but may not be owned by the same userid, since the process creating the shared resource may have a different <code class="code">userid </code> from the one that created the database.  There are two edge cases to consider:</p><div class="itemizedlist"><ul><li><p>Where the owner of the database file is not a member of the group of the database file, but is a member of the group GT.M's <code class="code">libgtmshr.so</code> file.  In this case, if a process with a <code class="code">userid</code> other than the owner were to create a shared resource, a process with the <code class="code">userid </code>of the owner would not have access to them.  Therefore, GT.M uses the group id of the <code class="code">libgtmshr.so</code> file if the process creating the shared resource is also a member of that group.  In this case it would also restrict access to the resource to members of that group.  If the process creating this resource is not a member of the <code class="code">libgtmshr.so</code> group, the group id of the shared resource remains that of the creating resource but the permissions allow world access.  FIS advises against using a database file whose owner is not a member of the group of that file. </p></li><li><p>Where the owner of the database file is neither a member of the group nor a member of the group of <code class="code">libgtmshr.so</code>.  In this case, GT.M uses world read-write permissions for the shared resources.  FIS advises against the use of a database file whose owner is neither a member of the group of the file nor a member of the group of <code class="code">libgtmshr.so.</code></p></li></ul></div></li><li><p>The Mapped Memory (MM) access method does not use a shared memory segment for a buffer pool for database blocks - shared memory is used only for control structures.  Therefore, consider using MM if there are processes that are are not considered trustworthy but which need read-only access to database files.<sup>[<a id="id2294400" href="GTM_Security_Philosophy.html#ftn.id2294400">4</a>]</sup></p></li><li><p>If MM cannot be used, and processes that are not considered trustworthy need read-only access to database files, run those processes on a replicating instance specifically set up for that purpose.</p></li><li><p>If a database file does not change during normal operation (for example, it contains configuration parameters), make its permissions read only for everyone.  On rare occasions when they need to be changed, shut down the application to get stand-along access, temporarily make it read-write, make the changes, and then make it read-only once more.</p></li><li><p>GT.M by default uses a wrapper for <code class="code">gtmsecshr</code>.  Source code for the wrapper is published.  If processes that startup <code class="code">gtmsecshr</code> cannot be trusted or coerced to have the correct values of <code class="code">$gtm_log and $gtm_tmp</code>, modify the source code to set <code class="code">$gtm_log</code> and <code class="code">$gtm_tmp</code> to required values, recompile and reinstall your modified wrapper.</p></li><li><p>Consider implementing layered security software if it exists for your platform, for example, SELinux, Trusted Solaris, Trusted AIX.</p></li></ol></div></div><div class="appendix" lang="en"><h2 class="title"><a id="id2294424"></a>A. gtmsecshr commands</h2><div class="informaltable"><table border="1"><colgroup><col></col><col></col><col></col></colgroup><tbody><tr><td>
               <p>Commands</p>
            </td><td>
               <p>Action</p>
            </td><td>
               <p>Comments</p>
            </td></tr><tr><td>
		    <p><code class="code">WAKE_MESSAGE</code></p>
            </td><td>
		    <p>Sends <code class="code">SIGALRM</code> to specified process.</p>
            </td><td>
               <p>Used to inform receiving process that a resource (such as a critical section) it awaits has become available.</p>
            </td></tr><tr><td>
		    <p><code class="code">CONTINUE_PROCESS</code></p>
            </td><td>
		    <p>Sends <code class="code">SIGCONT</code> to specified process.</p>
            </td><td>
		    <p>Used to awake a process that has been suspended while holding a resource. <sup>[<a id="id2294686" href="GTM_Security_Philosophy.html#ftn.id2294686">a</a>]</sup></p>
            </td></tr><tr><td>
		    <p><code class="code">CHECK_PROCESS_ALIVE</code></p>
            </td><td>
		    <p>Test sending a signal to specified process. <sup>[<a id="id2294511" href="GTM_Security_Philosophy.html#ftn.id2294511">b</a>]</sup></p>
            </td><td>
               <p>Used to determine if a process owning a resource still exists; if not, the resource is available to be grabbed by another process that needs it.</p>
            </td></tr><tr><td>
		    <p><code class="code">REMOVE_SEM</code></p>
            </td><td>
               <p>Remove a specified POSIX semaphore.</p>
            </td><td>
               <p>Used to remove an abandoned semaphore (for example, if the last attached process terminated abnormally).</p>
            </td></tr><tr><td>
		    <p><code class="code">REMOVE_SHMMEM</code></p>
            </td><td>
               <p>Remove a specified shared memory segment.</p>
            </td><td>
               <p>Used to remove an abandoned shared memory segment. Before removing the segment, gtmsecshr checks that there are no processes attached to it.</p>
            </td></tr><tr><td>
		    <p><code class="code">REMOVE_FILE</code></p>
            </td><td>
               <p>Remove a specified file.</p>
            </td><td>
		    <p>Used to remove an abandoned socket file (for example, as a result of abnormal process termination) used for interprocess communication on platforms that do not support memory semaphores (<code class="code">msems</code>); unused on other platforms. Before removal, gtmsecshr verifies that the file is a socket file, in directory <code class="code">$gtm_tmp</code>, and its name matches GT.M socket file naming conventions.</p>
            </td></tr><tr><td>
		    <p><code class="code">FLUSH_DB_IPCS_INFO</code></p>
            </td><td>
               <p>Writes file header of specified database file to disk.</p>
            </td><td>
               <p>The ipc resources (shared memory and semaphore) created for a database file are stored in the database file header. The first process opening a database file initializes these fields while the last process to use the database clears them. If neither of them has read-write access permissions to the database file, they set/reset these fields in shared memory and gtmsecshr will write the database file header from shared memory to disk on their behalf.</p>
            </td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a id="ftn.id2294686" href="GTM_Security_Philosophy.html#id2294686">a</a>] </sup>Please do not ever suspend a GT.M processes. In the event GT.M finds a process suspended while holding a resource, it is sent a <code class="code">SIGCONT</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2294511" href="GTM_Security_Philosophy.html#id2294511">b</a>] </sup>This function is no longer needed and will be removed soon.</p></div></td></tr></tbody></table></div></div><div class="footnotes"><br></br><hr width="100" align="left"></hr><div class="footnote"><p><sup>[<a id="ftn.id2294150" href="GTM_Security_Philosophy.html#id2294150">1</a>] </sup>The term "UNIX" refers to platforms on which GT.M uses a POSIX API to access the underlying operating system.  Currently, this refers to AIX, GNU/Linux, HP-UX, Solaris, Tru64 UNIX and z/OS.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2293733" href="GTM_Security_Philosophy.html#id2293733">2</a>] </sup>The concept of write-only access to a database file is not meaningful for GT.M</p></div><div class="footnote"><p><sup>[<a id="ftn.id2293738" href="GTM_Security_Philosophy.html#id2293738">3</a>] </sup>The GT.M installation script presents an option to restrict access to GT.M to members of a group.</p></div><div class="footnote"><p><sup>[<a id="ftn.id2294400" href="GTM_Security_Philosophy.html#id2294400">4</a>] </sup>Even with MM, processes that have read-only access to the database file still have read-write access to the control structures (for example, for M locks).  It is conceivable that a rogue process with read-only access may somehow place information in the control structures (for example, bad M lock information) to induce a normal process with read-write access to record inconsistent information in the database.</p></div></div></div><div xmlns="" id="customfooter" align="center">
For more information, see the <a href="http://www.sanchez-gtm.com" target="_blank" style="color: #000; font-weight: bold;">GT.M</a> web site. 
</div></body></html>
