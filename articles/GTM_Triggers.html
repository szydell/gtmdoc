

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>



<!-- Mirrored from tinco.pair.com/bhaskar/gtm/doc/articles/GTM_Triggers.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Mar 2019 23:00:53 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<base target="_top">
<style type="text/css">
  

/* default css */

table {
  font-size: 1em;
  line-height: inherit;
  border-collapse: collapse;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select {
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}


pre {
  font-family: Courier New;
  white-space: pre-wrap;
  margin:0;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
  color: #000;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
    overflow-x: hidden;
    overflow-y: scroll;
  }

  

  body {
    min-height: 1100px;
    
    counter-reset: __goog_page__;
  }
  
  * html body {
    height: 1100px;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px;
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  

  
    
    .writely-callout-data {
      display: inline-block;
      width: 0;
      height: 0;
      overflow: hidden;
    }
    

    .writely-footnote-marker {
      background-image: url('MISSING.html');
      background-color: transparent;
      background-repeat: no-repeat;
      width: 7px;
      overflow: hidden;
      height: 16px;
      vertical-align: top;

      
      -moz-user-select: none;
    }
    .editor .writely-footnote-marker {
      cursor: move;
    }
    .writely-footnote-marker-highlight {
      background-position: -15px 0;
      -moz-user-select: text;
    }
    .writely-footnote-hide-selection ::-moz-selection, .writely-footnote-hide-selection::-moz-selection {
      background: transparent;
    }
    .writely-footnote-hide-selection ::selection, .writely-footnote-hide-selection::selection {
      background: transparent;
    }
    .writely-footnote-hide-selection {
      cursor: move;
    }

    /* Comments */
    .writely-comment-yellow {
      background-color: #ffffd7;
    }
    .writely-comment-orange {
      background-color: #ffe3c0;
    }
    .writely-comment-pink {
      background-color: #ffd7ff;
    }
    .writely-comment-green {
      background-color: #d7ffd7;
    }
    .writely-comment-blue {
      background-color: #d7ffff;
    }
    .writely-comment-purple {
      background-color: #eed7ff;
    }

  


  
  .br_fix span+br:not(:-moz-last-node) {
    
    position:relative;
    
    left: -1ex
    
  }

  
  #cb-p-tgt {
    font-size: 8pt;
    padding: .4em;
    background-color: #ddd;
    color: #333;
  }
  #cb-p-tgt-can {
    text-decoration: underline;
    color: #36c;
    font-weight: bold;
    margin-left: 2em;
  }
  #cb-p-tgt .spin {
    width: 16px;
    height: 16px;
    background: url(http://ssl.gstatic.com/docs/clipboard/spin_16o.gif) no-repeat;
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

.webkit-indent-blockquote { border: none; }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* Ordered lists converted to numbered lists can preserve ordered types, and
   vice versa. This is confusing, so disallow it */
ul[type="i"], ul[type="I"], ul[type="1"], ul[type="a"], ul[type="A"] {
  list-style-type: disc;
}

ol[type="disc"], ol[type="circle"], ol[type="square"] {
  list-style-type: decimal;
}

/* end default css */


  /* default print css */
  @media print {
    body {
      padding: 0;
      margin: 0;
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }

    .endnotes {
      page: endnote;
    }

    /* MLA specifies that endnotes title should be 1" margin from the top of the page. */
    @page endnote {
      margin-top: 1in;
    }

    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }

    /* Comments */
    .writely-comment-yellow {
      background-color: #ffffd7;
    }
    .writely-comment-orange {
      background-color: #ffe3c0;
    }
    .writely-comment-pink {
      background-color: #ffd7ff;
    }
    .writely-comment-green {
      background-color: #d7ffd7;
    }
    .writely-comment-blue {
      background-color: #d7ffff;
    }
    .writely-comment-purple {
      background-color: #eed7ff;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */


/* custom css */


/* end custom css */

/* ui edited css */

body {
  font-family: Verdana;
  
  font-size: 10.0pt;
  line-height: normal;
  background-color: #ffffff;
}
/* end ui edited css */


/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt;
  line-height: 1.4;
  padding: 1px;
  border: 1px dashed #C0C0C0
}


/* end editor CSS */

</style>

  
  <title>[V5.4-001] Triggers Technical Bulletin</title>

</head>

<body 
    
    >
    
    
    
<h1 style=TEXT-ALIGN:center>
  <a id=Triggers_7120101139357794_5481 name=Triggers_7120101139357794_5481></a>Triggers Technical Bulletin
</h1>
<br>
Copyright © 2010 Fidelity Information Services, Inc. All Rights Reserved.<br>
<br>
Permission is granted to copy, distribute and/or modify this document under the terms of the <a href=http://www.gnu.org/licenses/fdl.txt>GNU Free Documentation License</a>, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.<br>
<br>
GT.M™ is a trademark of Fidelity Information Services, Inc. Other trademarks are the property of their respective owners.<br>
<br>
This document contains a description of GT.M and the operating instructions pertaining to the various functions that comprise the system. This document does not contain any commitment of FIS. FIS believes the information in this publication is accurate as of its publication date; such information is subject to change without notice. FIS is not responsible for any errors or defects.
<p>
</p>
<div class=legalnotice>
  <h2>
    <a id=Revision_History_3290079960565_7935655643865981 name=Revision_History_3290079960565_7935655643865981></a>Revision History
  </h2>
</div>
<table border=1 bordercolor=#000000 cellpadding=4 cellspacing=0>
  <tbody>
  <tr valign=top>
    <th align=left valign=top>
      <p align=center>
        Version
      </p>
    </th>
    <th align=middle valign=top>
      <p align=left>
        Date
      </p>
    </th>
    <th align=left valign=top>
      <p align=left>
        Summary
      </p>
    </th>
  </tr>
  <tr>
    <td align=left style=TEXT-ALIGN:center valign=top>
      1.1
    </td>
    <td align=left valign=top>
      July 13, 2010<br>
    </td>
    <td align=left style=COLOR:#0000ff valign=top>
      <div>
        <font color=#000000>Updated to reflect the trigger enhancements released with GT.M V5.4-001. Reworked the Overview and Trigger Definition File section. Added a new section called "Chained and Nested Triggers". Added V5.4-001 Triggers-related error messages. Miscellaneous cleanup of vocabulary and grammar. Improved content organization and presentation.<br>
        <br>
        All significant changes are marked in "<font color=#0000ff>blue</font>" color. </font>
      </div>
    </td>
  </tr>
  <tr valign=top>
    <td align=left style=TEXT-ALIGN:left valign=top>
      <p align=center>
        1.0
      </p>
    </td>
    <td align=left valign=top>
      <p align=left>
        February 2, 2010
      </p>
    </td>
    <td align=left valign=top>
      <p align=left>
        First published version.
      </p>
      <div>
        &nbsp;
      </div>
    </td>
  </tr>
  </tbody>
</table>
<h2>
  <a id=Contact_Information_3062105850_21319304946740025 name=Contact_Information_3062105850_21319304946740025></a>Contact Information
</h2>
<font size=2><a id=Revision_History_5023846650535 name=Revision_History_5023846650535></a><br>
</font>
<table border=0 cellpadding=4 cellspacing=0 class=zeroBorder width=100%>
  <tbody>
  <tr valign=top>
    <td width=50%>
      <div>
        GT.M Group
      </div>
      <div>
        FIS
      </div>
      <div>
        2 West Liberty Boulevard, Suite 300
      </div>
      <div>
        Malvern, Pennsylvania 19355
      </div>
      <div>
        United States of America
      </div>
    </td>
    <td width=50%>
      <div>
        GT.M Support for customers: +1 (610) 578-4226 / <a href=mailto:gtmsupport@fisglobal.com title="Click here to send e-mail to the GT.M support team">gtmsupport@fisglobal.com</a>
      </div>
      <div>
        Switchboard: +1 (610) 296-8877
      </div>
      <div>
        Website: <a href=http://fis-gtm.com/ target=_blank title="Click here to visit the GT.M home page">http://fis-gtm.com</a>
      </div>
    </td>
  </tr>
  </tbody>
</table>
<h2>
  <a id=Table_of_Contents_667841659900 name=Table_of_Contents_667841659900></a>Table of Contents
</h2>
<p>
</p>
<div class=writely-toc id=WritelyTableOfContents toctype=none+none>
  <ol class=writely-toc-none>
    <li>
      <a href=#Triggers_7120101139357794_5481 target=_self>Triggers Technical Bulletin</a>
    </li>
    <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
      <li>
        <a href=#Revision_History_3290079960565_7935655643865981 target=_self>Revision History</a>
      </li>
      <li>
        <a href=#Contact_Information_3062105850_21319304946740025 target=_self>Contact Information</a>
      </li>
      <li>
        <a href=#Table_of_Contents_667841659900 target=_self>Table of Contents</a>
      </li>
      <li>
        <a href=#Overview__44614247556389985 target=_self>Overview</a>
      </li>
      <li>
        <a href=#Trigger_Definition_File_695291 target=_self>Trigger Definition File</a>
      </li>
      <li>
        <a href=#Trigger_ISVs_01497802250751845 target=_self>Trigger ISVs</a>
      </li>
      <li>
        <a href=#Chained_and_Nested_Triggers_98_41164951289297713 target=_self>Chained and Nested Triggers</a>
      </li>
      <li>
        <a href=#A_Simple_Example_6287305510053 target=_self>A Simple Example</a>
      </li>
      <li>
        <a href=#Trigger_Definition_Storage target=_self>Trigger Definition Storage</a>
      </li>
      <li>
        <a href=#Trigger_Invocation_and_Executi_6795392753241312 target=_self>Trigger Invocation and Execution Semantics</a>
      </li>
      <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
        <li>
          <a href=#_Kill_ZKill_21073764376342297__15847752450665864 target=_self>Kill / ZKill</a>
        </li>
        <li>
          <a href=#_Set_24480497278273106_0433005_3179483964975046 target=_self>Set</a>
        </li>
        <li>
          <a href=#_Trigger_Execution_Environment target=_self>Trigger Execution Environment</a>
        </li>
        <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
          <li>
            <a href=#Error_Handling_941303418956791 target=_self>Error Handling during Trigger Execution</a>
          </li>
          <li>
            <a href=#ZGOTO_7180728288161529_0188809 target=_self>ZGOTO</a>
          </li>
        </ol>
        <li>
          <a href=#GT_CM_49789984146174426_697042_5132996957051892 target=_self>GT.CM</a>
        </li>
        <li>
          <a href=#Other_Utilities_29288564453147_003777423220862608 target=_self>Other Utilities</a>
        </li>
      </ol>
      <li>
        <a href=#Managing_Triggers_During_Journ_7707549730126613 target=_self>Triggers in Journaling and Database Replication</a>
      </li>
      <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
        <li>
          <a href=#Journaling_6032871440963476_38 target=_self>Journaling</a>
        </li>
        <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
          <li>
            <a href=#MUPIP_JOURNAL_RECOVER_ROLLBACK_9106664843498762 target=_self>MUPIP JOURNAL -RECOVER / -ROLLBACK</a>
          </li>
        </ol>
        <li>
          <a href=#Multisite_Database_Replication_7430153823458132 target=_self>Multisite Database Replication</a>
        </li>
        <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
          <li>
            <a href=#Replicating_to_an_instance_wit_8397909650732762 target=_self>Replicating to an instance with a different trigger configuration</a>
          </li>
          <li>
            <a href=#Replicating_to_an_instance_tha_41438381869517404 target=_self>Replicating to an instance that does not support triggers</a>
          </li>
        </ol>
        <li>
          <a href=#Update_Helper_Processes_445095_43763238503831536 target=_self>Update &amp; Helper Processes</a>
        </li>
      </ol>
      <li>
        <a href=#MUPIP_TRIGGER_and_ZTRIGGER_420_5237262879328747 target=_self>MUPIP TRIGGER and $ZTRIGGER()</a>
      </li>
      <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
        <li>
          <a href=#MUPIP_TRIGGER_6167536123068051_27673809056170584 target=_self>MUPIP TRIGGER</a>
        </li>
        <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
          <li>
            <a href=#TRIGgerfile_7938620190536088_2 target=_self>TRIGgerfile</a>
          </li>
          <li>
            <a href=#SELEct_8216150894080576_818443 target=_self>SELEct</a>
          </li>
          <li>
            <a href=#_Examples_for_MUPIP_TRIGGER_92 target=_self>Examples for MUPIP TRIGGER</a>
          </li>
        </ol>
        <li>
          <a href=#_ZTRIGGER_2451844221301963_501 target=_self>$ZTRIGGER</a>
        </li>
        <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
          <li>
            <a href=#Examples_for_ZTRIGGER target=_self>Examples for $ZTRIGGER</a>
          </li>
        </ol>
      </ol>
      <li>
        <a href=#ISVs_and_Environment_Variables_24024687006173362 target=_self>ISVs and Environment Variables</a>
      </li>
      <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
        <li>
          <a href=#ZTCode_17816755651572924_74733_014850263749313641 target=_self>$ZTCOde</a>
        </li>
        <li>
          <a href=#ZTDATA_9789166493622181_093555_7093928520373519 target=_self>$ZTDAta</a>
        </li>
        <li>
          <a href=#ZTLEVEL_7369127931401924_64612_7123582267582766 target=_self>$ZTLevel</a>
        </li>
        <li>
          <a href=#ZTOLDval_9980852676208929_6086_40753979322937217 target=_self>$ZTOLdval</a>
        </li>
        <li>
          <a href=#ZTRIGGEROP_15597338125752685_4_4879474761480417 target=_self>$ZTRIggerop</a>
        </li>
        <li>
          <a href=#ZTSLATE_05477704183700538 target=_self>$ZTSlate</a>
        </li>
        <li>
          <a href=#ZTUPDATE_10020805229422586_409_36494897036165375 target=_self>$ZTUPdate</a>
        </li>
        <li>
          <a href=#_ZTVAlue_3231391431763768_4805 target=_self>$ZTVAlue</a>
        </li>
        <li>
          <a href=#_ZTWOrmhole_723045572067297_66 target=_self>$ZTWOrmhole</a>
        </li>
        <li>
          <a href=#Examples_for_Trigger_ISVs_3316_17053643101540827 target=_self>Examples for Trigger ISVs</a>
        </li>
      </ol>
      <li>
        <a href=#trigger_error_message_95314458 target=_self>Trigger Error Messages</a>
      </li>
      <ol class="writely-toc-none writely-toc-subheading" style=MARGIN-LEFT:0pt>
        <li>
          <a href=#GVDATAGETFAIL_8969227625057101_22502521181950985 target=_self>GVDATAGETFAIL</a>
        </li>
        <li>
          <a href=#NOZTRAPINTRIG_4783436138845975_8381153391061101 target=_self>NOZTRAPINTRIG</a>
        </li>
        <li>
          <a href=#SETINTRIGONLY_9104180634021759 target=_self>SETINTRIGONLY</a>
        </li>
        <li>
          <a href=#TRIG2NOTRIG_6193048210852266_3 target=_self>TRIG2NOTRIG</a>
        </li>
        <li>
          <a href=#TRIGCOMPFAIL_8763801705045893_ target=_self>TRIGCOMPFAIL</a>
        </li>
        <li>
          <a href=#TRIGDATAIGNORE target=_self>TRIGDATAIGNORE</a>
        </li>
        <li>
          <a href=#TRIGDEFBAD target=_self>TRIGDEFBAD</a>
        </li>
        <li>
          <a href=#TRIGINVCHSET_9080986866784484_ target=_self>TRIGINVCHSET</a>
        </li>
        <li>
          <a href=#TRIGJNLSTATE_01283656155191159_3022250048913012 target=_self>TRIGJNLSTATE</a>
        </li>
        <li>
          <a href=#TRIGNAMEUNIQ_5537249126379007_ target=_self>TRIGNAMEUNIQ</a>
        </li>
        <li>
          <a href=#TRIGSUBSCRANGE target=_self>TRIGSUBSCRANGE</a>
        </li>
        <li>
          <a href=#TRIGTCOMMIT_40825184478781307_ target=_self>TRIGTCOMMIT</a>
        </li>
        <li>
          <a href=#TRIGTLVLCHNG_5764811123555567_ target=_self>TRIGTLVLCHNG</a>
        </li>
        <li>
          <a href=#ZGOTOINVLVL_8065602728806421_3 target=_self>ZGOTOINVLVL</a>
        </li>
        <li>
          <a href=#ZTRIGINVACT_5534175802365219_8 target=_self>ZTRIGINVACT</a>
        </li>
        <li>
          <a href=#ZTRIGNOTP_3144967133369201_257 target=_self>ZTRIGNOTP</a>
        </li>
        <li>
          <a href=#ZTWORMHOLE2BIG_373249391012786_8961635177962388 target=_self>ZTWORMHOLE2BIG</a>
        </li>
      </ol>
    </ol>
  </ol>
</div>
<br>
<h2>
  <a id=Overview__44614247556389985 name=Overview__44614247556389985></a>Overview
</h2>
<div>
  Starting with V5.4-000, GT.M allows you to set up a trigger mechanism that automatically executes a defined action in response to a database update operation on a matching global node.<br>
  <br>
  The trigger mechanism executes a fragment of M code (trigger code) "before" or "as part of" a database update. You can define the specifications of this mechanism in a file called a <a href=#Trigger_Definition_File_695291 id=fu9: target=_self title="Trigger Definition File">Trigger Definition File</a>.<br>
  <br>
  For a trigger on KILL (and ZKILL), GT.M executes trigger code "before" the KILL operation. For example, a trigger on <font face="courier new">KILL ^CIF(:,1)</font> automatically might clear old cross references.<br>
  <br>
  For a trigger on SET, GT.M executes trigger code "as part of" the SET operation. Within trigger logic, the ISV $ZTOLDVAL provides read access to the value of global node prior to the update and $ZTVALUE provides read/write access to the tentative SET value. This allows you to modify the tentative SET value before GT.M commits it to the database. The term "as part of" means that SET triggers execute intertwined with the SET operation. Although it is not yet committed the database, the tentative new value appears to the process as assigned but the process must SET $ZTVALUE to make any revision to the tentative value, because a SET of the global node would nest the trigger recursively - a pathological condition. GT.M executes SET triggers during a MERGE update where GT.M internally performs a series of SET operations and while performing a $INCREMENT() operation where GT.M internally performs a SET operation.<br>
  <br>
  For all triggers, GT.M handles the database update event and the triggered actions as an Atomic (all or nothing) transactional unit. For more information, see "<a href=#Trigger_Invocation_and_Executi_6795392753241312 id=ob:w target=_self title="Trigger Invocation and Execution Semantics">Trigger Invocation and Execution Semantics</a>".<br>
  <br>
  Triggers can be used in a variety of situations including (but not limited to) the following:&nbsp; &nbsp;<br>
  <br>
</div>
<ul>
  <li>
    <b>Enforce schema-level consistency</b>: Since database schema created in a normal M application are implicit, M applications implement logic to maintain and enforce conformance with an application schema. Using triggers to enforce schema-level consistency ensures all processes invoke the code uniformly, and increases code modularity and maintainability.
  </li>
  <li>
    <b>Allow an application to maintain one or more non-primary key indexes</b>. For example, a trigger on updates to global nodes containing a customer id can maintain an index on the last name.
  </li>
  <li>
    <b>Implement business logic</b>: For example, an update to an account could automatically trigger updates to related accounts.
  </li>
  <li>
    <b>Reducing replication traffic</b>: Since the GT.M replication stream carries only the triggering updates, not the triggered updates, triggers reduce network traffic.
  </li>
  <li>
    <b>Automate application defined logging or journaling of updates or maintaining historical records</b>. &nbsp;Triggers can be used to control these.
  </li>
  <li>
    <b>Implement referential integrity</b>: For example, a trigger can prevent the posting of a bank transaction for an inactive account and display a rule violation message.
  </li>
  <li>
    <b>Debugging</b>: Debugging an application with multiple concurrent accesses is hard. &nbsp;You can use triggers to establish "watch points" on global variable updates to trap incorrect accesses. &nbsp;For example, if an application is failing because certain global variable nodes either have incorrect values or when previously set values disappear. A trigger can be used to trap all such accesses.
  </li>
  <li>
    <b>Implement a dataflow based programming paradigm</b>. Although not a primary goal of the implementation of triggers, you can use them to implement applications that use a dataflow programming paradigm.
  </li>
</ul>
<h2>
  <a id=Trigger_Definition_File_695291 name=Trigger_Definition_File_695291></a>Trigger Definition File
</h2>
A trigger definition file is a text file used for adding new triggers, modifying existing triggers, or removing obsolete triggers. A trigger definition file consists of one or more trigger definitions. A trigger definition includes the following information:&nbsp;<br>
<br>
<ul>
  <li>
    <b>Trigger signature</b>: A trigger signature consists of:
  </li>
  <ul>
    <li>
      <i>Global Variable</i>: The name of a specific global to which this trigger applies.
    </li>
    <li>
      <i>Subscripts</i>: Subscripts for global variable nodes of the named global, specified using the same patterns as the ZWRITE command.
    </li>
    <li>
      <i>Value</i>: For commands that SET or update the value at a node, GT.M honors an optional pattern to screen for changes to delimited parts of the value.&nbsp; A value pattern includes a piece separator and a list of pieces of interest.
    </li>
    <li>
      <i>Command</i>: There are three commands: SET, KILL and ZKILL (ZWITHDRAW is identical to ZKILL; the shorter name for the command is used when specifying triggers. &nbsp;MERGE is logically treated as equivalent to a series of SET operations performed in a loop. GT.M handles $INCREMENT() of a global matching a SET trigger definition as a triggering update.
    </li>
    <li>
      <i>Trigger code</i>:&nbsp; A string containing M code that GT.M executes when application code updates,&nbsp; including deletions by KILL and like commands, a global node with a matching trigger. The specified code can invoke additional routines and subroutines.<br>
      <br>
      Note: Although the trigger code is a part of a trigger signature, GT.M uses a combination of global variable, subscripts, value, and command to find the matching trigger to invoke for a database update.<br>
      <br>
    </li>
  </ul>
  <li>
    <b>ACID property modifiers for triggered database updates</b>: Currently, GT.M merely performs a syntax check on this part of a trigger definition. GT.M ensures the triggering database update, and any updates generated by trigger logic executed with transaction semantics. &nbsp;With the <font face="courier new">VIEW "NOISOLATION"</font> command, GT.M transaction processing has long provided a mechanism for an application to inform the GT.M runtime system that it need not enforce Isolation. In such a case, the application and schema design provides Isolation by ensuring only one process ever updates nodes in a particular global at any given time, say by using $JOB as a subscript. This property anticipates a time when a trigger specification can provide NOISOLATION for particular nodes, in contrast to entire globals, and for every update to that node, in contrast to by process use of a VIEW command.&nbsp; Currently, the GT.M runtime system enforces Consistency for application logic inside a transaction and for triggered updates. This property anticipates a time when a trigger specification permits an application to inform the runtime system the application and schema design ensures appropriate Consistency for a trigger and its logic, thus relieving the GT.M runtime system from that task.
  </li>
  <li>
    <b style=COLOR:#0000ff>Trigger Name</b><font color=#0000ff>: You can optionally specify a trigger name that uniquely identifies each trigger. GT.M uses a trigger name for error reporting and configuration management of triggers - for example, a ZSHOW "S" reports the name of each trigger on the stack. If you do not specify a trigger name, GT.M automatically generates one using the global name as a base. </font><br style=COLOR:#0000ff>
    <br style=COLOR:#0000ff>
    <font color=#0000ff>A user-specified trigger name is an alphanumeric string of up to 28 characters</font><font color=#0000ff>. It must start with an alphabetic character or a percent sign (%). For a trigger name, GT.M uses the same naming convention as an M name (or a routine name). In other contexts, GT.M truncates M names at 31 characters. However, GT.M treats a trigger name of over 28 characters as an error. This is because a trigger name uniquely identifies a trigger and truncation may cause duplication. </font>
  </li>
</ul>
<br>
<div style=MARGIN-LEFT:40px>
  <font color=#0000ff>An automatically generated trigger name is a string comprised of two parts. Using the global name as a base, GT.M takes the first part as an alphanumeric string of up to 21 characters starting with an alphabetic character or a percent sign (%). The trailing part consists of an automatically incremented number in the form of #n where n is a whole number from 1 to 9999999 that uniquely identifies a trigger for the same update. For example, GT.M automatically generates trigger names </font><font color=#0000ff face="Courier &#10;New">Account#1, Account#2, and Account#3</font><font color=#0000ff> for the first three triggers defined for global variable </font><font color=#0000ff face="Courier New">^Account</font><font color=#0000ff> if no trigger names are specified in the trigger definition file. <font color=#0000ff>An attempt to use automatic assignment for more than a million triggers produces an error. </font><br>
  <br>
  At run-time GT.M generates a trailing suffix of a hash-sign (#) followed by up to two characters to ensure that every trigger has a unique designation, even when the environment is complex. The run-time suffix applies to both user-specified and automatically generated trigger names. Typically, you can ignore this suffix. </font><br>
</div>
<br>
<div>
  <font color=#0000ff>Suppose you want to set up a trigger called </font><font color=#0000ff face="courier new">TrigAcct</font><font color=#0000ff> on every </font><font color=#0000ff face="courier new">s ^Acct("ID")</font><font color=#0000ff> to invoke the routine </font><font color=#0000ff face="courier new">^OpenAccount</font><font color=#0000ff>. Your trigger definition file may have an entry like </font><font color=#0000ff face="courier new">+^Acct("ID") -command=S -xecute="do ^OpenAccount" -name=TrigAcct</font><font color=#0000ff>. The following diagram identifies the different parts of this trigger definition:</font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <div id=dy25 style=COLOR:#0000ff;TEXT-ALIGN:left>
    <div id=n2tx style=TEXT-ALIGN:left>
      <div id=qam: style=TEXT-ALIGN:left>
        <div id=t9-m style=TEXT-ALIGN:left>
          <img src="images/dpqq6h6_155cs8vtfd4_b.gif" style=HEIGHT:225px;WIDTH:860px>
        </div>
        <br>
      </div>
    </div>
  </div>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>To apply this trigger definition file to GT.M, all you do is to load it using </font><font color=#0000ff face="courier new">MUPIP TRIGGER -TRIGGERFILE</font><font color=#0000ff> or </font><font color=#0000ff face="courier new">$ZTRIGGER()</font><font color=#0000ff>. GT.M would invoke trigger name </font><font color=#0000ff face="courier new">TrigAcct</font><font color=#0000ff> on every Set operation on </font><font color=#0000ff face="courier new">^Acct("ID")</font><font color=#0000ff>.&nbsp; Internally, GT.M stores trigger </font><font color=#0000ff face="courier new">TrigAcct</font><font color=#0000ff> in the same database file where </font><font color=#0000ff face="courier new">^Acct</font><font color=#0000ff> is stored.&nbsp;</font><br>
  <br>
  The syntax of an entry in a trigger definition file is:&nbsp;<br>
  <font face="Courier New">{-triggername|-triggername-prefix*|-*|{+|-}trigvn -commands=cmd[,...] -xecute=strlit1 [-[z]delim=expr]</font><font face="Courier New">[-pieces=[lvn=]int1[:int2][;...]] [-options={[no]i[solation]|[no]c[onsistencycheck]}...] [-name=strlit2]}<br>
  <br>
  </font>
  <div>
    &nbsp;
  </div>
  <div align=left>
    <table border=1 bordercolor=#000000 cellpadding=4 cellspacing=0 width=100%>
      <tbody>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">-triggername|-trigger-name-prefix*|-*</font>
        </td>
        <td width=79%>
          <font face="Courier New">-triggername </font>deletes a user-specified trigger name called <font face="courier new">triggername</font> from the database.&nbsp;&nbsp;<br>
          <font face="Courier New">-triggername*</font> deletes all those user-defined triggers whose starting name match <font face="courier new">triggername</font>. &nbsp;<br>
          <font face="Courier New">-*</font> deletes all triggers; if the MUPIP TRIGGER command does not specify -NOPROMPT , GT.M displays a warning and asks for user confirmation before deleting all triggers. If MUPIP TRIGGER command specifies -NOPROMPT and the definition file includes a <font face="courier new">-*</font> line, GT.M deletes all the triggers without user confirmation. $ZTRIGGER() performs deletions -NOPROMPT. &nbsp;<br>
          <font face="courier new">+triggername</font> issues an error; to add a new user-specified trigger name, use <font face="Courier New">-name=strlit2</font>.
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">{+|-}tri<a id=gvn name=gvn></a>gvn </font>
        </td>
        <td width=79%>
          <font face="Courier New">trigvn </font>is a global node on which you set up a trigger.&nbsp; &nbsp;<br>
          <font face="Courier New">-trigvn</font> deletes any triggers in the database that match the specified trigger.&nbsp; &nbsp;<br>
          <font face="Courier New">+trigvn </font>adds or replaces the specified trigger.&nbsp; If the specified trigger exists (with a matching specification), MUPIP TRIGGER or $ZTRIGGER() treats the matching definition as a no-op, resulting in no database update.&nbsp; If you want to specify more than one global node for the same trigger code, the following rules apply: &nbsp;
          <ul>
            <li>
              You can use patterns and ranges for subscripts.
            </li>
            <li>
              You can specify a semicolon (;) separated list for subscripts.
            </li>
            <li>
              You can specify a selection list that includes a mix of points, ranges and patterns, but a pattern cannot serve as either end of a range. For example, :,"a":"d";?1U is a valid specification but :,"a":?1A is not.&nbsp;
            </li>
            <li>
              You can specify a local variable name for each subscript. For example instead of <font face="Courier New">^X(1,:,:)</font>, you can specify <font face="Courier New">^X(1,lastname=:,firstname=:)</font>. This causes GT.M to define local variables<font face="courier new"> lastname</font> and <font face="courier new">firstname</font> to the actual second and third level subscripts respectively from the global node invoking this trigger. The trigger code can then use these variables just like any other M local variable. As described in the Trigger Execution Environment section, trigger code executes in a clean environment - as if all code is preceded by an implicit NEW – the implicit assignments apply only within the scope of the trigger code and don't conflict or affect any run-time code or other triggers.
            </li>
            <li>
              You cannot use the @ operator, unspecified subscripts (for example, <font face="Courier New">^A()</font> or <font face="Courier New">^A(:,))</font> or local or global variable names as subscripts.
            </li>
            <li>
              You cannot use patterns and ranges for the global variable name. Therefore, you cannot set a trigger for <font face="Courier New">^Acct*.</font>
            </li>
          </ul>
          In order to account for any non-standard collation, GT.M evaluates string subscript ranges using the global specific collation when an application update first invokes a trigger - as a consequence, it detects and reports range issues at run-time rather than from MUPIP TRIGGER or $ZTRIGGER(), so test appropriately. For example, GT.M reports a run-time error for an inverted subscript range such as (ASCII) C:A. &nbsp;
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">-comma<a id=cmd name=cmd></a>nd=cmd</font>
        </td>
        <td width=79%>
          cmd is the trigger invocation command. Currently, you can specify one or more of S[et], K[ill<font color=#000000>] or ZK[ill]. A subsequent GT.M release may support ZTK[ill] for triggering on descendent nodes of a KILLed ancestor, but, while current versions accept ZTK, they convert it into K. </font>&nbsp; <font color=#000000>If cmd specifies multiple command values, GT.M treats each M command as a separate trigger. Note that even if you specify both SET and KILL, only one M command matches at any given time.</font> <font color=#000000>Trigger code is not executed in the following conditions: </font>&nbsp;
          <ul>
            <li>
              <font color=#000000>A KILL of a node that does not exist.</font>
            </li>
            <li>
              <font color=#000000>A KILL of a node that has a <font face="courier new">cmd=ZK</font> trigger, but no <font face="courier new">cmd=K</font> trigger.</font>
            </li>
            <li>
              <font color=#000000>A ZKILL or ZWITHDRAW of a node that has descendents but no data and a trigger with <font face="courier new">cmd=ZK</font>.</font>
            </li>
            <li>
              The trigger uses the "piece" syntax (described below) and no triggering piece changes in the update.
            </li>
            <li>
              <font color=#000000>The duplicate SET optimization is enabled (that is, the environment variable <font face="courier new">gtm_gvdupsetnoop</font> is set to 1|<font face="courier new">True</font>|<font face="courier new">Yes</font>) and a SET command causes no change in the value of a preexisting node. </font>&nbsp;
            </li>
          </ul>
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">-x<a id=xecute name=xecute></a>ecute="strlit1"</font>
        </td>
        <td width=79%>
          <font face="courier new">strlit1</font> specifies the trigger code executed when an update matches the trigvn. Note that <font face="courier new">strlit1</font> is a quoted string literal and quotes inside strlit1 are doubled as in normal M syntax.&nbsp;<br>
          <br>
          To validate <font face="courier new">strlit1</font>, MUPIP TRIGGER or $ZTRIGGER() compiles it before applying the trigger definition to the database and issues a TRGCOMPFAIL error if it contains any invalid code.<br>
          <br>
          Note: Trigger compilation detects compilation errors, but not run-time errors. Therefore, you should always test your trigger code before applying trigger definitions to the database<br>
          <br>
          <font color=#0000ff>Warning: As stated in the </font><a href=#Trigger_Definition_File_695291 id=q5ot style=COLOR:#0000ff target=_self title="Trigger Definition File">Trigger Definition File</a><font color=#0000ff> section, the text of trigger code is a part of the trigger signature. If you use two trigger signatures that have the same semantics (global variable, subscript, value, and command) but different text (for example:</font><font color=#0000ff face="courier new"> set foo=$ztoldval</font><font color=#0000ff>, </font><font color=#0000ff face="courier new">s foo=$ztoldval</font><font color=#0000ff>, and </font><font color=#0000ff face="courier new">set foo=$ztol</font><font color=#0000ff>), their signatures become different and GT.M treats them as different triggers. FIS recommends you to use comprehensive and strong coding conventions for trigger code or rely on user-specified names in managing the deletion and replacement of triggers.</font><br>
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">[<font face="'courier new'">-pieces=</font>int1[:int2][;...]]&nbsp;&nbsp;&nbsp;&nbsp;</font>
        </td>
        <td width=79%>
          <p>
            If cmd is S[et], you can specify an optional piece list sequence where <font face="courier new">int2</font>&gt;<font face="courier new">int1</font> and <font face="courier new">int1:int2</font> denotes a integer range from <font face="courier new">int1</font> to <font face="courier new">int2</font>. The trigger gets executed only when any piece from the specified piece list changes. Suppose your trigvn has a list "<font face="courier new">Window|Chair|Table|Door</font>" and you want to execute the trigger only when the value of the 3rd or 4th piece changes so you might specify the following trigger definition: &nbsp;
          </p>
          <div>
            <font face="Courier New"><br>
            +^trigvn -commands=S -pieces=3;4 -delim="|" -options=NOI,NOC -xecute="W ""3rd or 4th element updated.""" </font>
          </div>
          <div>
            &nbsp;
          </div>
          <div>
            <font face="Courier New">GTM&gt;W ^trigvn<br>
            </font><font face="Courier New">Window|Chair|Table|Door| </font>
          </div>
          <div>
            <font face="Courier New">GTM&gt;s $P(^trigvn,"|",3)="Dining Table"</font>
          </div>
          <div>
            <font face="Courier &#10;New">3rd or 4th element updated.<br>
            </font>
          </div>
          <p>
            This trigger is not executed if you change the first element. For example:&nbsp;&nbsp;<br>
            <br>
          </p>
          <p>
            <font face="Courier New">S $P(^trigvn,"|",1)="Chandelier"</font><br>
          </p>
          <p>
            does not invoke the trigger. &nbsp;<br>
          </p>
          <p>
            <br>
          </p>
          <p>
            You can also specify a range for your piece sequence. For example, 3:5;7;9:11 specifies a trigger on pieces 3 through 5,7 and 9 through 11. GT.M merges any overlapping values or ranges - for example, 3:6;7 is the same as 3:7.&nbsp;
          </p>
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">[<font face="'courier new'">-[z]delim=</font>expr]</font>
        </td>
        <td width=79%>
          If cmd is S[et], you can specify an optional piece delimiter using <font face="courier new">-[z]delim=expr</font> where expr is a string literal or an expression (with very limited syntax) evaluating to a string separating the pieces (e.g., "|") in the values of nodes, and is interpreted as an ASCII or UTF-8 string based on the $gtm_chset environment variable.&nbsp; To allow for unprintable delimiters in the delimiter expression, MUPIP TRIGGER only accepts&nbsp; $Char() and $ZChar()&nbsp; and string concatenation (_) as embellishments to the string literals.&nbsp; If zdelim specifies a delimiter, GT.M uses the equivalent of $ZPiece() to match pieces and to identify changes in $ZTUPDATE() (refer to the ISV description for additional information); otherwise, if delim specifies a delimiter, GT.M uses the equivalent of $Piece() for the current mode (M or UTF-8). Specifying a delimiter for cmd other than S[et] or specifying both delim and zdelim for the same trigger each produce an error.
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">[<font face="'courier new'">-o<a id=ACID name=ACID></a>ptions=</font>{no]i[solation]|[[no]c[onsistencycheck]}...</font>
        </td>
        <td width=79%>
          You can specify <font face="courier new">[NO] ISOLATION </font>or <font face="courier new">[NO]CONSISTENCYCHECK</font> as a property of the triggered database updates. <font face="courier new">NOISOLATION</font> is a facility for your application to instruct GT.M where the application logic and database schema take responsibility for ensuring the ACID property of <font face="courier new">ISOLATION</font>, and that any apparent collisions are purely coincidental from multiple global nodes resident in the same physical block which serves as the GT.M level of granularity in conflict checking. In the current release this trigger designation is notational only - you must still implement <font face="courier new">NOISOLATION</font> at the process level with the VIEW command, but you can use the trigger designation in planning to move to schema-based control of this facility. <font face="courier new">NOCONSISTENCYCHECK</font> is a facility for your application to instruct GT.M that application logic and schema take responsibility for ensuring the ACID property of <font face="courier new">CONSISTENCY</font>. The <font face="courier new">[NO]CONSISTENCYCHECK</font> feature is not yet implemented and will be made available in a future GT.M release. For now, you can plan to move <font face="courier new">CONSISTENCY </font>responsibility from your application to a trigger and implement it later when this feature becomes available.<br>
          <br>
          <font color=#0000ff>Note: </font><font color=#0000ff face="courier new">-options</font><font color=#0000ff> are not part of the trigger signature and so can be modified without deleting an existing trigger.</font><br>
        </td>
      </tr>
      <tr valign=top>
        <td width=21%>
          <font face="Courier New">[-<a id=name name=name></a><font face="'courier new'">name</font>=strlit2]</font>
        </td>
        <td width=79%>
          <font color=#0000ff face="courier new">strlit2</font><font color=#0000ff> is a user-specified trigger name. It is an alphanumeric string of up to 28 characters. It must start with an alphabetic character or a percent sign (%).</font><br style=COLOR:#0000ff>
          <br style=COLOR:#0000ff>
          <font color=#0000ff>Note: </font><font color=#0000ff face="courier new">-name</font><font color=#0000ff> is not part of the trigger signature and so can be modified without deleting an existing trigger.</font><br style=COLOR:#0000ff>
          <br style=COLOR:#0000ff>
          <font color=#0000ff>Note also that the name can be used to delete a trigger - this alternative avoids potential issues with text variations in the code associated with the -xecute qualifier which is part of the trigger signature when the variations don't have semantic significance.</font><br>
        </td>
      </tr>
      </tbody>
    </table>
  </div>
  <div align=left>
    &nbsp;<br>
  </div>
  <h2>
    <a id=Trigger_ISVs_01497802250751845 name=Trigger_ISVs_01497802250751845></a>Trigger ISVs
  </h2>
</div>
<div>
  The following table briefly describes all ISVs (Intrinsic Special Variables) available for use by application logic using triggers.&nbsp; With the exception of $ZWORMHOLE they return zero (0) if they have numeric values or an empty string when referenced by code outside of a trigger context. For more comprehensive description and usage examples of these ISVs, see "<u><a href=#ISVs_and_Environment_Variables_24024687006173362 id=uhv7 target=_self title="Trigger Intrinsic Special Variables">Trigger ISVs</a></u>".<br>
  <br>
</div>
<table border=1 bordercolor=#000000 cellpadding=3 cellspacing=0 id=vs0o width=100%>
  <tbody>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTCode_17816755651572924_74733_014850263749313641 id=qncb target=_self title=$ZTCODE>$ZTCODE</a><br>
    </td>
    <td width=50%>
      Contains the M code (Xecute) string corresponding to the current trigger.<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTDATA_9789166493622181_093555_7093928520373519 id=wqsq target=_self title=$ZTDATA>$ZTDATA</a><br>
    </td>
    <td width=50%>
      A fast path alternative to $Data(@$REFERENCE)#2 for a SET or $Data(@$REFERENCE) of the node for a KILL update.<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTLEVEL_7369127931401924_64612_7123582267582766 id=m88d target=_self title=$ZTLEVEL>$ZTLEVEL</a><br>
    </td>
    <td width=50%>
      Returns the current level of trigger nesting (invocation by an update in trigger code of an additional trigger).<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTOLDval_9980852676208929_6086_40753979322937217 id=fx3t target=_self title=$ZTOLDVAL>$ZTOLDVAL</a><br>
    </td>
    <td width=50%>
      Returns the prior (old) value of the node whose update caused the trigger invocation or an empty string if node had no value; refer to $ZTDATA to determine if the node had a data value.<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTRIGGEROP_15597338125752685_4_4879474761480417 id=kvrz target=_self title=$ZTRIGGEROP>$ZTRIGGEROP</a><br>
    </td>
    <td width=50%>
      For SET (including MERGE and $INCREMENT() operations), $ZTRIGGEROP returns the value "S". For KILL, $ZTRIGGEROP returns the value "K". For ZKILL or ZWITHDRAW, $ZTRIGGEROP returns the value "ZK".<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTSLATE_05477704183700538 id=q7xa target=_self title=$ZTSLATE>$ZTSLATE</a><br>
    </td>
    <td width=50%>
      <font color=#0000ff>$ZTSLATE allows you to specify a string that you want to make available in chained or nested triggers invoked for an outermost transaction (when a TSTART takes $TLEVEL from 0 to 1).</font><br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#_ZTVAlue_3231391431763768_4805 id=wd_g target=_self title=$ZTVALUE>$ZTVALUE</a><br>
    </td>
    <td width=50%>
      For SET, $ZTVALUE has the value assigned to the node which triggered the update. Initially this is the value specified by the explicit (triggering) SET operation. Modifying $ZTVALUE within a trigger modifies the value GT.M eventually assigns to the node.<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#ZTUPDATE_10020805229422586_409_36494897036165375 id=ujgz target=_self title=$ZTUPDATE>$ZTUPDATE</a><br>
    </td>
    <td width=50%>
      For SET commands where the GT.M trigger specifies a piece separator, $ZTUPDATE provides a comma separated list of ordinal piece numbers of pieces that differ between the current values of $ZTOLDVAL and $ZTVALUE.<br>
    </td>
  </tr>
  <tr>
    <td align=left valign=top width=5%>
      <a href=#_ZTWOrmhole_723045572067297_66 id=y0n5 target=_self title=$ZTWORMHOLE>$ZTWORMHOLE</a><br>
    </td>
    <td width=50%>
      <font color=#0000ff>$ZTWORMHOLE allows you to specify a string up to 128KB&nbsp; that you want to make available during trigger execution.</font> You can use $ZTWORMHOLE to supply application context or process context to your trigger logic. Because $ZTWORMHOLE is retained throughout the duration of the process, you can read/write $ZTWORMHOLE both from inside and outside a trigger. Note that if trigger code does not reference $ZTWORMHOLE, GT.M does not make it available to MUPIP (via the journal files or replication stream). Therefore, if a replicating secondary has different trigger code than the initiating primary (an unusual configuration) and the triggers on the replicating node require information from $ZTWORMHOLE, the triggers on the initiating node must reference $ZTWORMHOLE to ensure GT.M maintains the data it contains for use by the update process on the replicating node. GT.M allows you to change $ZTWORMHOLE within trigger code so that a triggered update can trigger other updates&nbsp; but because of the arbitrary ordering of triggers matching the same node (refer to the discussion on trigger chaining below), such an approach requires careful design and implementation.<br>
    </td>
  </tr>
  </tbody>
</table>
<div>
  &nbsp; &nbsp;<br>
  The <a href=#_Trigger_Execution_Environment id=c1as target=_self title="Trigger Execution Environment">Trigger Execution Environment</a> section describes the interactions of the following ISVs with triggers: $ETRAP, $REFERENCE, $TEST, $TLEVEL, and $ZTRAP.<br>
  <h2>
    <a id=Chained_and_Nested_Triggers_98_41164951289297713 name=Chained_and_Nested_Triggers_98_41164951289297713></a>Chained and Nested Triggers
  </h2>
  <font color=#0000ff>Triggers are chained or nested when a database update sets off more than one trigger. A nested trigger is a trigger set off by another trigger. GT.M assigns a nesting level to each nested trigger to up to 127 levels. While nested triggers are always Atomic with their triggering update GT.M gives each nested trigger a new trigger context rather than a part of the triggering update.&nbsp; </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>A chained trigger is an arbitrary sequence of matching triggers for the same database update. </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>Consider the following trigger definition entries: </font>
  <div style="COLOR:#0000ff;MARGIN:0pt 0pt 0pt">
    &nbsp;
  </div>
  <div style="COLOR:#0000ff;MARGIN:0pt 0pt 0pt">
    <font face="'courier new'">+^Acct("ID") -commands=Set -xecute="Set ^Acct(1)=$ZTVALUE+1"<br>
    +^Acct(sub=:) -command=Set -xecute="Set ^X($ZTVALUE)=sub"</font>
  </div>
  <div style="COLOR:#0000ff;MARGIN:0pt 0pt 0pt">
    &nbsp;
  </div>
  <font color=#0000ff>This example sets off a chained sequence of two triggers and one nested trigger. On </font><font color=#0000ff face="Courier &#10;New">Set ^Acct("ID")=10</font><font color=#0000ff>, GT.M chains together an arbitrary sequence of triggers for </font><font color=#0000ff face="Courier New">^Acct("ID")</font><font color=#0000ff> and </font><font color=#0000ff face="Courier New">^Acct(sub:)</font><font color=#0000ff>. It is possible for either the <font color=#0000ff face="courier new">^Acct(sub=:)</font> trigger or</font><font color=#0000ff> the&nbsp;<font color=#0000ff face="courier new">^Acct("ID")</font> trigger to execute first and the other to follow </font><font color=#0000ff>because the trigger execution sequence is arbitrary. Whenever GT.M invokes the trigger for </font><font color=#0000ff face="courier new">^Acct("ID")</font><font color=#0000ff>, the </font><font color=#0000ff face="courier new">Set ^Acct(1)=$ZTVALUE+1</font><font color=#0000ff> code sets off the trigger for ^</font><font color=#0000ff face="courier &#10;new">Acct(sub=:)</font><font color=#0000ff> as a nested trigger. </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>Caution: FIS recommends against using chained and nested triggers that potentially update the same piece of a global variable. You should always assess the significance of having chained triggers for a database update especially because of the arbitrary trigger execution order.</font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>The following table shows the stacking behavior of some Intrinsic Special Variables in chained and nested triggers.<br>
  <br>
  </font>
  <table border=1 bordercolor=#000000 cellpadding=2 cellspacing=0 class=MsoTableGrid style=COLOR:#0000ff>
    <tbody>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt;TEXT-ALIGN:left">
          <b>ISV Stacking </b>
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt;TEXT-ALIGN:left">
          <b>Chained</b>
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt;TEXT-ALIGN:left">
          <b>Nested</b>
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $REFERENCE
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $TEST
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTVALUE
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared (updatable)<br>
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTOLDVAL
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTDATA
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt width=157>
        $ZTSLATE<br>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt width=150>
        Not Stacked<br>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in width=144>
        Not Stacked<br>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTTRIGGEROP
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTWORMHOLE
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Not Stacked
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Not Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTLEVEL
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          Shared
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:117.9pt valign=top width=157>
        <p style="MARGIN:0pt 0pt 0pt">
          $ZTUPDATE
        </p>
      </td>
      <td bgcolor=transparent style=WIDTH:112.5pt valign=top width=150>
        <p style="MARGIN:0pt 0pt 0pt">
          depends on $ZTVALUE when trigger starts<br>
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:1.5in valign=top width=144>
        <p style="MARGIN:0pt 0pt 0pt">
          Stacked
        </p>
      </td>
    </tr>
    </tbody>
  </table>
  <p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
    &nbsp;
  </p>
  <p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
    <i>Stacked</i> denotes an ISV whose value is restored at the completion of the trigger.<br>
    <i>Not Stacked</i> denotes an ISV whole value is retained after the completion of the trigger.<br>
    <i>Shared </i>denotes an ISV whose value is the same, possibly subject to updates, across chained updates<font size=3><br style=FONT-FAMILY:Verdana>
    </font>
  </p>
  <p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
    Note that a trigger that is both nested and chained has the characteristics from both columns - the "Chained" column is really about the relationship between triggers invoked by the same update and the "Nested" is really about the isolation of a trigger from the context that invoked it, whether or not that context is inside the context of another trigger.<font size=3><br>
    </font>
  </p>
</div>
<h2>
  <a id=A_Simple_Example_6287305510053 name=A_Simple_Example_6287305510053></a>A Simple Example
</h2>
<div style=COLOR:#0000ff>
  This section contains a simple example showing how a GT.M trigger can automatically maintain cross references in response to a SET or KILL operation on <font face="courier new">^CIF(<font color=#274e13 face="comic sans ms">ACN</font>,1)</font>.&nbsp; It also reinforces the basic trigger concepts explained above.<br>
  <br>
  Global nodes in <font face="courier new">^CIF(<font color=#274e13 face="comic sans ms">ACN</font>,1)</font> have a structure <font face="courier new">^CIF(<font color=#274e13 face="comic sans ms">ACN</font>,1)=<font color=#274e13 face="comic sans ms">NAM</font>|<font color=#274e13 face="comic sans ms">XNAME</font>|</font> where the vertical-bars are delimiters and <font face="comic sans ms">XNAME</font> is a customer's canonical name (e.g., <font face="courier new">"Doe, Johnny"</font>). The application schema has one cross reference index, <font face="courier new">^XALPHA("A",<font face="comic sans ms">XNAME</font>,<font face="comic sans ms">ACN</font>)=""</font> . &nbsp;A GT.M trigger specified for<font face="courier new"> ^CIF(:,1)</font> nodes can automatically maintain the cross references.&nbsp;&nbsp; &nbsp;&nbsp;<br>
  &nbsp;
</div>
<ol style=COLOR:#0000ff>
  <li>
    Using your editor, create a trigger definition file called <font face="courier new">triggers.trg<sup><a href=#FOOTNOTE-1>1</a></sup></font>with the following entry:<br>
    <font face="courier new">+^CIF(acn=:,1) -delim="|" -pieces=2 -commands=SET,KILL -xecute="Do ^XNAMEinCIF"</font><br>
    In this definition:<br>
    <font face="courier new">^CIF</font> - specifies the global variable to which the trigger applies.<br>
    <font face="courier &#10;new">acn=:</font> - in ZWRITE syntax, ":" specifies any value for the first subscript, and the <font face="courier new">acn= prefix</font> requests GT.M assign the value of the first subscript (<font color=#274e13><font face="Comic Sans MS">ACN</font>)</font> to the local variable <font face="courier new">acn</font> before invoking the trigger logic.<br>
    <font face="courier new">1</font> - specifies that the trigger matches only if the second subscript is 1 (one).<br>
    <font face="courier new">-delim="|</font>" - specifies that GT.M use "|"&nbsp; as the piece separator when checking the value of the node to see whether to invoke the trigger. &nbsp;Use of the keyword delim tells GT.M to use $PIECE() semantics for the value at the node; zdelim, instead, would instruct GT.M to use $ZPIECE() semantics.<br>
    <font face="courier new">-pieces=2 </font>- specifies that GT.M should only invoke the trigger when the update changes the second piece (<font face="comic sans ms">XNAME</font>) not for a change to the first piece (<font color=#274e13 face="comic sans ms">NAM</font>), or any other piece without a change to XNAME.<br>
    <font face="courier new">-commands=</font>SET,KILL - specifies that GT.M invoke the trigger for SET and KILL updates (but not a ZKILL/ZWITHDRAW command).<br>
    <font face="courier new">-xecute="Do ^XNAMEinCIF"</font> - provides code for GT.M to invoke to perform the trigger logic.<br>
    <br>
  </li>
  <li>
    Execute a command like the following:<br>
    <font face="courier new">$ mupip trigger -triggerfile=triggers.trg</font><br>
    This command adds a trigger for ^CIF(:,1).<br>
    On successful trigger load, this command displays an output like the following:<br>
    <font face="courier new">File triggers.trg, Line 1: ^CIF trigger added with index 1</font><br style="FONT-FAMILY:Courier New">
    <font face="courier &#10;new">=========================================</font><br style="FONT-FAMILY:Courier New">
    <font face="courier new">1 triggers added</font><br style="FONT-FAMILY:Courier New">
    <font face="Courier New">0 triggers deleted</font><br style="FONT-FAMILY:Courier New">
    <font face="courier new">0 trigger file entries not changed</font><br style="FONT-FAMILY:Courier New">
    <font face="courier new">0 triggers modified</font><br style="FONT-FAMILY:Courier New">
    <font face="courier&#10; new">=========================================</font><br>
    Now, every <font face="courier new">S[et]</font> and <font face="courier new">K[ill]</font> operation on the global node ^CIF(:,1) executes the routine <font face="courier new">XNAMEinCIF</font>.<br>
    <br>
  </li>
  <li>
    Using your editor, create an M routine called XNAMEinCIF.m with the following code:&nbsp;<br>
    <font face="courier new" size=2>XNAMEinCIF ; Triggered Update for XNAME change in ^CIF(:,1)</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;Set oldxname=$Piece($ZTOLDval,"|",2) Set:'$Length(oldxname) oldxname=$ZChar(254)&nbsp; &nbsp; ; old XNAME&nbsp;</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;Kill ^XALPHA("A",oldxname,acn)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ; remove any old xref&nbsp;</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;; Create a new cross reference if the command is a Set</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;Do:$ZTRIggerop="S"&nbsp;</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;. Set xname=$Piece($ZTVALue,"|",2) Set:'$Length(xname) xname=$ZChar(254)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ; new XNAME</font><font size=2><br>
    </font><font face="courier new" size=2>&nbsp;&nbsp;&nbsp;&nbsp;. Set^XALPHA("A",xname,acn)=""&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ; create new xref</font><br>
    ;<br>
    When the <font face="comic sans ms">XNAME</font> piece of a ^CIF(:,1) node is SET to a new value or KILLed, we delete the existing cross references.&nbsp; The deletion can be unconditional, because if the node did not previously exist, then the KILL is a no-op.&nbsp; If the command is a SET, we create new cross references. &nbsp;From the definition of the schema, the code uses the following values:
  </li>
</ol>
<div style=COLOR:#0000ff>
  &nbsp;
</div>
<ul style=COLOR:#0000ff>
  <ul>
    <li>
      <font face="courier new">acn </font>- GT.M sets variable <font face="courier &#10;new">acn</font> to the value of the first subscript of the ^CIF() node matching the trigger specification.
    </li>
    <li>
      the code sets the variable <font face="courier new">oldxname</font> to the prior value of the node, from the ISV <font face="courier new">$ZTOLDVAL</font> and if that is null (has zero length), substitutes the byte $ZCHAR(254).
    </li>
    <li>
      the code SETs the variable <font face="courier new">xname</font> to the new value of the node, from the ISV <font face="courier new">$ZTVALUE</font> or to $ZCHAR(254) if that is null.<br>
      <br>
    </li>
  </ul>
</ul>
<div style=MARGIN-LEFT:40px>
  <font color=#0000ff>After obtaining the values, an unconditional KILL command deletes the previous cross reference index, if it exists. &nbsp;Then, only if a SET invoked the trigger (determined from the ISV $ZTRIGGEROP), the trigger invoked routine creates a new cross reference index node. Note that because GT.M implicitly creates a new context for the trigger logic we do not have to worry about out choice of names or explicitly NEW any variables.</font><br style=COLOR:#0000ff>
</div>
<br>
<br style=COLOR:#0000ff>
<font color=#0000ff>The following illustration shows the flow of control when the trigger is executed for </font><font color=#0000ff face="courier new">Set ^CIN(ACN,1)="Paul|John, Doe, Johnny|"</font><font color=#0000ff>. The initial value of </font><font color=#0000ff face="courier new">^CIN(ACN,1)</font><font color=#0000ff> is </font><font color=#0000ff face="courier new">"Paul|Doe, John|"</font><font color=#0000ff> and </font><font color=#274e13 face="comic sans ms">ACN</font><font color=#0000ff> is set to "</font><font color=#0000ff face="courier new">NY</font><font color=#0000ff>". &nbsp; </font><br style=COLOR:#0000ff>
<br style=COLOR:#0000ff>
<div id=hqwg style=COLOR:#0000ff;TEXT-ALIGN:center>
  <img src="images/dpqq6h6_148hhnmhghj_b.gif" style=HEIGHT:436px;WIDTH:772px>
</div>
<br style=COLOR:#0000ff>
&nbsp;<br style=COLOR:#0000ff>
<b style=COLOR:#0000ff>Important</b><font color=#0000ff>: Within trigger context (Step 1 through 4) , if you modify the value of $ZTVAL, GT.M commits it to the database at Step 5. GT.M executes all steps (0 through 5) as an Atomic (all or nothing) transactional unit. </font><br style=COLOR:#0000ff>
<br style=COLOR:#0000ff>
<font color=#0000ff>The following illustration shows the flow of control when the trigger is executed for </font><font color=#0000ff face="courier new">Kill ^CIN(<font face="comic sans &#10;ms">ACN</font>,1)</font><font color=#0000ff>. </font><br>
<div id=latd style=TEXT-ALIGN:left>
  <div id=zxk2 style=TEXT-ALIGN:center>
    <img src="images/dpqq6h6_149ghpb4rff_b.gif" style=HEIGHT:384px;WIDTH:772px>
  </div>
  <br>
</div>
<h2>
  <a id=Trigger_Definition_Storage name=Trigger_Definition_Storage></a>Trigger Definition Storage
</h2>
GT.M stores trigger definitions as nodes of a global-like structure <font face="Courier New">(^#t</font>) within the same database as the nodes with which they're associated. You can manage the trigger definitions with MUPIP TRIGGER and $ZTRIGGER() but you cannot directly access <font face="Courier New">^#t</font> (except with DSE, which FIS recommends against under normal circumstances). The block size, key size, and record size for a database must be sufficient to hold its associated trigger definition. In addition, GT.M stores cross-region name resolution information in the DEFAULT region, so the DEFAULT region in a global directory used to update triggers must have sufficient block size, key size, and record size to hold that trigger-related data.<br>
<br>
<h2>
  <a id=Trigger_Invocation_and_Executi_6795392753241312 name=Trigger_Invocation_and_Executi_6795392753241312></a>Trigger Invocation and Execution Semantics
</h2>
<p>
  GT.M stores Triggers for each global variable in the database file for that global variable. &nbsp;When a global directory maps a global variable to its database file, it also maps triggers for that global variable to the same database file. &nbsp;When an extended reference uses a different global directory to map a global variable to a database file, that global directory also maps triggers for that global variable to that same database file.
</p>
<p>
  <br>
</p>
<p>
  Although triggers for Set and Kill / ZKill commands can be specified together, the command invoking a trigger is always unique. The ISV $ZTRIggerop provides the trigger code which matched the triggering command.
</p>
<p>
  <br>
</p>
<p>
  Whenever a command updates a global variable, the GT.M runtime system first determines whether there are any triggers for that global variable. &nbsp;If there are any triggers, it scans the signatures for subscripts and node values to identify matching triggers. &nbsp;If multiple triggers match, GT.M invokes them in an arbitrary order. &nbsp;Since a future version of GT.M, potentially multi-threaded, may well choose to execute multiple triggers in parallel, you should ensure that when a node has multiple triggers, they are coded so that correct application behavior does not rely on the order in which they execute.
</p>
<p>
  <br>
</p>
<p>
  When a process executes a Kill, Zkill or Set command, the&nbsp;<u>target</u>&nbsp;is the global variable node specified by the command argument for modification.&nbsp; With Set and ZKill, the target is a single node. &nbsp;In the case of Kill, the target may represent an entire sub-tree of nodes. &nbsp;GT.M only matches the trigger against the target node, and only invokes the trigger once for each Kill command.&nbsp; GT.M does not check nodes in sub-trees to see whether they have matching triggers.
</p>
<h3>
  <a id=_Kill_ZKill_21073764376342297__15847752450665864 name=_Kill_ZKill_21073764376342297__15847752450665864></a>Kill / ZKill
</h3>
<p style=MARGIN-LEFT:0px;MARGIN-RIGHT:0px>
  If Kill or ZKill updates a global node matching a trigger definition, GT.M executes the trigger code when a database state change has been computed but&nbsp;<i>before&nbsp;</i>it has been applied in the process space or the database. This means that the node to be KILLed and descendants (if any) remain visible to the trigger code. Note that a KILL trigger ignores $ZTVALUE.<br>
</p>
<h3>
  <a id=_Set_24480497278273106_0433005_3179483964975046 name=_Set_24480497278273106_0433005_3179483964975046></a>Set
</h3>
<div>
  If a SET updates a global node matching a trigger definition, GT.M executes the trigger code <i>after</i> the node has been updated in the process address space, but before it is applied to the database.&nbsp; <font color=#0000ff>When the trigger execution completes, the trigger logic commits the value of a node from the process address space only if </font><font color=#0000ff face="courier new">$ZTVALUE</font><font color=#0000ff> is not set. if <font face="courier &#10;new">$ZTVALUE</font> is set during trigger execution, the trigger logic commits the value of a node from the value of </font><font color=#0000ff face="courier new">$ZTVALUE</font><font color=#0000ff>.&nbsp; </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <p style=COLOR:#0000ff>
    Consider the following example:
  </p>
  <p style=COLOR:#0000ff>
    <br>
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    GTM&gt;set c=$<span class=SpellE>ztrigger</span>("S")
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    ;trigger name: A#1#&nbsp; cycle: 1
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    +^A -commands=S -xecute="set ^B=200"
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    ;trigger name: B#1#&nbsp; cycle: 1
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    +^B -commands=S -xecute="set $ztval=$ztval+1 "
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    &nbsp;
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    GTM&gt;set ^A=100,^B=100
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    &nbsp;
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    GTM&gt;write ^A
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    100
  </p>
  <font face="courier new"><font color=#0000ff>GTM&gt;write ^B</font></font>
  <p style=COLOR:#0000ff>
  </p>
  <p class=MsoPlainText style="COLOR:#0000ff;FONT-FAMILY:Courier New">
    201
  </p>
  <br style=COLOR:#0000ff>
  <font color=#0000ff face="courier new">SET ^A=100</font><font color=#0000ff> invokes trigger</font><font color=#0000ff face="courier new"> A#1</font><font color=#0000ff>. When the trigger execution begins, GT.M sets </font><font color=#0000ff face="courier new">^A</font><font color=#0000ff> to </font><font color=#0000ff face="courier new">100</font><font color=#0000ff> in the process address space, but does not apply it to the database. Therefore, the trigger logic sees </font><font color=#0000ff face="courier new">^A</font><font color=#0000ff> as set to </font><font color=#0000ff face="courier new">100</font><font color=#0000ff>. Other process accessing the database, however, see the prior value of </font><font color=#0000ff face="courier new">^A</font><font color=#0000ff>. </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>When the trigger execution completes, the trigger logic commits the value of a node from the process address space only if </font><font color=#0000ff face="courier new">$ZTVALUE</font><font color=#0000ff> is not set. The trigger logic commits the value of a node from the </font><font color=#0000ff face="courier new">$ZTVALUE</font><font color=#0000ff> only if </font><font color=#0000ff face="courier new">$ZTVALUE</font><font color=#0000ff> is set during trigger execution.&nbsp; </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>Because $ZTVALUE is not set in </font><font color=#0000ff face="courier new">A#1</font><font color=#0000ff>, GT.M commits the value of </font><font color=#0000ff face="courier &#10;new">^A </font><font color=#0000ff>from the process address space to the database. Therefore, GT.M commits&nbsp;</font><font color=#0000ff face="courier new">^A</font><font color=#0000ff><font face="courier new">=100</font> to the database. </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff face="courier new">SET ^B=200</font><font color=#0000ff> invokes trigger </font><font color=#0000ff face="courier new">B#2</font><font color=#0000ff>. <font face="Courier New">$ZTVALUE</font> is set during trigger execution, therefore GT.M commits the value of <font face="Courier New">$ZTVALUE</font> to </font><font color=#0000ff face="courier new">^B</font><font color=#0000ff> at the end of trigger execution. </font><br style=COLOR:#0000ff>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>Note: Within trigger code, any <font face="Courier New">SET</font> operation on </font><font color=#0000ff face="courier new">^B</font><font color=#0000ff> recursively invokes trigger </font><font color=#0000ff face="courier new">B#1</font><font color=#0000ff>. Therefore, always set $ZTVALUE to change the value node during trigger execution. </font><br>
  <br>
  GT.M executes the triggering update and all associated triggers within the same transaction, whether or not the original command is inside a transaction. &nbsp;This means that although the trigger logic sees the updated value of the node, it is not visible to other processes until the outermost transaction commits to the database.<br>
</div>
<p>
  <br>
</p>
<div>
  A trigger may need to update the node whose SET initiated the trigger. &nbsp;Situations where this may occur include:<br>
  <br>
</div>
<ul>
  <li>
    a log or journal entry may need to be stored in a different piece of the same node as the update, or
  </li>
  <li>
    the node being updated may need its data to be stored in a canonical form (such as all-caps, or with standardized punctuation, regardless of how it was actually entered), or have its value limited to a range.
  </li>
</ul>
<div>
  <br>
  In such cases, the trigger logic should make the changes to the ISV $ZTVALUE instead of the global node. &nbsp;At the end of the trigger invocation, GT.M applies the value in $ZTVALUE to the node. Before the first matching trigger executes, GT.M sets $ZTVALUE.&nbsp; Since a command inside one trigger's logic can invoke another nested trigger, if already in a trigger, GT.M stacks the value of $ZTVALUE for the prior update before modifying it for the nested trigger initiation.
</div>
<p>
  <br>
</p>
<p>
</p>
<p>
  GT.M treats a MERGE command as a series of SET commands performed in collation order of the data source. &nbsp;GT.M checks each global node updated by the MERGE for matching triggers. &nbsp;If GT.M finds one or more matches, it invokes all the matching trigger(s) before the next command or the next set argument to the same SET command.
</p>
<p>
  <br>
</p>
<p>
  GT.M treats the $INCREMENT() function as a SET command. &nbsp;Since the result of a $INCREMENT() operation must be numeric, if the trigger code modifies $ZTVALUE, at the end of the trigger, GT.M applies the value of +$ZTVALUE (that is, $ZTVALUE coerced to a number) to the target node.
</p>
<p>
  <br>
</p>
<p>
</p>
<p>
</p>
<h3>
  <a id=_Trigger_Execution_Environment name=_Trigger_Execution_Environment></a>Trigger Execution Environment
</h3>
<p style=MARGIN-LEFT:0px;MARGIN-RIGHT:0px>
  As noted above, if there are multiple matching triggers, the GT.M process makes a list of matching triggers and executes them in an arbitrary order with no guarantee of predictability.
</p>
<p style=MARGIN-LEFT:0px;MARGIN-RIGHT:0px>
  &nbsp;
</p>
<p>
  For each matching trigger:
</p>
<p>
  <br>
</p>
<ol>
  <li>
    The GT.M process implicitly stacks the naked reference, $REFERENCE, $TEST, $ZTOLDVAL, $ZTDATA, $ZTRIGGEROP, $ZTUPDATE and NEWs all local variables. At the beginning of trigger code execution, <span class=WW-FootnoteReference>$REFERENCE, $TEST </span><span class=WW-FootnoteReference>and</span><span class=WW-FootnoteReference> the naked indicator initially retain the values they had just prior to being stacked (in the case of KILL/ZKILL, to the reference of the KILL/ZKILL command, even though the trigger executes prior to the removal of any nodes).&nbsp; If an update directly initiates multiple (chained) triggers, all start with identical values of the naked reference, $REFERENCE, $TEST, $ZTDATA, $ZTLevel, $ZTOLDVAL</span><span class=WW-FootnoteReference> and $ZTRIGGEROP.&nbsp; This facilitates triggers that are independent of the order in which they run. &nbsp;Application logic inside triggers can use $REFERENCE, the read-only intrinsic special variables $ZTDATA, $ZTLEVEL, $ZTOLDVAL, $ZTRIGGEROP &amp; $ZTUPDATE, and the read-write intrinsic special variables $ZTVALUE, and $ZTWORMHOLE.<br>
    </span>
  </li>
  <li>
    GT.M executes the trigger code. Note that in the course of executing this GT.M trigger, if the same trigger matches again for the same or a different target, GT.M<i> reinvokes the trigger recursively</i>.&nbsp; In other words, the same trigger can be invoked more than once for the same command. &nbsp;Note that such a recursive invocation is probably a pathological condition that will eventually cause a STACKCRIT error. Triggers may nest up to 127 levels, after which an additional attempt to nest produces a MAXTRGRNEST error.<br>
  </li>
  <li>
    When the code completes, GT.M clears local variables, restores what was stacked, except $ZTVALUE (refer to the ISV definitions for comments on modifying $ZTVALUE) to the values they had at the start of the trigger, and if there is any remaining trigger matching the original update, adjusts $ZTUPDATE and executes that next action. $ZTVALUE always holds the current target value for the node for which the application update initially invoked the trigger(s). Note that because multiple triggers for the same node execute in an arbitrary order, having more than one trigger change $ZTVALUE requires careful design and implementation.
  </li>
</ol>
<p style=TEXT-ALIGN:left>
</p>
<p style=TEXT-ALIGN:left>
  <br>
</p>
<p style=TEXT-ALIGN:left>
  After executing all triggers, GT.M commits the operation initiating the trigger as well as the trigger updates and continues execution with the next command (or, in the case of multiple nodes being updated by the same command, with the next node). &nbsp;Note that if the operation initiating the trigger is itself within a transaction, other processes will not see the database state changes till the TCOMMIT of the outermost transaction.
</p>
<ol>
</ol>
<p>
  <br>
</p>
<p>
  To ensure trigger actions are Atomic with respect to the update that invokes them, GT.M always executes trigger logic and the triggering update within a transaction. &nbsp;If the triggering update is not within an application transaction, GT.M implicitly starts a restartable "Batch" transaction to wrap the original update and any triggers generated by the update. &nbsp;In other words, when 0=$TLEVEL GT.M behaves as if implicit <font face="'Courier New'">TStart *:Transactionid="BATCH"</font> and&nbsp;<font face="'Courier New'">TCommit</font>&nbsp;commands bracket the upddate and its triggers. Therefore, the trigger code and/or its error trap always operate inside a Transaction and can use the TRESTART command even if the main application code never uses TSTART. $ETRAP code for use in triggers may include TROLLBACK logic.
</p>
<p>
  <br>
</p>
<p>
  The deprecated ZTSTART/ZTCOMMIT transactions are not compatible with triggers. &nbsp;If a ZTSTART transaction is already active when an update to a global that has any trigger defined occurs, GT.M issues a runtime error. Likewise GT.M treats any attempt to issue a ZTSTART within a trigger context as an error.
</p>
<h4>
  <a id=Error_Handling_941303418956791 name=Error_Handling_941303418956791></a>Error Handling during Trigger Execution
</h4>
<p>
  GT.M uses the $ETRAP mechanism to handle errors during trigger execution. If an error occurs during a trigger, GT.M executes the M code in $ETRAP. If $ETRAP does not clear $ECODE, GT.M does not commit the database updates within the trigger and passes control to the environment of the trigger update. If the $ETRAP action or the logic it invokes clears $ECODE, GT.M can continue processing the trigger logic.
</p>
<p>
  <br>
</p>
<p>
  Consider the following trivial example:
</p>
<font face="Courier New">^Acct(id=:,disc=:) –commands=Set –xecute="Set msg=<font face="Courier New">""Trigger Failed"",</font>$ETrap=""If $Increment(^count) Write msg,!"" Set $ZTVAlue=x/disc"</font>
<p>
  <br>
</p>
<p>
  During trigger execution if <font face="'Courier New'">disc</font> (the second subscript of the triggering update) evaluates to zero, resulting in a <font face="'courier new'">DIVZERO (Attempt to divide by zero)</font> error, GT.M displays the message "<font face="'courier new'">Trigger Failed"</font>. &nbsp;Since the $ETRAP does not clear $ECODE, after printing the message, GT.M leaves the trigger context and invokes the error handler outside the trigger, if any.&nbsp; In a DIVZERO case, the process neither assigns a new value to <font face="'courier new'">^Acct(id,disc)</font> nor commits the incremented value of <font face="'courier new'">^count</font> to the database.
</p>
<p>
  <br>
</p>
An application process can use a broad range of corrective actions to handle run-time errors within triggers. However, these corrective actions may not be available during MUPIP replication. As described in the Trigger Environment section, GT.M replicates only the trigger definitions, but not the triggered updates, which are executed by triggers when a replicating instance replays them. If a trigger is invoked in a replicating instance, it means that trigger was successfully invoked on the originating instance. &nbsp;For normal application requirements, you should ensure that the trigger produces the same results on a correctly configured replicating instance. Therefore your $ETRAP code on MUPIP should deal with the following cases where:
<div>
  &nbsp;
</div>
<ul>
  <li>
    <p>
      The run-time $ETRAP code modified the trigger logic to achieve the desired result
    </p>
  </li>
  <li>
    <p>
      The replicating configuration is different from the initiating configuration
    </p>
  </li>
  <li>
    <p>
      The filters between the initiating and replicating instance introduce an error
    </p>
  </li>
</ul>
<p>
  &nbsp;
</p>
<div>
  In the later two cases there are probably basically two possibilities for the mismatch environments - they are:
</div>
<div>
  &nbsp;
</div>
<ul>
  <li>
    Intended and the $ETRAP mechanism is an integral part of managing the difference
  </li>
  <li>
    Unintended and the $ETRAP mechanism should help notify the operational team to correct the difference and restart replication&nbsp;
  </li>
</ul>
<div>
  &nbsp;
</div>
<p>
  The trigger facility introduces an environment variable called <font face="'Courier New'">gtm_trigger_etrap</font>. It provides the initial value for $ETRAP in trigger context and can be used to set error traps for trigger operations in both mumps and MUPIP processes.&nbsp; The code can, of course, also SET $ETRAP within the trigger context. During a run-time trigger operation if you do not specify the value of <font face="'Courier New'">gtm_trigger_etrap</font> and a trigger fails, GT.M uses the current trap handler. In a mumps process, if the trap handler was $ZTRAP at the time of the triggering update and <font face="'Courier New'">gtm_trigger_etrap </font>isn't defined, the error trap is implicitly replaced by $ETRAP="" which exits out of both the trigger logic and the triggering action before the $ZTRAP unstacks and takes effect. In a MUPIP process, if you do not specify the value of <font face="'courier new'">gtm_trigger_etrap</font> and a trigger fails, GT.M implicitly performs a <font face="'courier new'">SET $ETRAP="If $ZJOBEXAM()</font>" and terminates the MUPIP process. $ZOBEXAM() records diagnostic information (equivalent to <font face="'courier new'">ZSHOW "*")</font> to a file that provides a basis for analysis of the failure.
</p>
<p>
  &nbsp;
</p>
<p>
  <b>Important:&nbsp;</b><font face="'courier new'">$ZJOBEXAM()</font> dumps the context of a process at the time the function executes and the output may well contain sensitive information such as identification numbers, credit card numbers, and so on.&nbsp; You should secure the location of files produced by the MUPIP error handler or set up appropriate security characteristics for operating MUPIP. Alternatively, if you do not want MUPIP to create a <font face="'courier new'">$ZJOBEXAM()</font> file, explicitly set the <font face="'Courier New'">gtm_trigger_etrap</font> environment variable to a handler such as&nbsp;<font face="'courier new'">"Write !,$ZSTATUS,!,$ZPOSITION,! Halt</font>".
</p>
<p>
  &nbsp;
</p>
<div>
  Other key aspects of error handling during trigger execution are as follows:&nbsp;
</div>
<div>
  &nbsp;
</div>
<ul>
  <li>
    <p>
      Any attempt to use the $ZTRAP error handling mechanism for triggers results in a NOZTRAPINTRIGR error.
    </p>
  </li>
  <li>
    <p>
      If the trigger initiating update occurs outside any transaction (<font face="'courier new'">$TLEVEL=0</font>), GT.M implicitly starts a transaction to wrap the initiating update and the triggered updates. Consequently if a <font face="'courier new'">TROLLBACK</font> or <font face="'courier new'">TCOMMIT</font> within the trigger context causes the code to come back to complete the initiating update with a different $TLEVEL than when the trigger started (including any implicit <font face="'courier new'">TSTART</font>), GT.M issues a TRIGTLVLZERO error and does not commit the original update.
    </p>
  </li>
  <li>
    <p>
      Any <font face="'courier new'">TCOMMIT</font> that takes <font face="'courier new'">$TLEVEL</font> below what it was when at trigger initiation, causes a TRIGTLVLCHNG error. This behavior applies to any trigger, whether chained, nested or singular.
    </p>
  </li>
  <li>
    <p>
      <font color=#000000>It may appear that GT.M executes trigger code as an argument for an XECUTE. However, for performance reasons, GT.M internally converts trigger code into a pseudo routine and executes it as if it is a routine.</font> Although this invisible for the most part, the trigger name can appear in places like error messages and <font face="'courier new'">$STACK()</font> return values.
    </p>
  </li>
  <li>
    <p>
      Triggers are associated with a region and a process can use one or more global directories to access multiple regions, therefore, there is a possibility for triggers to have name conflicts. To avoid a potential name conflict with other resources, GT.M attempts to add a two character suffix, delimited by a <font face="'courier new'">"#"</font> character to the user-supplied or automatically generated trigger name. If this attempt to make the name unique fails, GT.M issues a TRIGNAMEUNIQ error.
    </p>
  </li>
  <li>
    <p>
      Defining <font face="'courier new'">gtm_trigger_etrap</font> to hold M code of any complexity exposes mismatches between the quoting conventions for M code and shell scripts. FIS suggests an approach of enclosing the entire value in single-quotes and only escaping the single-quote (‘), exclamation-point (!) and back-slash (\) characters. For a comprehensive (but hopefully not very realistic) example:
    </p>
    <font face="Courier New">$ export gtm_trigger_etrap='write:1\'=2 $zstatus,\!,"5\\2=",5\\2,\! halt' </font>
    <div>
      <font face="Courier New">$ echo $gtm_trigger_etrap</font>
    </div>
    <div>
      <font face="Courier New">write:1'=2 $zstatus,!,"5\2=",5\2,! halt</font>
    </div>
    <div>
      &nbsp;
    </div>
    <div>
      <font face="Courier New">GTM&gt;set $etrap=$ztrnlnm("gtm_trigger_etrap")<br>
      GTM&gt;xecute "write 1/0"<br>
      150373210,+1^GTM$DMOD,%GTM-E-DIVZERO, Attempt to divide by zero</font>
    </div>
    <div>
      <font face="Courier New">5\2=2</font>
    </div>
  </li>
</ul>
<div style=MARGIN-LEFT:40px>
  <font face="Courier New">$</font><br>
</div>
<h4>
  <a id=ZGOTO_7180728288161529_0188809 name=ZGOTO_7180728288161529_0188809></a>ZGOTO
</h4>
<p>
  To maintain the transactional integrity of triggers and to avoid branching control to an inappropriate destination, ZGOTO behaves as follows:
</p>
<div>
  &nbsp;
</div>
<ol>
  <li>
    <div>
      GT.M does not support ZGOTO 1:&lt;entryref&gt; arguments in MUPIP because they form an attempt to replace the MUPIP context.&nbsp;<br>
    </div>
  </li>
  <li>
    <div>
      When a ZGOTO argument specifies an entryref at or below the level of the update that initiated the trigger, GT.M redirects the flow of control to the entryref without performing the triggering update. Alternatively if GT.M finds a non-null $ECODE, indicating an unhandled error when it goes to complete the trigger, it throws control to the current error handler rather than committing the original triggering update.<br>
    </div>
  </li>
  <li>
    <div>
      ZGOTO 0 terminates the process and ZGOTO 1 returns to the base stack frame, which has to be outside any trigger invocation.<br>
    </div>
  </li>
  <li>
    <div>
      ZGOTO from within a run-time trigger context cannot directly reach a subsequent M command on the line containing the command that invoked the trigger, because a ZGOTO with an argument specifying the level where the update originated but no entryref returns to the update itself (as would a QUIT) and, if $ECODE is null, GT.M continues processing with any additional triggers and the triggering update before resuming the line.
    </div>
  </li>
</ol>
<h3>
  <a id=GT_CM_49789984146174426_697042_5132996957051892 name=GT_CM_49789984146174426_697042_5132996957051892></a>GT.CM
</h3>
<p>
  GT.CM servers do not invoke triggers. This means that the client processes must restrict themselves to updates which don't require triggers, or explicitly call for the actions that triggers would otherwise perform. Because GT.CM bypasses triggers, it may provide a mechanism to bypass triggers for debugging or complex corrections to repair data placed in an inconsistent state by a bug in trigger logic.
</p>
<h3>
  <a id=Other_Utilities_29288564453147_003777423220862608 name=Other_Utilities_29288564453147_003777423220862608></a>Other Utilities
</h3>
<p>
  During MUPIP INTEG, REORG and BACKUP (including -BYTESTREAM), GT.M treats trigger definitions just as it treats any normal global node.&nbsp;
</p>
<p>
  &nbsp;
</p>
<p>
  Because they are designed as state capture and [re]establishment facilities, MUPIP EXTRACT does <i>not </i>extract trigger definitions and MUPIP LOAD doesn't restore trigger definitions or invoke any triggers. While you can construct input for MUPIP LOAD which bypasses triggers, there is no way for M code itself to bypass an existing trigger, except by using a GT.CM configuration. The $ZTRIGGER() function permits M code to adjust the triggers, including removing triggers, but those actions affect all processes updating the node associated with any trigger. Like MUPIP EXTRACT and LOAD, the ^%GI and ^%GO M utility programs do not extract and load GT.M trigger definitions. Unlike MUPIP LOAD, ^%GI invokes triggers just like any other M code, which may yield results other than those expected or intended.
</p>
<h2>
  <a id=Managing_Triggers_During_Journ_7707549730126613 name=Managing_Triggers_During_Journ_7707549730126613></a>Triggers in Journaling and Database Replication&nbsp;&nbsp;
</h2>
<p>
  GT.M handles "trigger definitions" and "triggered updates" differently.<br>
</p>
<p>
  <br>
</p>
<p>
</p>
<ul>
  <li>
    Trigger definition changes appear in both journal files and replication streams so the definitions propagate to recovered and replicated databases.
  </li>
  <li>
    Triggered updates appear in the journal file, since MUPIP JOURNAL RECOVER/ROLLBACK to not invoke triggers. &nbsp;However, they do not appear in the replication stream since the Update Process on a replicating instance apply triggers and process their logic.
  </li>
</ul>
<p>
</p>
<h3>
  <a id=Journaling_6032871440963476_38 name=Journaling_6032871440963476_38></a>Journaling
</h3>
<div>
  Effective V5.4-000, the journal extract format changed to accomodate triggers. You may need to adjust the code which reads and processes journal extracts. Here is the summary of the journal extract format changes in V5.4-000:
</div>
<div>
  &nbsp;
  <table border=1 bordercolor=#000000 cellpadding=7 cellspacing=0 width=100%>
    <tbody>
    <tr valign=top>
      <td bgcolor=#e5e5e5 width=24%>
        <p align=center>
          <b>Type</b>
        </p>
      </td>
      <td bgcolor=#e5e5e5 width=28%>
        <p align=center>
          <b>Prior to V5.4-000</b>
        </p>
      </td>
      <td bgcolor=#e5e5e5 width=48%>
        <p align=center>
          <b>V5.4-000 onwards</b>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        Journal extract format
      </td>
      <td width=28%>
        <font face="Courier New">GDSJEX03 (UNIX)<br>
        GDSJEX01 (VMS)</font>
      </td>
      <td width=48%>
        <font face="Courier New">GDSJEX04</font>
      </td>
    </tr>
    <tr>
      <td bgcolor=#e5e5e5 colspan=3 valign=top width=100%>
        <p>
          <b>Existing journal record types</b>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New">KILL</font>
        </p>
      </td>
      <td width=28%>
        <p>
          <font face="Courier New">04\time\tnum\pid\clntpid\token_seq\node</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New">04\time\tnum\pid\clntpid\token_seq\updnum\nodeflags\node</font>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New">SET </font>
        </p>
      </td>
      <td width=28%>
        <p>
          <font face="Courier New">05\time\tnum\pid\clntpid\token_seq\node=sarg</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New">05\time\tnum\pid\clntpid\token_seq\updnum\nodeflags\node=sarg</font>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New">ZTSTART</font>
        </p>
      </td>
      <td width=28%>
        <p>
          <font face="Courier New">06\time\tnum\pid\clntpid\token\jsnum</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New">06\time\tnum\pid\clntpid\token</font>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New">ZTCOM</font>
        </p>
      </td>
      <td width=28%>
        <p>
          <font face="Courier New">07\time\tnum\pid\clntpid\token\jsnum\partners</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New">07\time\tnum\pid\clntpid\token\partners</font>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New">ZKILL</font>
        </p>
      </td>
      <td width=28%>
        <p>
          <font face="Courier New">10\time\tnum\pid\clntpid\token_seq\node</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New">10\time\tnum\pid\clntpid\token_seq\updnum\nodeflags\node</font>
        </p>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New, monospace">NULL</font>
        </p>
      </td>
      <td colspan=2 width=76%>
        NULL records are only possible when you use replication and external M-filters. Journal files generated by GT.M do not have NULL records.
      </td>
    </tr>
    <tr>
      <td bgcolor=#e5e5e5 colspan=3 valign=top width=100%>
        <b>New journal record types</b>
      </td>
    </tr>
    <tr valign=top>
      <td width=24%>
        <p>
          <font face="Courier New, monospace">ZTWORM</font>
        </p>
      </td>
      <td width=28%>
        <p align=center>
          <font face="Courier New, monospace">---NA---</font>
        </p>
      </td>
      <td width=48%>
        <p>
          <font face="Courier New, monospace">11\time\tnum\pid\clntpid\token_seq\ztwormhole</font>
        </p>
      </td>
    </tr>
    </tbody>
  </table>
</div>
<div>
  &nbsp;
</div>
<p>
  Legend (additions and changes):<br>
</p>
<p>
</p>
<div align=left>
  <table border=1 bordercolor=#000000 cellpadding=3 cellspacing=0 height=100% id=jh40>
    <tbody>
    <tr>
      <td align=right valign=top width=8%>
        <font face="Courier New">nodeflags:</font>
      </td>
      <td align=left valign=top width=92%>
        Decimal number interpreted as a binary mask. Currently only 4 bits are used.<br>
        &nbsp;&nbsp;&nbsp; <font face="Courier New">0001</font> (1) =&gt; update journaled but NOT replicated (For example, update inside a trigger)<br>
        &nbsp;&nbsp;&nbsp; <font face="Courier New">0010</font> (2) =&gt; update to a global that had at least one trigger defined, even if no trigger matched this update<br>
        &nbsp;&nbsp;&nbsp; <font face="Courier New">0100</font> (4) =&gt; $ZTWORMHOLE holds the empty string ("") at the time of this update or was not referenced during this update<br>
        &nbsp;&nbsp;&nbsp; <font face="Courier New">1000</font> (8) =&gt; update did not invoke any triggers even if they existed (For example, MUPIP LOAD)&nbsp;<br>
        &nbsp;&nbsp;&nbsp; Combinations of the above bits would mean each of the individual bit characteristics.<br>
        &nbsp;&nbsp;&nbsp; For example,&nbsp; <font face="Courier New">0011</font> =&gt; update within a trigger context, and to a global with at least one trigger defined. Certain bit combinations are impossible. For example, <font face="Courier New">1001</font> since GT.M replicates any update that does not invoke triggers.
      </td>
    </tr>
    <tr>
      <td align=right valign=top width=8%>
        <font face="Courier New">partners:</font><br>
      </td>
      <td align=left valign=top width=92%>
        Number of journaled regions participating in this TP or ZTP transaction (TCOM/ZTCOM record written in this TP or ZTP)
      </td>
    </tr>
    <tr>
      <td align=right valign=top width=8%>
        <font face="Courier New">ztwormhole:</font><br>
      </td>
      <td align=left valign=top width=92%>
        string value from/for $ZTWORMHOLE.&nbsp;
      </td>
    </tr>
    </tbody>
  </table>
</div>
<br>
When journaling is ON, GT.M generates journal records for database updates performed by trigger logic. For an explicit database update, a journal record specifies whether any triggers were invoked as part of that update. GT.M triggers have no effect on the generation and use of before image journal records, and the backward phase of rollback / recovery.<br>
<br>
<p>
  A trigger associated with a global in a region that is journaled can perform updates in a region that is not journaled. However, if triggers in multiple regions update the same node in an unjournaled region concurrently, the replay order for recovery or rollback might differ from that of the original update and therefore produce a different result; therefore this practice requires careful analysis and implementation. Except when using triggers for debugging, FIS recommends journaling any region that uses triggers.<br>
</p>
<p>
  &nbsp;
</p>
<p>
  The following sample journal extract shows how GT.M journals records updates to trigger definitions and information on $ZWORmhole:
</p>
<p>
  &nbsp;
</p>
<font face="Courier New">GDSJEX04 </font>
<div>
  <font face="Courier New">01\61731,15123\1\16422\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">02\61731,15123\1\16422\0</font>
</div>
<div>
  <font face="Courier New">01\61731,15126\1\16423\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,15126\1\16423\0\4294967297</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\1\4\^#t("trigvn","#LABEL")="1"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\2\4\^#t("trigvn","#CYCLE")="1"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\3\4\^#t("trigvn","#COUNT")="1"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\4\4\^#t("trigvn",1,"TRIGNAME")="trigvn#1#"05\61731,15126\1\16423\0\4294967297\5\4\^#t("trigvn",1,"CMD")="S"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\6\4\^#t("trigvn",1,"XECUTE")="W $ZTWORMHOLE s ^trigvn(1)=""Triggered Update"" if $ZTVALUE=1 s $ZTWORMHOLE=$ZTWORMHOLE_"" Code:CR"""</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\7\4\^#t("trigvn",1,"CHSET")="M"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\8\4\^#t("#TRHASH",175233586,1)="trigvn"_$C(0,0,0,0,0)_"W $ZTWORMHOLE s ^trigvn(1)=""Triggered Update"" if $ZTVALUE=1 s $ZTWORMHOLE=$ZTWORMHOLE_"" Code:CR""1"</font>
</div>
<div>
  <font face="Courier New">05\61731,15126\1\16423\0\4294967297\9\4\^#t("#TRHASH",107385314,1)="trigvn"_$C(0,0)_"W $ZTWORMHOLE s ^trigvn(1)=""Triggered Update"" if $ZTVALUE=1 s $ZTWORMHOLE=$ZTWORMHOLE_"" Code:CR""1"</font>
</div>
<div>
  <font face="Courier New">09\61731,15126\1\16423\0\4294967297\1\1\</font>
</div>
<div>
  <font face="Courier New">02\61731,15127\2\16423\0</font>
</div>
<div>
  <font face="Courier New">01\61731,15224\2\16429\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,15224\2\16429\0\8589934593</font>
</div>
<div>
  <font face="Courier New">11\61731,15224\2\16429\0\8589934593\1\"A process context like--&gt; Discount:10%;Country:IN"</font>
</div>
<div>
  <font face="Courier New">05\61731,15224\2\16429\0\8589934593\1\1\^trigvn="Initial Update"</font>
</div>
<div>
  <font face="Courier New">09\61731,15224\2\16429\0\8589934593\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,15232\3\16429\0\12884901889</font>
</div>
<div>
  <font face="Courier New">11\61731,15232\3\16429\0\12884901889\1\"A process context like--&gt; Discount:10%;Country:IN Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,15232\3\16429\0\12884901889\1\1\^trigvn="1"</font>
</div>
<div>
  <font face="Courier New">09\61731,15232\3\16429\0\12884901889\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,15260\4\16429\0\17179869185</font>
</div>
<div>
  <font face="Courier New">11\61731,15260\4\16429\0\17179869185\1\"A process context like--&gt; Discount:10%;Country:IN Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,15260\4\16429\0\17179869185\1\1\^trigvn="Another Update"</font>
</div>
<div>
  <font face="Courier New">09\61731,15260\4\16429\0\17179869185\1\1\BA</font>
</div>
<div>
  <font face="Courier New">02\61731,15263\5\16429\0</font>
</div>
<div>
  <font face="Courier New">01\61731,15865\5\26697\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,15865\5\26697\0\21474836481</font>
</div>
<div>
  <font face="Courier New">05\61731,15865\5\26697\0\21474836481\1\2\^trigvn(1)="Updated outside the trigger."</font>
</div>
<div>
  <font face="Courier New">09\61731,15865\5\26697\0\21474836481\1\1\BA</font>
</div>
<div>
  <font face="Courier New">02\61731,15870\6\26697\0</font>
</div>
<div>
  <font face="Courier New">01\61731,15886\6\26769\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,15886\6\26769\0\25769803777</font>
</div>
<div>
  <font face="Courier New">11\61731,15886\6\26769\0\25769803777\1\" Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,15886\6\26769\0\25769803777\1\1\^trigvn="1"</font>
</div>
<div>
  <font face="Courier New">09\61731,15886\6\26769\0\25769803777\1\1\BA</font>
</div>
<div>
  <font face="Courier New">02\61731,15895\7\26769\0</font>
</div>
<div>
  <font face="Courier New">01\61731,15944\7\26940\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,15944\7\26940\0\30064771073</font>
</div>
<div>
  <font face="Courier New">05\61731,15944\7\26940\0\30064771073\1\3\^trigvn="Another Update"</font>
</div>
<div>
  <font face="Courier New">09\61731,15944\7\26940\0\30064771073\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,16141\8\26940\0\34359738369</font>
</div>
<div>
  <font face="Courier New">11\61731,16141\8\26940\0\34359738369\1\"A process context like--&gt; Discount:10%;Country:IN&nbsp; Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,16141\8\26940\0\34359738369\1\1\^trigvn="1"</font>
</div>
<div>
  <font face="Courier New">09\61731,16141\8\26940\0\34359738369\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,16178\9\26940\0\38654705665</font>
</div>
<div>
  <font face="Courier New">11\61731,16178\9\26940\0\38654705665\1\"A process context like--&gt; Discount:10%;Country:IN&nbsp; Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,16178\9\26940\0\38654705665\1\1\^trigvn="Another update"</font>
</div>
<div>
  <font face="Courier New">09\61731,16178\9\26940\0\38654705665\1\1\BA</font>
</div>
<div>
  <font face="Courier New">02\61731,16210\10\26940\0</font>
</div>
<div>
  <font face="Courier New">01\61731,16517\10\5337\gtm.node1\gtmuser1\21\0\\\</font>
</div>
<div>
  <font face="Courier New">08\61731,16517\10\5337\0\42949672961</font>
</div>
<div>
  <font face="Courier New">05\61731,16517\10\5337\0\42949672961\1\2\^trigvn(1)="4567"</font>
</div>
<div>
  <font face="Courier New">09\61731,16517\10\5337\0\42949672961\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,16522\11\5337\0\47244640257</font>
</div>
<div>
  <font face="Courier New">11\61731,16522\11\5337\0\47244640257\1\" Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,16522\11\5337\0\47244640257\1\1\^trigvn="1"</font>
</div>
<div>
  <font face="Courier New">09\61731,16522\11\5337\0\47244640257\1\1\BA</font>
</div>
<div>
  <font face="Courier New">08\61731,16544\12\5337\0\51539607553</font>
</div>
<div>
  <font face="Courier New">11\61731,16544\12\5337\0\51539607553\1\"No context Code:CR"</font>
</div>
<div>
  <font face="Courier New">05\61731,16544\12\5337\0\51539607553\1\1\^trigvn="1"</font>
</div>
<div>
  <font face="Courier New">09\61731,16544\12\5337\0\51539607553\1\1\BA</font>
</div>
<div>
  <font face="Courier New">02\61731,16555\13\5337\0</font>
</div>
<div>
  <font face="Courier New">03\61731,16555\13\5337\0\0</font>
</div>
<div>
  &nbsp;
</div>
<p>
  This journal extract output shows <font face="Courier New">$ZTWORMHOLE</font> information for each triggered update to <font face="Courier New">^trigvn</font>. Notice how GT.M stored trigger definitions as a node of a global-like structure <font face="Courier New">^#t</font> and how GT.M journals the trigger definition for <font face="Courier New">^trigvn </font>and the triggered update for<font face="Courier New"> ^trgvn.</font>
</p>
<p>
  <br>
</p>
<p>
  <font color=#0000ff>Note: GT.M implicitly wraps a trigger as an M transaction. Therefore, a journal extract file for a database that uses triggers has Type 8 and 9 (TSTART/TCOMMIT) records even if the triggers perform no updates (that is, are effectively No-ops). </font><br>
</p>
<h4>
  <a id=MUPIP_JOURNAL_RECOVER_ROLLBACK_9106664843498762 name=MUPIP_JOURNAL_RECOVER_ROLLBACK_9106664843498762></a>MUPIP JOURNAL -RECOVER / -ROLLBACK
</h4>
<p>
  The lost and broken transaction files generated by MUPIP JOURNAL -RECOVER / -ROLLBACK contain trigger definition information. You can identify these entries + or - and appropriately deal with them using MUPIP TRIGGER and $ZTRIGGER().&nbsp;&nbsp;&nbsp;&nbsp;
</p>
<h3>
  <a id=Multisite_Database_Replication_7430153823458132 name=Multisite_Database_Replication_7430153823458132></a>Multisite Database Replication
</h3>
<p>
  During replication, GT.M replicates trigger definitions to ensure that when MUPIP TRIGGER updates triggers on an initiating instance, all replicating instances remain logically identical.
</p>
<p>
  &nbsp;
</p>
<p>
  The replication stream has no records for updates generated by implicit GT.M trigger logic. If your trigger action invokes a routine, specify the value of the gtmroutines environment variable before invoking replication with MUPIP so the update process can locate any routines invoked as part of trigger actions.&nbsp;
</p>
<p>
  &nbsp;
</p>
<p>
  To support upward compatibility, V5.4-000 allows your originating primary to replicate to:
</p>
<p>
  &nbsp;
</p>
<ul>
  <li>
    <p>
      An instance with a different a trigger configuration.
    </p>
  </li>
  <li>
    <p>
      An instance running a prior GT.M version (having no trigger capability), in which case it replicates any triggered updates.
    </p>
  </li>
</ul>
<p>
  &nbsp;
</p>
<p>
  When a replicating instance needs to serve as a possible future originating instance, you must carefully design your replication filters to handle missing triggers or trigger mismatch situations to maintain logical consistency with the originating primary.
</p>
<h4>
  <a id=Replicating_to_an_instance_wit_8397909650732762 name=Replicating_to_an_instance_wit_8397909650732762></a>Replicating to an instance with a different trigger configuration
</h4>
<p>
  During an event such as rolling upgrade, the replicating instance may have a new database schema (due to application upgrades) and in turn a new set of triggers.&nbsp; Therefore, GT.M replication allows you to have different-trigger configuration for originating (primary) and replicating (secondary) instances.&nbsp; When replication starts between the two instances, any update to triggers on the originating instance automatically flow (through the filters) to the replicating instance. For the duration of the rolling upgrade, your application must use replication filters to ensure trigger updates on the originating instance produce an appropriate action on the replicating instance.&nbsp; However, whenever you follow the practice of creating replicating instances from backups of other appropriate originating instances, you do not have to use additional replication filters, because the backups include GT.M trigger definitions, under normal conditions instances automatically have the same triggers.
</p>
<p>
  &nbsp;
</p>
<p>
  <font color=#000000>Because the replication stream carries the native key format, having different collation for a replicated global on the replicating node from that on the initiating node is effectively a schema change and requires an appropriate filter to appropriately transform the subscripts from initiating form to replicating form. This is true even without triggers. However, with triggers a mismatch also potentially impacts appropriate trigger invocation.</font>
</p>
<p>
  &nbsp;
</p>
<p>
  Because GT.M stores triggers in the database files as pseudo global variables, an application upgrade requiring a change to triggers is, in the worst case, no different than an application upgrade that changes the database schema, and can be handled under current rolling upgrade methods. Some changes to GT.M triggers may well be much simpler than a database schema change, and may not need a rolling upgrade.&nbsp;
</p>
<h4 style=COLOR:#000000>
  <a id=Replicating_to_an_instance_tha_41438381869517404 name=Replicating_to_an_instance_tha_41438381869517404></a>Replicating to an instance that does not support triggers
</h4>
<div style=COLOR:#000000>
  At replication connection, if an originating primary detects a replicating instance that does not support triggers, the Source Server issues a warning to the operator log and the Source Server log. The Source Server also sends a warning message to the operator log and the Source Server log the first time it has to replicate an update associated with a trigger. In this configuration, internal filters in GT.M strip the replication stream of trigger-related information such as $ZTWORMHOLE data and trigger definition updates from MUPIP TRIGGER or $ZTRIGGER(). The Source Server does send updates done within trigger logic.&nbsp; Unless the application has replication filters that appropriately compensate for the trigger mismatch, this is a situation for concern, as the replicating instance may not maintain logical consistency with the originating primary. Note that filters that deal with $ZTWORMHOLE issues must reside on the originating instance.&nbsp; &nbsp;
</div>
<h3 style=COLOR:#000000>
  <a id=Update_Helper_Processes_445095_43763238503831536 name=Update_Helper_Processes_445095_43763238503831536></a>Update &amp; Helper Processes
</h3>
<p>
  <font color=#ff0000><font color=#000000>For any replication stream record indicating triggers were invoked, the Update Process scans for matching GT.M triggers and unconditionally executes the implicit GT.M trigger logic</font>. </font>
</p>
<h2 style=COLOR:#ffffff>
  <a id=MUPIP_TRIGGER_and_ZTRIGGER_420_5237262879328747 name=MUPIP_TRIGGER_and_ZTRIGGER_420_5237262879328747></a><font color=#000000>MUPIP TRIGGER and $ZTRIGGER()</font>
</h2>
<p>
  MUPIP TRIGGER provides a facility to examine and update triggers. The $ZTRIGGER() function performs trigger maintenance actions analogous to those performed by MUPIP TRIGGER. $ZTRIGGER() returns the truth value expression depending on the success of the specified action. You choice of MUPIP TRIGGER or $ZTRIGGER() for trigger maintenance should depend on your current application development model and configuration management practices. &nbsp; Both MUPIP TRIGGER and $ZTRIGGER() use the same trigger definition syntax. You should familiarize yourself with the syntax of an entry in a trigger definition file before exploring MUPIP TRIGGER and $ZTRIGGER(). &nbsp;
</p>
<h3>
  <a id=MUPIP_TRIGGER_6167536123068051_27673809056170584 name=MUPIP_TRIGGER_6167536123068051_27673809056170584></a>MUPIP TRIGGER
</h3>
<p>
  Examines or loads trigger definitions. The format of the MUPIP TRIGGER command is:
</p>
<p>
  &nbsp;
</p>
<font face="Courier New">MUPIP TRIGGER {-TRIG[gerfile]=&lt;trigger_definitions_file&gt;[ -NOPR[ompt]]| [-SELE[ct][=name-list|*][ &lt;select-output-file&gt;]}<br>
</font>
<p>
  &nbsp;
</p>
<div>
  Before you run the MUPIP TRIGGER command:<br>
</div>
<ul>
  <li>
    Set the value of the environment variable <font face="Courier New">gtmgbldir</font>: to specify the value of a current global directory.
  </li>
  <li>
    Ensure that the key size, record size, block size of your database is sufficient for storing trigger definition. You may have to set the key and record sizes larger than the database content would otherwise require.
  </li>
</ul>
<p>
  <br>
  The qualifiers of the MUPIP TRIGGER command are as follows:
</p>
<h4 style="MARGIN:5pt 0pt">
  <a id=TRIGgerfile_7938620190536088_2 name=TRIGgerfile_7938620190536088_2></a>TRIGgerfile
</h4>
<p>
  Loads a trigger definition file to the database. The format of the TRIGGERFILE qualifier is:
</p>
<p>
  &nbsp;
</p>
<div>
  <font face="courier new">-TRIG[gerfile]=&lt;trigger_definitions_file&gt;[-noprompt]</font><br>
</div>
<ul>
  <li>
    For information on the syntax and usage of a trigger definition file, see "<a href=#Trigger_Definition_File_695291 id=tpz- target=_self title="Trigger Definition File">Trigger Definition File</a>".
  </li>
  <li>
    A MUPIP TRIGGER –TRIGGERFILE operation occurs within a transaction boundary, therefore, if even one trigger from the trigger definition file fails to parse correctly, MUPIP TRIGGER rolls back the entire trigger definition file load.
  </li>
  <li>
    MUPIP TRIGGER –TRIGGERFILE ignores blank lines and extra whitespace within lines. It treats lines with a semi-colon in the first position as comments and ignores their content.
  </li>
  <li>
    MUPIP TRIGGER compiles the XECUTE action string and rejects the load if the compilation has errors.
  </li>
  <li>
    Always specify the same value for the environment variable <font face="courier new">gtm_chset</font> during loading and executing triggers. If you specify different values of gtm_chset during loading and executing triggers, MUPIP TRIGGER generates a run-time error (TRIGINVCHSET). GT.M does not prevent a process from updating different nodes with triggers using a different character set, however, GT.M prevents a process from updating the same triggering node with different character sets. Your coding practice, for all database updates, should be to ensure that you provide the same value for <font face="courier new">gtm_chset</font> during load compilation and run-time compilation.
  </li>
  <li>
    Incompatible with: <font face="courier new">-SELECT&nbsp;</font> <font size=2><br>
    </font>
  </li>
</ul>
<br>
<font color=#0000ff>Note: </font><font color=#0000ff>The trigger update&nbsp; summary reports count not only names and option changes as "modified" but also cases where a -COMMANDS list changed, even though those are functionally additions or deletions of separate trigger definitions.</font><br>
<br>
<h4 style="MARGIN:2pt 0pt">
  <a id=SELEct_8216150894080576_818443 name=SELEct_8216150894080576_818443></a>SELEct
</h4>
<p>
  Provides a facility to examine the current trigger definition. SELECT produces a list of the current triggers for a comma-separate list of global variables or trigger names. The format of the SELECT qualifier is:
</p>
<p>
  &nbsp;
</p>
<div>
  <font face="courier new">-SELE[ct][=name-list[*]|*][ &lt;select-output-file&gt;]</font>&nbsp;&nbsp;
</div>
<div>
  &nbsp;
</div>
<ul>
  <li>
    Name-list can include global names, delimited with a leading up-arrow, (^) and/or trigger names with no leading up-arrow. You can specify a trailing asterisk(*) with either.
  </li>
  <li>
    With no arguments specified, GT.M treats -SELECT as –SELECT="*" and extracts a list of all current triggers.
  </li>
  <li>
    Optionally, you can specify a file name to redirect the output of the command. If you do not specify a file name, MUPIP TRIGGER prompts for a file name. If you respond with an empty string (RETURN), MUPIP TRIGGER directs the output to STDOUT.
  </li>
</ul>
<p style="MARGIN:2pt 0pt">
  &nbsp;
</p>
<div style="MARGIN:2pt 0pt">
  <p>
    Note: The output from the MUPIP TRIGGER –SELECT command may not be identical to your trigger definition file. This is because GT.M converts some semantically identical syntax into a single internal representation; while -SELECT output may not be identical to the -TRIGGERFILE input, it has the same meaning.&nbsp; <font color=#0000ff>Additionally, MUPIP TRIGGER -SELECT displays a field called "Cycle" as part of a comment. Cycle is the number of trigger definition updates (addition, modification, or deletion) performed on a global.<br>
    </font>
  </p>
</div>
<h4 style="MARGIN:2pt 0pt">
  <a id=Examples_for_MUPIP_TRIGGER name=Examples_for_MUPIP_TRIGGER></a>&nbsp;
</h4>
<h4 style="MARGIN:2pt 0pt">
  <a id=_Examples_for_MUPIP_TRIGGER_92 name=_Examples_for_MUPIP_TRIGGER_92></a>Examples for MUPIP TRIGGER
</h4>
<div style="MARGIN:2pt 0pt">
  <p>
    This section provides step-by-step instructions for creating, modifying, and deleting triggers. Triggers affect all processes updating a database unlike, for example, environment variables such as $gtmroutines which work on a per process basis. Therefore, FIS recommends that you should always have carefully planned procedures for changing triggers in your production environment.&nbsp;&nbsp;
  </p>
  <p>
    &nbsp;
  </p>
  <p>
    <b>To create a new trigger for global node ^Acct("ID"): </b>&nbsp;
  </p>
</div>
<div style="MARGIN:2pt 0pt">
  <ol>
    <li>
      Using your editor, create a trigger definition file called triggers.trg with the following entry:&nbsp;<br>
      <font face="Courier New">+^Acct("ID") -name=ValidateAccount -commands=S -xecute="Write ""Hello Earth!"""<br>
      <br>
      </font>
    </li>
    <li>
      Execute a command like the following:<br>
      <font face="Courier New">$ mupip trigger –triggerfile=triggers.trg</font><br>
      This command adds a trigger for ^Acct("ID"). On successful trigger load, this command displays an output like the following:
      <div>
        <font face="Courier New">File triggers.trg, Line 1: ^Acct trigger added with index 1</font>
      </div>
      <div>
        <font face="Courier New">========================================= </font>
      </div>
      <div>
        <font face="Courier New">1 triggers added </font>
      </div>
      <div>
        <font face="Courier New">0 triggers deleted </font>
      </div>
      <div>
        <font face="Courier New">0 trigger file entries not changed </font>
      </div>
      <div>
        <font face="Courier New">0 triggers modified </font>
      </div>
      <div>
        <font face="Courier New">========================================= </font>
      </div>
      <div>
        Now, every S[et] operation on the global node ^Acct("ID") executes the trigger.<br>
        <br>
      </div>
    </li>
    <li>
      <div>
        Execute a command like the following:<br>
        <font face="Courier New">$ mupip trigger –select="^Acct*"</font><br>
        This command displays the triggers. A sample output looks like the following:&nbsp;<br>
        <font face="Courier New">;trigger name: ValidateAccount#&nbsp; <font color=#0000ff><font color=#000000>cycle:</font> 1<br>
        </font>+^Acct("ID") -name=ValidateAccount -commands=S -xecute="Write ""Hello Earth!""" </font>
      </div>
    </li>
  </ol>
</div>
<div>
  &nbsp;
</div>
<div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
  <b>To modify an existing trigger for global node ^Acct("ID"):</b>&nbsp;&nbsp;
</div>
<div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
  <p>
    You cannot directly replace an existing trigger definition with a new one. With the exception of -NAME and -OPTIONS, to change an existing trigger, you have to delete the existing trigger definition and then add the modified trigger definition as a new trigger. Note that GT.M performs two different trigger comparisons to match trigger definitions depending on whether or not S[ET] is the trigger invocation command. If there is a S[ET], then the comparison is based on the global name and subscripts, PIECES, [Z]DELIM, and XECUTE. If there is no SET, GT.M compares only the global node with subscripts and the -XECUTE code value.<br>
  </p>
</div>
<ol>
  <li>
    <div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
      <font face=Verdana>Begin by executing the following command: </font><br>
      <font face="Courier New">$mupip trigger -select="^Acct*"<br>
      Output file:&nbsp; </font>
    </div>
  </li>
  <li>
    <div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
      <font face=Verdana>Specify trigger_mod.trg as the output file. This file contains entries like the following:</font><br>
      <font face="Courier New">;trigger name: ValidateAccount#&nbsp; <font color=#0000ff><font color=#000000>cycle:</font> 1</font><br>
      +^Acct("ID") -name=ValidateAccount -commands=S -xecute="Write ""Hello Earth!"""</font>
    </div>
  </li>
  <li>
    <div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
      <font face=Verdana>Using your editor, open trigger_mod.trg and change + (plus) to - (minus) for the trigger definition entry for ValidateAccount and add a new trigger definition for ^Acct("ID"). To avoid inconsistent application behavior, it is important to replace an old trigger with a new one in the same transaction (Atomic). The trigger_mod.trg file should have entries like:<br>
      </font><font face="courier new">;trigger name:&nbsp; ValidateAccount#&nbsp;&nbsp;&nbsp; cycle: 1<br>
      -^Acct("ID") -name=ValidateAccount -commands=Set -xecute="Write ""Hello Earth!"""<br>
      ;trigger name: ValidateAccount#<br>
      +^Acct("ID") -name=ValidateAccount -commands=Set -xecute="Write ""Hello Mars!"""&nbsp;</font>
    </div>
  </li>
  <li>
    <div align=left style="COLOR:#000000;MARGIN:5pt 0pt">
      Execute a command like the following:<br>
      $ <font face="Courier New">mupip trigger -triggerfile=trigger_mod.trg</font>
    </div>
  </li>
</ol>
<div align=left>
  <ol>
    <div>
      <font face=Verdana>This command displays an output like the following:</font>&nbsp;&nbsp;<br>
    </div>
    <div>
      <font face="Courier New">File trigger_mod.trg, Line 1: ^Acct trigger deleted<br>
      </font><font face="courier new">File trigger_mod.trg, Line 3: ^Acct trigger added with index 1<br>
      =========================================<br>
      1 triggers added<br>
      1 triggers deleted<br>
      0 trigger file entries not changed<br>
      0 triggers modified<br>
      </font><font face="courier new">=========================================</font><br>
      <br>
      Congratulations! You have successfully modified the xecute string of ValidateAccount with the new one.&nbsp;
    </div>
    <div>
      &nbsp;
    </div>
  </ol>
</div>
<div align=left>
  &nbsp;&nbsp;<b>To delete an existing trigger for global node ^Acct("ID"):</b>&nbsp;&nbsp;&nbsp; &nbsp;<br>
</div>
<br>
<ol>
  <li>
    Begin by executing the following command:&nbsp;<br>
    <font face="Courier New">$mupip trigger -select="^Acct*"</font><br>
    <font face="Courier New">Output file:<br>
    <br>
    </font>
  </li>
  <li>
    Specify trigger_delete.trg as the output file. This file contains entries like the following:<br>
    <font face="courier new">;trigger name: ValidateAccount#&nbsp; cycle: 3<br>
    +^Acct("ID") -name=ValidateAccount -commands=S -xecute="Write ""Hello Mars!"""<br>
    <br>
    </font>
  </li>
  <li>
    Using your editor, change + (plus) to - (minus) for the trigger definition entry for <font face="Courier New">ValidateAccount</font>. Alternatively, you can create a file with an entry like <font face="Courier New">-ValidateAccount</font>.&nbsp;&nbsp;<br>
    <br>
  </li>
  <li>
    Now, execute a command like the following:<br>
    <font face="Courier New">$ mupip trigger -triggerfile=trigger_delete.trg<br>
    <br>
    </font>This command displays an output like the following:&nbsp;
  </li>
</ol>
<p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
</p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New">File trigger_delete.trg, Line 2: ^Acct trigger deleted<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New">=========================================<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 triggers added<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 triggers deleted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 trigger file entries not changed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 triggers modified<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=========================================</font><br>
<p style=MARGIN-LEFT:40px>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</p>
<p>
  You have successfully deleted trigger "ValidateAccount".<br>
</p>
<p>
  <br>
</p>
<p>
</p>
<div align=left style="COLOR:#274e13;MARGIN:5pt 0pt">
  <font color=#0000ff><b>To change a trigger name for global node ^Acct("ID"):</b>&nbsp;&nbsp; </font>
</div>
<div align=left style="COLOR:#274e13;MARGIN:5pt 0pt">
  <p>
  </p>
</div>
<ol>
  <li style=COLOR:#274e13>
    <font color=#0000ff><font face=verdana>U</font>sing your editor, create a new file called <font face="Courier New">trigger_rename.trg</font> and add a trigger definition entry for <font face="Courier New">ValidateAcct</font> with the same trigger signature as <font face="courier new">ValidateAccount</font>. Your trigger definition would look something like:&nbsp;<br style=COLOR:#274e13>
    <font face="courier new">+^Acct("ID") -name=ValidateAcct -commands=S -xecute="Write ""Hello Mars!"""</font><br style=COLOR:#274e13>
    </font>
  </li>
  <li style=COLOR:#274e13>
    <div align=left style="MARGIN:5pt 0pt">
      <font color=#0000ff><font face=Verdana>Verify that the <font face="courier new">ValidateAccount </font>trigger exists by executing the following command: </font><br>
      </font><font color=#0000ff><font face="Courier New">$mupip trigger -select="^Acct*"<br>
      Output file:</font><br>
      </font>
    </div>
  </li>
  <li style=COLOR:#274e13>
    <div align=left style="MARGIN:5pt 0pt">
      <font color=#0000ff>Respond with an empty string (Press Enter). Confirm that the trigger summary report contains an entry like the following:<br>
      <font face="courier new">;trigger name: ValidateAccount#&nbsp; cycle: 3</font></font><font face="courier new"><br>
      <font color=#0000ff>+^Acct("ID") -name=ValidateAccount -commands=S -xecute="Write ""Hello Mars!"""</font></font>
    </div>
  </li>
  <li>
    <font color=#0000ff>Now, execute a command like the following:<br style=COLOR:#274e13>
    <font face="Courier New">$ mupip trigger -triggerfile=trigger_rename.trg</font><br style=COLOR:#274e13>
    </font><br>
    <font color=#0000ff>This command displays an output like the following: </font><br style=COLOR:#274e13>
    <font color=#0000ff><font face="courier new">=========================================</font><br style="COLOR:#274e13;FONT-FAMILY:Courier New">
    <font face="courier new">0 triggers added</font><br style="COLOR:#274e13;FONT-FAMILY:Courier New">
    <font face="courier new">0 triggers deleted</font><br style="COLOR:#274e13;FONT-FAMILY:Courier New">
    <font face="courier new">0 trigger file entries not changed</font><br style="COLOR:#274e13;FONT-FAMILY:Courier New">
    <font face="courier new">1 triggers modified</font><br style="COLOR:#274e13;FONT-FAMILY:Courier New">
    <font face="courier new">=========================================</font><br style=COLOR:#274e13>
    You have successfully changed the trigger name <font face="courier new">ValidateAccount</font> to <font face="courier new">ValidateAcct</font>.<br>
    </font><br>
  </li>
</ol>
<p>
</p>
<h3>
  <a id=_ZTRIGGER_2451844221301963_501 name=_ZTRIGGER_2451844221301963_501></a>$ZTRIGGER
</h3>
<div>
  Use the $ZTRIGGER() function to examine or load trigger definition. The format of the $ZTRIGGER() function is:&nbsp;&nbsp;
</div>
<div>
  &nbsp;
</div>
<div>
  <font face="Courier New">$ZTRIgger(expr1[,expr2])</font>&nbsp;&nbsp;
</div>
<div>
  &nbsp;
</div>
<ul>
  <li>
    $ZTRIGGER() returns the truth value expression depending on the success of the specified action.
  </li>
  <li>
    $ZTRIGGER() performs trigger maintenance actions similar those performed by MUPIP TRIGGER. &nbsp;
  </li>
  <li>
    If expr1 evaluates to case-insensitive "FILE", $ZTRIGGER() evaluates <font face="Courier New">expr2</font> as the location of the trigger definition file. Then, it applies the trigger definitions in the file specified by <font face="Courier New">expr2</font> with no user confirmation in the case of a -*.
  </li>
  <li>
    If expr1 evaluates to case-insensitive "ITEM", $ZTRIGGER() evaluates <font face="Courier New">expr2</font> as a single line trigger definition entry.
  </li>
  <li>
    If expr1 evaluates to case-insensitive "SELECT", $ZTRIGGER() evaluates the optional <font face="Courier New">expr2</font> as a trigger name or name wildcard, and direct its output to $IO. A FALSE result indicates there are no matching triggers.&nbsp;
  </li>
  <li>
    A $ZTRIGGER() within a TP transaction (0&lt;$TLEVEL) produces a ZTRIGNOTP error.&nbsp;
  </li>
</ul>
<br>
<h4>
  <a id=Examples_for_ZTRIGGER name=Examples_for_ZTRIGGER></a>Examples for $ZTRIGGER
</h4>
<font face="courier new">GTM&gt;set X=$ZTRIGGER("S")</font><br>
<br>
This example displays the current trigger definitions stored in the database.<br>
<br style="FONT-FAMILY:Courier New">
<font face="courier new">GTM&gt;set X=$ZTRIGGER("i","+^Acct(sub=:) - command=Set -xecute=""Set ^X($ZTVALUE)=sub""")</font><br>
<br>
This example adds a trigger definition for the first level node of <font face="courier new">^Acct</font>.<br>
<h2>
  <a id=ISVs_and_Environment_Variables_24024687006173362 name=ISVs_and_Environment_Variables_24024687006173362></a>ISVs and Environment Variables&nbsp;
</h2>
<p>
  GT.M provides seven ISVs (Intrinsic Special Variables) to facilitate trigger operations. With the exception of $ZWORMHOLE, all trigger-related ISVs return zero (0) if they have numeric values or an empty string when referenced by code outside of a trigger context.
</p>
<h3>
  <a id=ZTCode_17816755651572924_74733_014850263749313641 name=ZTCode_17816755651572924_74733_014850263749313641></a>$ZTCOde
</h3>
<p>
  Within trigger context, $ZTCOde evaluates to a string containing the trigger code (that is, the string value for the –xecute in the trigger definition). Outside trigger context, $ZTCOde has the value of an empty string.
</p>
<div>
  &nbsp;
</div>
<div>
  Example:
</div>
<p>
  $ZTCode evaluates to<font face="courier new"> Write "Hello Mars!</font>" in the context of trigger in the following definition:
</p>
<div class=programlisting>
  &nbsp;
</div>
<div class=programlisting>
  <font face="courier new">+^Acct("Id") -name=Acct -commands=Set -xecute="Write ""Hello Mars!"""</font><br>
  <br>
</div>
<p>
  Note that even though the quotes inside the -xecute literal are doubled as in normal M, $ZTCode evaluates them as one quote, again as in normal M.
</p>
<h3>
  <a id=ZTDATA_9789166493622181_093555_7093928520373519 name=ZTDATA_9789166493622181_093555_7093928520373519></a>$ZTDAta
</h3>
<p>
  Within trigger context, $ZTDATA returns <font face="courier new">$Data(@$REFERENCE)#2</font> for a SET or <font face="courier new">$Data(@$REFERENCE)</font> for a KILL, ZKILL or ZWITHDRAW prior to the explicit update. This provides a fast path alternative, avoiding the need for indirection in trigger code, to help trigger code determine the characteristics of the triggering node prior to the triggering update. For a SET, it shows whether the node did or did not hold data - whether a SET is modifying the contents of an existing node or creating data at a new node. For a KILL it shows whether the node had descendants and whether it had data.
</p>
<div>
  &nbsp;
</div>
<div>
  Outside trigger context, $ZTDATA, returns zero (0).
</div>
<h3>
  <a id=ZTLEVEL_7369127931401924_64612_7123582267582766 name=ZTLEVEL_7369127931401924_64612_7123582267582766></a>$ZTLevel
</h3>
<p>
  Within trigger context, $ZTLevel returns the current level of trigger nesting (invocation by a trigger of an additional trigger by an update in trigger context).
</p>
<div>
  &nbsp;
</div>
<div>
  $ZTLevel greater than one (&gt;1) indicates that there are nested triggers in progress. When a single update invokes multiple triggers solely because of multiple trigger matches of that initial (non-trigger) update, they aren’t nested (they are chained) and thus all have same $ZTLevel.
</div>
<p>
  <br>
</p>
<p>
  Outside trigger context (no trigger active), $ZTLevel returns 0.
</p>
<div>
  &nbsp;
</div>
<div>
  Example:
</div>
<div>
  <font face="Courier New">+^Cycle(1) -commands=Set -xecute="Write ""$ZTLevel for ^Cycle(1) is: "",$ZTLevel Set ^Cycle(2)=1"<br>
  +^Cycle(2) -commands=Set -xecute="Write ""$ZTLevel for ^Cycle(2) is: "",$ZTLevel Set ^Cycle(1)=1"<br>
  </font>
</div>
<p>
  These trigger definitions show different values of $ZTLevel when two triggers are called recursively (and pathologically).
</p>
<div class=programlisting>
  &nbsp;
</div>
<div class=programlisting>
  <font face="Courier New">+^Acct("ID") –commands=Set –xecute="Set ^Acct(1)=$ZTVALUE+1"</font>
</div>
<font face="Courier New">+^Acct(sub=:) - command=Set -xecute="Set ^X($ZTVALUE)=sub"</font>
<div>
  &nbsp;
</div>
<div>
  SET ^Acct("ID")=10 invokes both the above triggers in some order and $ZTLevel will have the same value in both because these triggers are chained rather than nested.
</div>
<h3>
  <a id=ZTOLDval_9980852676208929_6086_40753979322937217 name=ZTOLDval_9980852676208929_6086_40753979322937217></a>$ZTOLdval
</h3>
<div>
  Within trigger context, $ZTOLDVAL returns the prior (old) value of the global node whose update caused the trigger invocation. This provides a fast path alternative to $Get(@$REFERENCE) at trigger entry (which avoids the heavyweight indirection ). If there are multiple triggers matching the same node (chained), $ZTOLDVAL returns the same result for each of them.
</div>
<div>
  &nbsp;
</div>
<p>
  Outside trigger context, $ZTOLDVAL has the value of an empty string.
</p>
<div>
  &nbsp;
</div>
<div>
  Example:
</div>
<div>
  <font face="Courier New">+^Acct(1,"ID") -commands=Set -xecute="Write ""Is ^Acct(1,ID) previously defined? "",$ZTDATA Write "" Old value of ^Acct(1,ID)="",$ZTOLDVAL Set ^Acct(1,""Name"")=""&lt;First Name&gt; &lt;Last Name&gt;"" Write ""Current Value of ^Acct(I,ID)="",^Acct(1,""ID"")"<br>
  </font>
</div>
<div>
  &nbsp;
</div>
<div>
  Suppose ^Acct(1,"ID") has a value of 4412. This trigger gets invoked with a SET command like the following:
</div>
<div class=programlisting>
  &nbsp;
</div>
<div class=programlisting>
  <font face="Courier New">GTM&gt;write ^Acct(1,"ID")<br>
  4412<br>
  GTM&gt;set ^Acct(1,"ID")=9891<br>
  Is ^Acct(1,ID) previously defined? 1<br>
  Old value of ^Acct(1,"ID")=4412<br>
  Current value of ^Acct(1,"ID")=9891</font><br>
</div>
<h3>
  <a id=ZTRIGGEROP_15597338125752685_4_4879474761480417 name=ZTRIGGEROP_15597338125752685_4_4879474761480417></a>$ZTRIggerop
</h3>
<div>
  Within trigger context, for SET (including MERGE and $Increment() operations), $ZTRIGGEROP has the value "S". For KILL, $ZTRIGGEROP has the value "K" For ZKILL or ZWITHDRAW, $ZTRIGGEROP has the value "ZK". &nbsp; Outside trigger context, $ZTRIGGEROP has the value of an empty string.
</div>
<div>
  &nbsp;
</div>
<h3 style="MARGIN:0pt 0pt 10pt">
  <a id=ZTSLATE_05477704183700538 name=ZTSLATE_05477704183700538></a><font color=#0000ff>$ZTSlate</font>
</h3>
<p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
  $ZTSLATE allows you to specify a string that you want to make available in chained or nested triggers invoked for an outermost transaction (when a TSTART takes $TLEVEL from 0 to 1). You might use $ZTSLATE to accumulate transaction-related information, for example $ZTOLDVAL and $ZTVALUE,&nbsp; available within trigger context for use in a subsequent trigger later in the same transaction. For example,&nbsp; you can use $ZTSLATE to build up an application history or journal record to be written when a transaction is about to commit.
</p>
<p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
  You can SET $ZTSLATE only while a database trigger is active. GT.M clears $ZTSLATE for the outermost transaction or on a TRESTART. However, GT.M retains $ZTSLATE for all sub-transactions (where $TLEVEL&gt;1).<br>
</p>
<p style="COLOR:#0000ff;MARGIN:0pt 0pt 10pt">
  <br>
</p>
<h3>
  <a id=ZTUPDATE_10020805229422586_409_36494897036165375 name=ZTUPDATE_10020805229422586_409_36494897036165375></a>$ZTUPdate
</h3>
<div>
  Within trigger context, for SET commands where the GT.M trigger specifies a piece separator, $ZTUPDATE provides a comma separated list of piece numbers of pieces that differ between the current values of $ZTOLDVAL and $ZTVALUE. If the trigger specifies a piece separator, but does not specify any pieces of interest, $ZTUPDATE identifies all changed pieces. &nbsp; $ZTUPDATE is 0 in all other cases (that is: for SET commands where the GT.M trigger does not specify a piece separator or for Kills). Note that if an update matches more than one trigger, all matching triggers see the same $ZTOLDVAL at trigger entry but potentially different values of $ZTVALUE so $ZTUPDATE could change due to the actions of each matching trigger even though all matching triggers have identical -[z]delim and -piece specifications. &nbsp; Outside trigger context, $ZTUPDATE has the value of an empty string.&nbsp;&nbsp;
</div>
<div>
  &nbsp;
</div>
<div>
  Example:
</div>
<p>
  <font face="Courier New">+^trigvn -commands=Set -pieces=1;3:6 -delim="|" -xecute="Write !,$ZTUPDATE"</font>
</p>
<div>
  &nbsp;
</div>
<div>
  In the above trigger definition entry, $ZTUPDdate displays a comma separated list of the changed piece numbers if on of the pieces of interest: 1,3,4,5,or 6 are modified by the update.
</div>
<div style="FONT-FAMILY:Courier New">
  &nbsp;
</div>
<div style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
  <font face="courier new">GTM&gt;write ^trigvn </font><br>
  <font face="courier new">Window|Table|Chair|Curtain|Cushion|Air Conditioner<br>
  </font><font face="courier new">GTM&gt;set ^trigvn="Window|Dining Table|Chair|Vignette|Pillow|Air Conditioner"<br>
  </font><font face="courier new">4,5</font>
</div>
<div style="FONT-FAMILY:Courier New">
  &nbsp;
</div>
<div style="FONT-FAMILY:Courier New">
  <font face=Verdana>Note that even though piece numbers 2,4 and 5 are changed, $ZTUPDATE displays only 4,5 because the trigger is not defined for updates for the second piece.</font>
</div>
<h3 style="FONT-FAMILY:Courier New">
  <a id=_ZTVAlue_3231391431763768_4805 name=_ZTVAlue_3231391431763768_4805></a><font face=verdana>$ZTVAlue</font>
</h3>
<p style="FONT-FAMILY:Courier New">
  <font face=verdana>For SET, $ZTVALUE has the value assigned to the node by the explicit SET operation. Modifying $ZTVALUE within a trigger modifies the eventual value GT.M assigns to the node. Note that changing $ZTVALUE has some performance impact as it causes an additional update operation on the node once all trigger code completes. If a node has multiple associated triggers each trigger receives the current value of $ZTVALUE, however, because the triggers run in arbitrary order, FIS strongly recommends no more than one trigger change any given element of application data, for example, a particular piece. For KILL and its variants, $ZTVALUE returns the empty string "". While GT.M accepts updates to $ZTVALUE within the trigger code invoked for a KILL or any of its variants, it ultimately discards any such value. Outside trigger context, $ZTVALUE has the value of an empty string and attempting to SET it produces a SETINTRIGONLY error.</font>
</p>
<br>
<h3>
  <a id=_ZTWOrmhole_723045572067297_66 name=_ZTWOrmhole_723045572067297_66></a>$ZTWOrmhole
</h3>
<div>
  <font color=#0000ff>$ZTWORMHOLE allows you to specify a string up to 128KB of information you want to make available during trigger execution.</font> You can use $ZTWORMHOLE to supply an application-context or process context to your trigger logic. Because GT.M makes $ZTWORMHOLE available throughout the duration of the process, you can access or update $ZTWORMHOLE both from inside and outside a trigger.
</div>
<div>
  &nbsp;
</div>
<div>
  In many ways, $ZTWORMHOLE is like a wormhole (a popular concept in time-travel stories). Just as a wormhole provides a way to jump into a specific time-space continuum, $ZTWORMHOLE in GT.M provides a mechanism to access information from a process/application context that is otherwise unavailable in trigger context. GT.M records any non-empty string value of $ZTWORMHOLE in the GT.M database journal file as part of any update that invokes at least one trigger which references $ZTWORMHOLE. GT.M also transmits any non-NULL $ZTWORMHOLE value in the replication stream, thus providing the same context to triggers invoked by MUPIP processes (either as part of the replicating instance update process or as part of MUPIP journal recovery/rollback). Therefore, whenever you use $ZTWORMHOLE in a trigger, you create something like a wormhole for process context that is otherwise NEWed in the run-time or non-existent in MUPIP.
</div>
<div>
  &nbsp;
</div>
<div>
  Note that if trigger code does not reference $ZTMOrmhole, GT.M does not make it available to MUPIP (via the journal files or replication stream). Therefore, if a replicating secondary has different trigger code than the initiating primary (an unusual configuration) and the triggers on the replicating node require information from $ZTWORMHOLE, the triggers on the intiating node must reference $ZTWORMHOLE to ensure GT.M maintains the data it contains for use by the update process on the replicating node. While you can change $ZWORmhole within trigger code, because of the arbitrary ordering of triggers on the same node, such an approach requires careful design and implementation.<br>
  <br style=COLOR:#0000ff>
  <font color=#0000ff>GTM allows $ZTWOrmhole to be NEW’d. NEWing $ZTWOrmhole is slightly different from NEWing other ISVs/variables in the sense that the former retains its original value whereas the latter does not. However, like other NEWs, GT.M restores $ZTWOrmhole's value when the stack level pops.</font><br>
</div>
<div>
  &nbsp;
</div>
<div>
  The following example illustrates a simple use case for $ZTWORMHOLE.
</div>
<div>
  &nbsp;
</div>
<div>
  Suppose a large commercial bank runs a real-time core processing application in about 4000 networked branches across US, Europe, and Asia. For each continent, one centrally-located GT.M database serves all instances of the real-time core processing application for each branch. To capitalize on market opportunities, the bank decides to offer 25% to 50% discount on buying a new investment product for its existing customers. The discount percentage is based on the applicable regulations and laws of the country served by the branch. Due to some recently introduced regulatory requirements in a country in Asia, a discount cannot be offered if the investment product is purchased by switching (that is, selling one investment product to buy another investment product).
</div>
<div>
  &nbsp;
</div>
<div>
  This business rule can be implemented using the following guidelines:
</div>
<div>
  &nbsp;
</div>
<ul>
  <li>
    For each sale transaction, set $ZTWORmhole to contain the country-specific discount percentage and investment switching information.
  </li>
  <li>
    Design the trigger code to read the $ZTWORmhole information and complete the sale process.
  </li>
  <li>
    GT.M ensures that the process-specific context, available in $ZTWORmhole, goes into the journal files and replication stream so that it can be recalled in a future database administration or audit operation.
  </li>
</ul>
<div>
  &nbsp;
</div>
<div>
  Without $ZTWORmhole, additional update cycles and globals would have been consumed to preserve process-specific (applicable discount and switching) information.<a id=How-to_Scenarios name=How-to_Scenarios></a><font face=verdana>The following table summarizes the read/write permissions assigned to all trigger-related ISVs within trigger context and outside trigger context.</font>
</div>
<div style="FONT-FAMILY:Courier New">
  &nbsp;&nbsp;
  <table bgcolor=#ffffff border=1 bordercolor=#000000 cellpadding=1 cellspacing=1 class=informaltable style=BACKGROUND-IMAGE:none;BACKGROUND-REPEAT:repeat;WIDTH:100% width=100%>
    <tbody>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:19.72% width=19%>
        <div style=TEXT-ALIGN:center>
          <font face=Verdana><b>Intrinsic Special Variable </b></font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style=TEXT-ALIGN:center>
          <font face=Verdana><b>Outside Trigger Context&nbsp;&nbsp;&nbsp;&nbsp; </b></font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt;TEXT-ALIGN:center">
          <font face=Verdana><b>Within Trigger Context </b></font>
        </div>
      </td>
      <td bgcolor=transparent style=WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt;TEXT-ALIGN:center">
          <font face=Verdana><b>Notes</b> </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ETrap </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Set to gtm_trigger_etrap or the empty string when entering trigger context </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$Reference </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Restored at the completion of a trigger </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$Test </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Restored at the completion of a trigger </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$TLevel </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Always &gt;=1 in trigger code; must be the same as the completion of processing a trigger as it was at the start </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTCOde </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Shows the trigger code </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTDAta </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - 0 </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Shows prior state </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTLEvel </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - 0 </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Shows trigger nesting </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTOLdval </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Shows the pre-update value </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTrap </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Must use $ETrap in trigger code </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTRIggerop </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Shows the triggering command </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTUPdate </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Lists modified pieces (if requested) for SET<br>
          </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTVAlue </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read only - "" </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Can change the eventual applied value for SET<br>
          </font>
        </div>
      </td>
    </tr>
    <tr>
      <td style="BACKGROUND-COLOR:transparent;FONT-FAMILY:Courier New;WIDTH:19.72%" width=19%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>$ZTWOrmhole </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:13.08% width=13%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td style=BACKGROUND-COLOR:transparent;WIDTH:11.68% width=11%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>&nbsp;Read / Write </font>
        </div>
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;WIDTH:55.5% valign=top width=40%>
        <div style="MARGIN:0pt 0pt 0pt">
          <font face=Verdana>Holds application context because trigger code has no access to the local variable context </font>
        </div>
      </td>
    </tr>
    </tbody> <tbody>
    <tr>
      <td style=BACKGROUND-COLOR:transparent;COLOR:#0000ff;FONT-FAMILY:Verdana;WIDTH:19.72% width=19%>
        $ZTSlate
      </td>
      <td style=BACKGROUND-COLOR:transparent;COLOR:#0000ff;FONT-FAMILY:Verdana;WIDTH:13.08% width=13%>
        <p style=TEXT-ALIGN:center>
          -
        </p>
      </td>
      <td style=BACKGROUND-COLOR:transparent;COLOR:#0000ff;FONT-FAMILY:Verdana;WIDTH:11.68% width=11%>
        Read/ Write
      </td>
      <td bgcolor=transparent style=BACKGROUND-COLOR:transparent;COLOR:#0000ff;FONT-FAMILY:Verdana;WIDTH:55.5% valign=top width=40%>
        <font size=2>Holds outermost transaction context for chained or nested triggers.</font>
      </td>
    </tr>
    </tbody>
  </table>
</div>
<h3 style="FONT-FAMILY:Courier New">
  <a id=Examples_for_Trigger_ISVs_3316_17053643101540827 name=Examples_for_Trigger_ISVs_3316_17053643101540827></a><font face=Verdana>Examples for Trigger ISVs</font>&nbsp;&nbsp;
</h3>
<div style="FONT-FAMILY:Courier New">
  <div style="FONT-FAMILY:Courier New">
    <div style="FONT-FAMILY:Courier New">
      <div style="FONT-FAMILY:Courier New">
        <div style="FONT-FAMILY:Courier New">
          <div style="FONT-FAMILY:Courier New">
            <div style="FONT-FAMILY:Courier New">
              <div style="FONT-FAMILY:Courier New">
                <div style="FONT-FAMILY:Courier New">
                  <div style="FONT-FAMILY:Courier New">
                    <p>
                    <font face=Verdana>Nodes in <font face="courier new">^ACN(CID,50)</font> have TYPE in piece 1, CLS in piece 2, FEEPLN in piece 15 and EMPLNO in piece 31. Indexes are <font face="courier new">^XACN(CLS,ACN,CID)</font>, <font face="courier new">^XREF("EMPLCTA",EMPLNO,ACN,TYPE,CID)</font> and <font face="courier new">^XREF("FEEPLN",FEEPLN,CID)</font> and use ACN from the first piece of <font face="courier new">^ACN(CLS,99)</font>. These indexes are maintained with four triggers: one invoked by a KILL or ZKill of an ^ACN(:,50) node and three invoked by SETs to different pieces of ^ACN(:,50) nodes. Note that ACN, CID, CLS and TYPE are required, whereas EMPLNO and FEEPLN can be null, which requires (in our convention) the use of $ZC(254) in indexes. &nbsp; The triggerfile definitions are:</font>
                    </p>
                    <div style="FONT-FAMILY:Courier New">
                    &nbsp;
                    <div style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    <font face="courier new">+^ACN(cid=:,50) -zdelim="|" -pieces=2 -commands=SET -xecute="Do ^SclsACN50" </font>&nbsp;
                    </div>
                    <div style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    <font face="courier new">+^ACN(cid=:,50) -zdelim="|" -pieces=1,31 -commands=SET -xecute="Do ^SemplnoTypeACN50" </font><font face="courier new">+^ACN(cid=:,50) -zdelim="|" -pieces=15 -commands=SET -xecute="Do ^SfeeplnACN50"&nbsp;</font>
                    </div>
                    <div style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    <font face="courier new">+^ACN(cid=:,50) -commands=KILL,ZKill -xecute="Do ^KACN50" </font>&nbsp;<br>
                    <br>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <p>
                    <font face=Verdana>The code in KACN50.m kills cross reference indexes when the application deletes any ^ACN(:,50).&nbsp;&nbsp;&nbsp;&nbsp; </font>
                    </p>
                    <p>
                    &nbsp;
                    </p>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KACN50 ; KILL of entire ^ACN(:,50) node, e.g., from account deletion</font>
                    <div style="FONT-FAMILY:Courier New">
                    <p style="FONT-FAMILY:Courier New">
                    </p>
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">; Capture information</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Set cls=$Piece($ZTOLD,"|",2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; CLS</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Set emplno=$Piece($ZTOLD,"|",31)<br>
                    Set:'$Length(emplno) emplno=$ZC(254)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; EMPLNO</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Set feepln=$Piece($ZTOLD,"|",15) Set:'$L(feepln) feepln=$ZC(254) ; FEEPLN</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Set type=$Piece($ZTOLD,"|",1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; TYPE</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Set acn=$Piece(^ACN(cid,99),"|",1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ACN</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Kill ^XACN(cls,acn,cid)</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Kill ^XREF("EMPLCTA",emplno,acn,type,cid)</font><br style="FONT-FAMILY:Courier New">
                    <font face="courier new">Kill ^XREF("FEEPLN",feepln,cid)<br>
                    </font><font face="courier new">Quit</font><br>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <br>
                    <p>
                    <font face=Verdana>The routine in SclsACN50.m creates cross references for a SET or a SET $Piece() that modifies the second piece of ^ACN(:,50).</font>
                    </p>
                    <p>
                    &nbsp;
                    </p>
                    <p>
                    <font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp; SClsACN50 ; Update to CLS in ^ACN(,50) </font><br style="FONT-FAMILY:Courier New">
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    ; Capture information&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set oldcls=$Piece($ZTOLD,"|",2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Old CLS&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set cls=$Piece($ZTVAL,"|",2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; New CLS&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set acn=$Piece(^ACN(cid,99),"|",1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ACN&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set processMode=$Piece($ZTWORM,"|",1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Process<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    If processMode&lt;2 Kill ^XACN(oldcls,acn,cid)<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set ^XACN(cls,acn,cid)=""&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    <font face="courier new">Quit &nbsp; </font><br>
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    &nbsp;
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    <font face=Verdana>Note that the example is written for clarity. Eliminating values that need not be assigned to temporary local variables produces:</font>
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    &nbsp;
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    &nbsp;&nbsp;&nbsp; SClsACN50 ; Update to CLS in ^ACN(,50)<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    ; Capture information&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set oldcls=$Piece($ZTOLD,"|",2) &nbsp; &nbsp; &nbsp;; Old CLS&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Set acn=$Piece(^ACN(cid,99),"|",1) ; ACN&nbsp;<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    If $Piece($ZTWORM,"|",1)&lt;2 Do<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    . Kill ^XACN(oldcls,acn,cid) Set ^XACN($P($ZTVAL,"|",2),acn,cid)=""
                    </p>
                    <p style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    Quit<br>
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    <br>
                    </p>
                    <p style="FONT-FAMILY:Courier New">
                    <font face=Verdana>Or for automatically generated code where readability is not important, the routine can be just two lines:</font>
                    </p>
                    <div style="FONT-FAMILY:Courier New">
                    &nbsp;
                    <div style="FONT-FAMILY:Courier New">
                    <font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SclsACN50 </font><br>
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">S oldcls=$P($ZTOLD,"|",2),acn=$P(^ACN(cid,99),"|",1) </font><br>
                    <font face="courier new">I $P($ZTWORM,"|",1)&lt;2 K ^XACN(oldcls,acn,cid) </font><br>
                    <font face="courier new">S ^XACN($P($ZTVAL,"|",2),acn,cid)=""<br>
                    </font><font face="courier new">Q</font> &nbsp;<br>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <br>
                    <p>
                    <font face=verdana>Indeed, this index can simply be included in the (one line) triggerfile specification itself: </font>
                    </p>
                    <div style="FONT-FAMILY:Courier New">
                    &nbsp;
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">+^ACN(cid=:,50) -zdelim="|" -pieces=2 -commands=SET -xecute="S oldcls=$P($ZTOLD,""|"",2),acn=$P(^ACN(cid,99),""|"",1) </font><font face="courier new">K:</font><font face="courier new">$P($ZTWO,""|"",1)&lt;2 ^XACN(oldcls,acn,cid) S ^XACN($P($ZTVAL,""|"",2),acn,cid)=""""" </font>
                    </div>
                    <div>
                    &nbsp;
                    </div>
                    <p>
                    <font face=Verdana>In the interest of readability most triggerfile definitions in this document are written as complete routines.&nbsp; The code in SemplnoTypeACN50.m handles changes to pieces 1 and 31 of ^ACN(:,50). Note that a SET to ^ACN(:,50) that modifies either or both pieces causes this trigger to execute just once, whereas two sequential SET $Piece() commands, to first modify one piece and then the other cause it to execute twice, at different times, once for each piece.</font>
                    </p>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    &nbsp;
                    <div style="FONT-FAMILY:Courier New">
                    <font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp; EmplnoTypeACN50 ; Update to EMPLNO and/or TYPE in ^ACN(,50) </font>
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">; Capture information&nbsp; </font><br>
                    <font face="courier new">Set oldemplno=$Piece($ZTOLD,"|",31)<br>
                    Set:'$Length(oldemplno) oldemplno=$ZC(254)</font><br>
                    <font face="courier new">Set emplno=$Piece($ZTVAL,"|",31)<br>
                    Set:'$L(emplno) emplno=$ZC(254)</font><br>
                    <font face="courier new">Set oldtype=$Piece($ZTOLD,"|",1)</font><br>
                    <font face="courier new">Set type=$Piece($ZTVAL,"|",1)</font><br>
                    <font face="courier new">Set acn=$Piece(^ACN(cid,99),"|",1)</font><br>
                    <font face="courier new">Set processMode=$Piece($ZTWORM,"|",1)</font>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">If processMode&lt;2 D</font>o<br>
                    <font face="courier new">. Kill ^XREF("EMPLNO",oldemplno,acn,oldtype,cid)&nbsp;<br>
                    . Set ^XREF("EMPLNO",emplno,acn,type,cid)="" </font>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">Q</font>uit&nbsp;<br>
                    </div>
                    <br>
                    <p>
                    <font face=Verdana>The code in SFeeplnACN50.m handles changes to piece 15.</font>
                    </p>
                    <div style="FONT-FAMILY:Courier New">
                    &nbsp;
                    <div style="FONT-FAMILY:Courier New">
                    <font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SFeeplnACN50 ; Update to FEEPLN in ^ACN(,50) </font><br>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div style=MARGIN-LEFT:40px>
                    <font face="courier new">; Capture information </font><font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp;<br>
                    Set oldfeepln=$Piece($ZTOLD,"|",15)<br>
                    Set:'$Length(oldfeepln) oldfeepln=$ZC(254)</font><font face="courier new">&nbsp;&nbsp;&nbsp;&nbsp;<br>
                    Set feepln=$Piece($ZTVAL,"|",15)<br>
                    Set:'$Length(feepln) feepln=$ZC(254)</font><br>
                    <font face="courier new">Set processMode=$Piece($ZTWORM,"|",1)</font>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New">
                    <div style="FONT-FAMILY:Courier New;MARGIN-LEFT:40px">
                    <font face="courier new">If processMode&lt;2 D</font>o&nbsp;<br>
                    <font face="courier new">. Kill ^XREF("FEEPLN",oldfeepln,cid) Set ^XREF("FEEPLN",feepln,cid)=""<br>
                    Quit</font><br>
                    </div>
                    <div style="FONT-FAMILY:Courier New">
                    <div>
                    &nbsp;
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<h2>
  <a id=trigger_error_message_95314458 name=trigger_error_message_95314458></a>Trigger Error Messages&nbsp;
</h2>
<h3 class=titlepage>
  <a id=GVDATAGETFAIL_8969227625057101_22502521181950985 name=GVDATAGETFAIL_8969227625057101_22502521181950985></a>GVDATAGETFAIL
</h3>
<p class=titlepage>
  <b>GVDATAGETFAIL</b>, <i>Global variable DATAGET sub-operation (in KILL function) failed. Failure code: cccc. </i>
</p>
<div>
  &nbsp;
</div>
<p class=titlepage>
  Run Time Trigger Error: The target node for a KILL operation could not present its state to the trigger logic due to a database problem. cccc contains the failure codes for the failed attempts. The database may have integrity errors or the process-private data structures may be corrupted.
</p>
<div>
  &nbsp;
</div>
<p class=titlepage>
  Action: Report this database error to the group responsible for database integrity at your operation.&nbsp;&nbsp;
</p>
<a id=JNLENDIANBIG name=JNLENDIANBIG></a><br>
<h3 class=titlepage>
  <a id=NOZTRAPINTRIG_4783436138845975_8381153391061101 name=NOZTRAPINTRIG_4783436138845975_8381153391061101></a>NOZTRAPINTRIG&nbsp;&nbsp;
</h3>
<div class=titlepage>
  <div>
    <b>NOZTRAPINTRIG</b>, <i>Use of $ZTRAP in a database trigger environment ($ZTLEVEL greater than 0) is not supported.</i>
  </div>
  <br>
  <div>
    Run Time Trigger Error: GT.M requires the use of $ETRAP for error handling within trigger logic.
  </div>
  <br>
  <div>
    Action: Modify the application code to use $ETRAP to handle errors in trigger logic.
  </div>
</div>
<a id=PROCTERM name=PROCTERM></a>
<div class=titlepage>
  <div>
    &nbsp;
  </div>
</div>
<h3 class=titlepage>
  <a id=SETINTRIGONLY_9104180634021759 name=SETINTRIGONLY_9104180634021759></a>SETINTRIGONLY
</h3>
<div class=titlepage>
  <b>SETINTRIGONLY</b>, <i>ISV iiii cannot be modified outside of the trigger environment</i>
</div>
<div class=titlepage>
  <div>
    &nbsp;&nbsp;
  </div>
  <div>
    Run Time Trigger Error: The Intrinsic Special variable iiii can only be SET within the context of trigger logic ($ZTLEVEL &gt; 0)
  </div>
  <div>
    &nbsp;&nbsp;
  </div>
  <div>
    Action: Examine the application logic to determine whether code intended for use in a trigger context falls in an execution path outside of trigger logic. For code intended to execute both inside and outside triggers, use a postcondition that limits the SET to within a trigger.
  </div>
</div>
<br>
<h3 class=titlepage>
  <a id=TRIG2NOTRIG_6193048210852266_3 name=TRIG2NOTRIG_6193048210852266_3></a>TRIG2NOTRIG
</h3>
<div class=titlepage>
  <b>TRIG2NOTRIG</b>, <i>Sending transaction sequence number xxxx which used triggers to a replicator that does not support triggers</i>
</div>
<div class=titlepage>
  <div>
    &nbsp;&nbsp;
  </div>
  <div>
    MUPIP Warning: The source server encountered a transaction that includes triggers, but its replicating node does not support triggers. Unless you are using application level filters to handle this case, your originating instance and replicating instance are no longer consistent.
  </div>
  <div>
    &nbsp;&nbsp;
  </div>
  <div>
    Action: If this case it not handled by your application level filters, you should either enhance your filters or upgrade the replicating instance to a version of GT.M that supports triggers and load the the appropriate trigger definitions with MUPIP TRIGGER (or $ZTRIGGER()), and then take appropriate action (such as recreating the replicating instance from a backup of the originating instance) to restore consistency.&nbsp;&nbsp;
  </div>
</div>
<h3 class=titlepage>
  <a id=TRIGCOMPFAIL_8763801705045893_ name=TRIGCOMPFAIL_8763801705045893_></a>TRIGCOMPFAIL
</h3>
<div class=titlepage>
  <b>TRIGCOMPFAIL</b>, <i>Compilation of database trigger named tttt failed</i>&nbsp;
</div>
<div class=titlepage>
  <div>
    &nbsp;
  </div>
</div>
<div class=titlepage>
  Run Time Trigger Error: The -Xecute code of a trigger specification has syntax errors. Because triggers are precompiled when you define them, this error may indicate that either:<br>
  <br>
</div>
<ul>
  <li>
    A database upgrade was performed but the trigger code was not updated to eliminate obsolete syntax
  </li>
  <li>
    The portion of the database holding the trigger definitions may be corrupted<br>
  </li>
</ul>
<div class=titlepage>
  <br>
  Action: Validate the definitions by a SELECT option with MUPIP TRIGGER or $ZTRIGGER(), correct the trigger code syntax and apply a trigger update.&nbsp;<br>
  <h3 style=COLOR:#0000ff>
    <a id=TRIGDATAIGNORE name=TRIGDATAIGNORE></a>TRIGDATAIGNORE
  </h3>
  <font color=#0000ff><b>TRIGDATAIGNORE</b>,<i> Ignoring trigger data tttt. Use MUPIP TRIGGER to load trigger definitions</i><br>
  <br>
  MUPIP informational message : MUPIP LOAD displays this error when it encounters trigger metadata during extract file processing (GO/ZWR extracts).<br>
  <br>
  Action: Even though the trigger metadata in an extract file is safe, you should only use MUPIP TRIGGER or $ZTRIGGER() to define a trigger. </font><br>
  <h3 style=COLOR:#0000ff>
    <a id=TRIGDEFBAD name=TRIGDEFBAD></a>TRIGDEFBAD
  </h3>
  <font color=#0000ff><b>TRIGDEFBAD</b>, <i>Trigger initialization failed for global ^gggg. Error while processing ^#t("xxxx",yyyy[,zzzz])</i><br>
  <br>
  GT.M/MUPIP error : Missing or corrupted trigger metadata causes this error.<br>
  <br>
  Action:</font> <font color=#0000ff>Delete and replace defective triggers. If possible analyze the cause of the trigger damage and report the incident to your GT.M support channel.<br>
  </font><br>
</div>
<h3 class=titlepage>
  <a id=TRIGINVCHSET_9080986866784484_ name=TRIGINVCHSET_9080986866784484_></a>TRIGINVCHSET
</h3>
<div class=titlepage>
  <b>TRIGINVCHSET</b>, <i>Trigger tttt for global gggg was created with CHSET=cccc which is different from the current $ZCHSET of this process</i>
</div>
<div class=titlepage>
  &nbsp;&nbsp;
</div>
<div class=titlepage>
  Run Time Trigger Error: Trigger tttt on global gggg failed because the process that attempted to update global gggg did not have the same character set that was used to load trigger tttt. &nbsp;Databases with triggers can only be used by processes that are M mode or UTF-8 mode, depending on the mode of the process that loaded the triggers.
</div>
<div class=titlepage>
  <br>
</div>
<div class=titlepage>
  Action: Ensure that processes start with the same character set (as defined by the gtm_chset environment variable) that was used to load the trigger definitions with MUPIP TRIGGER (or $ZTRIGGER() function).
</div>
<h3 class=titlepage>
  <a id=TRIGJNLSTATE_01283656155191159_3022250048913012 name=TRIGJNLSTATE_01283656155191159_3022250048913012></a>TRIGJNLSTATE
</h3>
<div>
  <b>TRIGJNLSTATE</b>, <i>Trigger cannot update journaled database file dddd since triggering update was not journaled</i>
</div>
<br>
<div>
  Run Time Trigger Error: A process performed an update on a global in a database region which is not currently journaled, and that update invoked a trigger that, in turn, attempted an update on a global in a database region that is journaled. The secondary GVIS message provides the global name. This would produce a journal state with insufficient information to ensure proper replication of the region with the triggered update.
</div>
<br>
<div>
  Action: Revise global directories, journaling characteristics, or trigger logic to prevent this situation.&nbsp;&nbsp;
</div>
<h3>
  <a id=TRIGNAMEUNIQ_5537249126379007_ name=TRIGNAMEUNIQ_5537249126379007_></a>TRIGNAMEUNIQ
</h3>
<div>
  <b>TRIGNAMEUNIQ</b>, <i>Unable to make trigger name tttt unique beyond vvvv versions already loaded</i>
</div>
<br>
<div>
  Run Time Trigger Error: GT.M encountered more than vvvv different instances of the same trigger name across database regions used by the same process.
</div>
<br>
<div>
  Action: Revise trigger names to prevent such a high degree of overlap.<br>
  <br>
  <h3>
    <a id=TRIGSUBSCRANGE name=TRIGSUBSCRANGE></a>TRIGSUBSCRANGE
  </h3>
  <br>
  <font color=#0000ff><b>TRIGSUBSCRANGE</b>, <i>Trigger definition for global ^gggg has one or more invalid subscript range(s) : ssss</i><br>
  <br>
  GT.M/MUPIP error : This error indicates one or more invalid subscript range(s) (not matching collated/non-collated subscript ordering) for global gggg in tthe trigger definition files.<br>
  <br>
  Action: Verify the validity of subscript ranges in trigger definition file for the particular global and reload with correct subscript ranges for the collation of the global in question.</font><br>
</div>
<h3>
  <a id=TRIGTCOMMIT_40825184478781307_ name=TRIGTCOMMIT_40825184478781307_></a>TRIGTCOMMIT
</h3>
<div>
  <b>TRIGTCOMMIT</b>, <i>TCOMMIT at $ZTLEVEL=LLLL not allowed as corresponding TSTART was done at lower $ZTLEVEL=BBBB</i>
</div>
<br>
<div>
  Run Time Trigger Error: A TCOMMIT in trigger logic attempted to complete the active transaction that was started outside of the current trigger. Because trigger actions are atomic with the update initiating them, committing a transaction started prior to or by the triggering update cannot be committed inside the trigger.
</div>
<br>
<div>
  Action: Within the trigger context, review the TCOMMIT logic to ensure that it commits only those transactions that are started within the trigger. Ensure that TCOMMIT does not attempt to commit any transaction started prior to or by the triggering update.&nbsp;&nbsp;
</div>
<h3>
  <a id=TRIGTLVLCHNG_5764811123555567_ name=TRIGTLVLCHNG_5764811123555567_></a>TRIGTLVLCHNG
</h3>
<div>
  <b>TRIGTLVLCHNG</b>,<i> Detected a net transaction level ($TLEVEL) change during trigger tttt. Transaction level must be the same at exit as when the trigger started</i>
</div>
<br>
<div>
  Run Time Trigger Error: While the trigger logic can use balanced sub-transactions, it cannot cause a net change in $TLEVEL.
</div>
<br>
<div>
  Action: Review the transaction management (TSTART, TCOMMIT and TROLLBACK) within trigger logic to ensure that it commits or rolls back any transactions it starts and does not attempt to commit any transaction started prior to, or by, the trigger update. You can use TROLLBACK within trigger logic to block the current transaction, possibly to write error context information. Nonetheless if you use such a TROLLBACK, GT.M subsequently signals this error when you leave the trigger context in order to notify the process that the original triggering update has been discarded.<br>
</div>
<h3>
  <a id=ZGOTOINVLVL_8065602728806421_3 name=ZGOTOINVLVL_8065602728806421_3></a>ZGOTOINVLVL
</h3>
<div>
  <b>ZGOTOINVLVL</b>, <i>ZGOTO in a trigger running in mmmm cannot ZGOTO level LLLL</i>
</div>
<br>
<div>
  MUPIP Error: A ZGOTO command in trigger logic attempted to specify an inappropriate destination. Currently that is a ZGOTO in a trigger context with a target level of one (1) and an entryref. GT.M does not support such ZGOTO arguments in MUPIP because there is no context outside that of the trigger.
</div>
<br>
<div>
  Action: Revise the trigger logic to only use ZGOTO with an entryref within the trigger context of trigger logic. Note that you can ZGOTO out of a trigger, but doing so in MUPIP terminates the MUPIP process. FIS recommends limiting the use of ZGOTO to debugging, error handling and testing. Use of ZGOTO in production code, even for error processing, should always be thoroughly tested.<br>
</div>
<h3>
  <a id=ZTRIGINVACT_5534175802365219_8 name=ZTRIGINVACT_5534175802365219_8></a>ZTRIGINVACT
</h3>
<div>
  <b>ZTRIGINVACT</b>, <i>Missing or invalid subcode (first) parameter given to $ZTRIGGER()</i>
</div>
<br>
<div>
  Run Time Trigger Error: The first argument to $ZTRIGGER() is required to specify its mode of action.
</div>
<br>
<div>
  Action: for the first argument of $ZTRIGGER() use an expression that evaluates to "FILE", "ITEM" or "SELECT".
</div>
<h3>
  <a id=ZTRIGNOTP_3144967133369201_257 name=ZTRIGNOTP_3144967133369201_257></a>ZTRIGNOTP
</h3>
<div>
  <b>ZTRIGNOTP</b>, <i>$ZTRIGGER() cannot use update subcodes FILE or ITEM when a TP transaction is in progress ($TLEVEL greater than zero)</i>
</div>
<br>
<div>
  Run Time Trigger Error: A FILE or ITEM operation of $ZTRIGGER() failed because it attempted to apply a trigger definition inside an ongoing transaction. Both FILE and ITEM operations of $ZTRIGGER initiate an implicit transaction to achieve trigger update atomicity, therefore, GT.M does not allow nesting them inside another transaction that potentially might use the very triggers $ZTRIGGER() is attempting to update.
</div>
<br>
<div>
  Action: Move all FILE or ITEM operations of $ZTRIGGER() outside the scope of any open transaction.
</div>
<h3>
  <a id=ZTWORMHOLE2BIG_373249391012786_8961635177962388 name=ZTWORMHOLE2BIG_373249391012786_8961635177962388></a>ZTWORMHOLE2BIG
</h3>
<div>
  <b>ZTWORMHOLE2BIG</b>, <i>String length of LLLL bytes exceeds maximum length of mmmm bytes for $ZTWORMHOLE</i>
</div>
<div>
  <br>
  Run Time Trigger Error: GT.M limits $ZTWORMHOLE length to mmmm bytes and the application attempted to use LLLL bytes.
</div>
<br>
<div>
  Action: Restrict the size of the string stored in $ZTWORMHOLE to mmmm bytes. Ensure that $ZTWORMHOLE only holds the information that the application needs during trigger execution. If necessary, reorganize the logic to reduce the amount of local context needed during trigger execution, possibly by using global variables.<br>
  <br>
  <br>
  <br>
</div>
<p style=TEXT-ALIGN:center>
  <font size=1>For more information, see the <a href=http://www.fis-gtm.com/ id=to_b title=GT.M><font color=#810081>GT.M</font></a> web site.</font><br>
  <br>
</p>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<div class=endnotes>
  <p style="page-break-before:always; TEXT-ALIGN:center">
    notes
  </p>
  <br>
  <br>
  <sup>1 </sup><a name=FOOTNOTE-1></a>A trigger definition file is a text file. You can specify any extension of your choice. For consistency across GT.M documentation and&nbsp; GT.M automated testing systems, we have used .trg as the file extension for a trigger definition file.
</div></body>

<!-- Mirrored from tinco.pair.com/bhaskar/gtm/doc/articles/GTM_Triggers.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Mar 2019 23:00:53 GMT -->
</html>